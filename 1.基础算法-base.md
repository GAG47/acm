# 枚举

# 模拟

# 递归

# 贪心

贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思是问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。

## 排序解法

用排序法常见的情况是输入一个包含几个（一般一到两个）权值的数组，通过排序然后遍历模拟计算的方法求出最优值。

例题：[P1080 [NOIP 2012 提高组\] 国王游戏 - 洛谷](https://www.luogu.com.cn/problem/P1080)

## 后悔解法

思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则，正式接受。如此往复。

**反悔堆**（用优先队列维护）

基本思路就是维护已经被贪心选取的部分，如果新加入的部分与已被选取的部分有冲突，并且新加入的部分加入后结果更好，我们就从已被选取的部分扔掉收益最糟的，替换为新加入的。
[USACO09OPEN Work Scheduling G - 洛谷](https://www.luogu.com.cn/problem/P2949) （用时一定模型）
[P4053 JSOI2007 建筑抢修 - 洛谷](https://www.luogu.com.cn/problem/P4053) （价值一定模型）

例题：
[E - Most Valuable Parentheses](https://atcoder.jp/contests/abc407/tasks/abc407_e)

**反悔自动机**

基本思路就是将当一个部分被贪心加入时，再构造一个新的部分，该部分能够再加入其余新部分的同时撤销已加入部分的限制。
[CF865D Buy Low Sell High - 洛谷](https://www.luogu.com.cn/problem/CF865D)

---

# 差分

在需要进行快速的**区间修改**的操作时，且不需要实时查询或者对查询复杂度要求较低的情况下考虑使用差分。

## 一维差分

假如此时区间修改的范围为 $[l,r]$ ，则更新差分数组 $t_l+1,t_{r+1}-1$，如若需要查询某个元素的值，求差分数组的前缀和即可。

例题：
[F - Sums of Sliding Window Maximum](https://atcoder.jp/contests/abc407/tasks/abc407_f)

>**给你一个长度为 $N$ 的非负整数序列 $A = (A_1,\dots,A_N)$ 。**
>
>**求每个 $k = 1,\dots,N$ 的解：**
>
>- **$A$ 有长度为 $k$ 的 $N-k+1$ 个（连续）子数组。求每个子数组的最大值，并输出这些最大值之和。**
>
>数据范围如下：
>
>- $1 \le N \le 2 \times 10^{5}$
>- $0 \le A_i \le 10^{7}$ ( $1 \le i \le N$ )
>- 所有输入值均为整数。

考虑暴力解法，假设我们能够 $O(1)$ 求出每个子区间的最大值，求和得到答案的时间复杂度高达是 $O(n^2)$。因此考虑两种优化方式：一种是通过上一次求解的结果推导出下一次的结果；另一种则是考虑每一个元素对每个答案的贡献。对于前者，由于每次子区间的长度增加或减少，每个子区间的最大值的变化都与其元素的具体值有关，难以归纳出具体的规律。而对于后者，容易想到先通过**单调栈**求出前后第一个比自身大的元素位置，然后据此考虑对每个答案的贡献；但是如果逐一考虑对所有有影响的区间的贡献，时间复杂度为 $O(n*(r-l))$，$r$,$l$ 分别表示右左比自身大的元素的位置，如果整个数组单调，复杂度退化为 $O(n^2)$ ，因此不能直接更新值；因而考虑更新**差分数组**，然后最后累加得到结果。

现考虑如何进行差分，假设现在有一个下标为 $i$ 的元素 $a_i$ ，其左右第一个比它大的元素位置为 $l$ ，$r$，讨论的子区间的长度为 $len$ ,则容易发现:
当 $len$ 长度介于 $1$ 到 $min(i-l,r-i)$ 的时候，贡献次数只与 $len$ 长度相关；
当 $len$ 长度介于 $min(i-l,r-i)$ 到 $max(i-l,r-i)$ 的时候，则贡献次数与 $len$ 长度无关，只与 $min(i-l,r-i)$ 有关。
当 $len$ 长度介于 $max(i-l,r-i)$ 到 $i-l+r-i$ 的时候，则 $len$ 每次增长，贡献次数反而减少。

因此

## 二维差分

## 树上差分



























