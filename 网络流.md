# 网络流

## 最大流

### FF

这是一种时间复杂度为 $O(fm)$ 的算法，$f$ 为最大流。

~~~c++
int n, m, s, t; // s是源点，t是汇点
bool vis[MAXN];
int dfs(int p = s, int flow = INF)
{
    if (p == t)
        return flow; // 到达终点，返回这条增广路的流量
    vis[p] = true;
    for (int eg = head[p]; eg; eg = edges[eg].next)
    {
        int to = edges[eg].to, vol = edges[eg].w, c;
        // 返回的条件是残余容量大于0、未访问过该点且接下来可以达到终点（递归地实现）
        // 传递下去的流量是边的容量与当前流量中的较小值
        if (vol > 0 && !vis[to] && (c = dfs(to, min(vol, flow))) != -1)
        {
            edges[eg].w -= c;
            edges[eg ^ 1].w += c;
            // 这是链式前向星取反向边的一种简易的方法
            // 建图时要把cnt置为1，且要保证反向边紧接着正向边建立
            return c;
        }
    }
    return -1; // 无法到达终点
}
inline int FF()
{
    int ans = 0, c;
    while ((c = dfs()) != -1)
    {
        memset(vis, 0, sizeof(vis));
        ans += c;
    }
    return ans;
}
~~~



### EK

这是一种时间复杂度上限为 $O(nm^2)$ 的算法。

~~~c++
...

struct Edge
{
    ll to,w,nex;
}edge[MAXM];
int head[MAXN],cnt=1;
void add(int from,int to,int w)
{
    edge[++cnt].to=to;
    edge[cnt].w=w;
    edge[cnt].nex=head[from];
    head[from]=cnt;
}

ll n,m,s,t,last[MAXN],flow[MAXN];
inline int bfs()
{
    memset(last,-1,sizeof(last));
    queue<int>que;
    que.push(s);
    flow[s]=INF;
    while(!que.empty())
    {
        int p=que.front();
        que.pop();
        if(p==t) //到达汇点 结束搜索
        {
            break;
        }
        for(int eg=head[p];eg;eg=edge[eg].nex)
        {
            ll to=edge[eg].to,val=edge[eg].w;
            if(val>0 && last[to]==-1) //残余容量大于0且未访问过
            {
                last[to]=eg;
                flow[to]=min(flow[p],val);
                que.push(to);
            }
        }
    }
    return last[t]!=-1;
}
inline ll EK()
{
    ll maxflow=0;
    while(bfs())
    {
        maxflow+=flow[t];
        for(int i=t;i!=s;i=edge[last[i]^1].to)
        {
            edge[last[i]].w-=flow[t]; //保证正反边恰好占据奇偶数
            edge[last[i]^1].w+=flow[t]; //并且不用0 1 （0为边界点）
        }
    }
    return maxflow;
}

void solve()
{
    cin>>n>>m>>s>>t;
    int u,v,w;
    for(int i=1;i<=m;++i)
    {
        cin>>u>>v>>w;
        add(u,v,w);
        add(v,u,0);
    }
    cout<<EK();
}
...
~~~

### Dinic

这是一种时间复杂度上限为 $O(n^2m)$ 的算法，在**稠密图**中，比 $EK$ 算法有更好的效率。

~~~c++
struct Edge
{
    ll to,w,next;
}edge[MAXM];
ll head[MAXN],cnt=1;
void add(int from,int to,ll w)
{
    edge[++cnt].to=to;
    edge[cnt].w=w;
    edge[cnt].next=head[from];
    head[from]=cnt;
}

ll n,m,s,t,lv[MAXN],cur[MAXN]; //lv是层数 cur是当前弧优化
inline bool bfs() //bfs负责分层
{
    memset(lv,-1,sizeof(lv));
    memcpy(cur,head,sizeof(head));
    lv[s]=0;
    queue<int>que;
    que.push(s);
    while(!que.empty())
    {
        int q=que.front();
        que.pop();
        for(int i=head[q];i;i=edge[i].next)
        {
            int to=edge[i].to,val=edge[i].w;
            if(val>0&&lv[to]==-1) //未更新过深度则更新
            {
                lv[to]=lv[q]+1,que.push(to);
            }
        }
    }
    return lv[t]!=-1;
}
ll dfs(int p=s,ll flow=INF)
{
    if(p==t) return flow;
    ll rmn=flow; //剩余的流量
    for(int i=cur[p];i&&rmn;i=edge[i].next) //没有剩余流量就退出
    {
        cur[p]=i; //当前弧优化
        ll to=edge[i].to,val=edge[i].w;
        if(val>0&&lv[to]==lv[p]+1) //只传向更深的层
        {
            int c=dfs(to,min(val,rmn));
            rmn-=c; //剩余流量减少
            edge[i].w-=c;
            edge[i^1].w+=c;
        }
    }
    if(rmn==flow) lv[p]=0; //如果一点没流出去，在这个dfs内就没必要再访问了
    return flow-rmn; //返回传递出去的流量大小
}
inline ll dinic()
{
    ll ans=0;
    while(bfs())
    {
        ans+=dfs();
    }
    return ans;
}
~~~

### ISAP

## 费用流

### EK+SPFA

~~~c++
int head[MAXN],cnt=1;
struct Edge
{
    int to,w,c,next;
}edge[MAXM*2];
inline void add(int from,int to,int w,int c)
{
    edge[++cnt].to=to;
    edge[cnt].w=w;
    edge[cnt].c=c;
    edge[cnt].next=head[from];
    head[from]=cnt;
}

int n,m,s,t,last[MAXN],flow[MAXN],inq[MAXN],dist[MAXN];
queue<int>que;
bool SPFA()
{
    while(!que.empty()) que.pop();
    memset(last,-1,sizeof(last));
    memset(inq,0,sizeof(inq));  //是否在队列中
    memset(dist,127,sizeof(dist));  //距离源点的最小距离
    flow[s]=INF;
    dist[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int q=que.front();
        que.pop();
        inq[q]=0;
        for(int i=head[q];i;i=edge[i].next)
        {
            int to=edge[i].to,val=edge[i].w;
            if(val>0&&dist[to]>dist[q]+edge[i].c)
            {
                last[to]=i; //记录上一条边
                flow[to]=min(flow[q],val); //更新下一个点的流量
                dist[to]=dist[q]+edge[i].c;
                if(!inq[to])
                {
                    que.push(to);
                    inq[to]=1;
                }
            }
        }
    }
    return last[t]!=-1;
}
int maxflow,mincost;
inline void MCMF()
{
    while(SPFA())
    {
        maxflow+=flow[t];
        mincost+=dist[t]*flow[t];
        for(int i=t;i!=s;i=edge[last[i]^1].to) 
        {
            edge[last[i]].w-=flow[t];
            edge[last[i]^1].w+=flow[t];
        }   
    }
}
~~~

## 二者取一模型



## 对偶图优化最小割

结论：**求一个网络流的最小割等价于求其对偶图的最短路**
这个结论十分具象且符合直觉，对偶图上的没一个经过所有点的简单路径，必然将原图的节点分为两个集合。这可以由对偶图的性质与定义简单得出。而一般在求解该问题时，不会直接求对偶图上的最短路，而是会把**图外连通块**所化的点分割为起点与终点，然后再跑最短路，一般情况下，时间复杂度可以将一个半级别。
![img](https://cdn.luogu.com.cn/upload/pic/63309.png)

[[ICPC-Beijing 2006] 狼抓兔子(对偶图求最小割板题)](https://www.luogu.com.cn/problem/P4001)



# 网络流24题



## 2、[飞行员配对方案问题](https://www.luogu.com.cn/problem/P2756)

**题意**：第二次世界大战期间，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的两名飞行员，其中一名是英国飞行员，另一名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。一共有 $n$ 个飞行员，其中有 $m$ 个外籍飞行员和 $(n - m)$ 个英国飞行员，**外籍飞行员从 $1$ 到 $m$ 编号**，**英国飞行员从 $m + 1$ 到 $n$ 编号**。 对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。

**题解**：网络流中最基础的一类题目：**二分图最大匹配**。英国和外籍分别作为一个集合，中间的边表示可以很好配合，求最大匹配即可。网络流的求法：所有的英国/外籍与源点建立流量为 $1$ 的边，另一个则与汇点建立流量为 $1$ 的边，求最大流即可。



## 3、[软件补丁问题 ](https://www.luogu.com.cn/problem/P2761)

**题意**：
T 公司发现其研制的一个软件中有 $n$ 个错误，随即为该软件发放了 $m$ 个补丁程序。
每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。
换句话说，对于任意一个补丁 $i$，都有四个与之相应的集合 $B1_i,B2_i,F1_i$ 和 $F2_i$。仅当软件包含 $B1_i$ 中的所有错误，而不包含 $B2_i$ 中的任何错误时，才可以使用补丁 $i$。补丁 $i$ 将修复软件中的某些错误集合 $F1_i$，而同时加入另一些错误 $F2_i$。另外，运行每个补丁都耗费一定的时间。
试设计一个算法，利用 T 公司提供的 $m$ 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的 $n$ 个错误和 $m$ 个补丁程序，找到总耗时最少的软件修复方案。

**题解**：
这道题其实不是网络流。(😡)，将错误状态用二进制表示，再转化为十进制数字来表示该状态，补丁作为边来连接节点（依靠 **|，&，^** 等位运算来判断与操作），跑最短路即可。



## 4、[负载平衡问题](https://www.luogu.com.cn/problem/P4016)

**题意**：
$G$ 公司有 $n$ 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 $n$ 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。

**题解**：
先对所有仓库的货物数量求和，求出仓库最后应当由的库存数量。
1、所有仓库与源点建立流量为**库存数量**，权值为 $0$ 的边。
2、所有仓库与汇点建立流量为**平均库存数量**，权值为 $0$ 的边。
3、相邻仓库之间建立权值为 $INF$ ，权值为 $1$ 的边。
求费用流的费用即可。



## 5、[运输问题](https://www.luogu.com.cn/problem/P4015)

**题意**：

$W$ 公司有 $m$ 个仓库和 $n$ 个零售商店。第 $i$ 个仓库有 $a_i$ 个单位的货物；第 $j$ 个零售商店需要 $b_j$ 个单位的货物。货物供需平衡，即$\sum\limits_{i=1}^{m}a_i=\sum\limits_{j=1}^{n}b_j$。
从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用为 $c_{ij}$ 。
试设计一个将仓库中所有货物运送到零售商店的运输方案，使总运输费用最少。

**题解**：

网络流又一经典模型：**二分图最小权最大匹配**。将仓库当作一集合，零售店当作另一集合，运货作为边，运货费用作用边的权值。派一边费用流即可。



## 5、[(圆桌问题)](https://www.luogu.com.cn/problem/P3254)

**题意**：
有来自 $m$ 个不同单位的代表参加一次国际会议。第 $i$ 个单位派出了 $r_i$ 个代表。
会议的餐厅共有 $n$ 张餐桌，第 $i$ 张餐桌可容纳 $c_i$ 个代表就餐。
为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。请给出一个满足要求的代表就餐方案。

**题解**：
依旧是**二分图求最大匹配**。单位和餐桌分别作为一个集合，单位与源点建立流量为 $r_i$ 的边，餐桌与汇点建立流量为 $c_i$ 的边，每个单位向每个餐桌指出一条流量为 $1$ 的边，跑一遍最大流。如果最大流不等于代表总数目则无方案；反之则有，此时遍历两个集合内的正向边，如果流量为 $0$ 说明该边已经被跑过，记录两个端点，如果分别为单位和餐桌，则记录答案。



## 6、[试题库问题](https://www.luogu.com.cn/problem/P2763)

**题意**：
假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。

**题解**：
二分图匹配问题。题目和试卷分别作为一个集合，题目与源点连接流量为 $1$ 的边，类型与汇点连接流量为题目数量的边，在通过题的属性连边，跑最大流即可。如果最大流不等于代表总数目则无方案；反之则有，此时遍历两个集合内的正向边，如果流量为 $0$ 说明该边已经被跑过，记录两个端点，如果分别为题目和试卷，则记录答案。（这道题和上一道基本一模一样）。



## 7、[骑士共存问题](https://www.luogu.com.cn/problem/P3355)

**题意**：

在一个 $n \times n$ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

对于给定的 $n \times n$ 个方格的国际象棋棋盘和障碍标志，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。

**题解**：
在不考虑障碍的情况下，容易想到对所有一次可达的格子建边，转化为求图的**最大独立集**；现考虑障碍，只需要不将障碍所在节点放入图中即可。又容易发现，如果把棋盘上的格子分为奇偶两种类型（图中红黄），则马每次移动都会改变自己格子所在的奇偶性质，因而考虑使用**二分图**，将奇偶格子分别作为一个集合，那么有最大独立集=节点数-最小点覆盖，根据**康拓定理**，有最小点覆盖=最大匹配，因而该题可以转化为求**二分图最大匹配**，求出最大流后，答案即为 $ans=n*n-m-maxflow$。

或者用**最小割**的角度理解也可，我们用所有可放置马的节点建边，依旧按照奇偶格子建立二分图：
1、所有奇格子与源点建立流量为 $1$ 的边
2、所有偶格子与汇点建立流量为 $1$ 的边
3、可互相到达的奇偶格子建立流量为 $INF$ 的边
因为最小割=最大流，此时求出最大流即可。为什么？因为最小割是**割去边使得源点汇点分为两个互相不可达的集合的最小代价**，而这个建图方式中奇偶格子之间的边的权值都是无穷，不可能割去，因此只能割去边类型 $1$ 和类型 $2$ ，割去某个节点连接的边表示不取该节点，则剩下的节点保证不存在冲突，且由于最小割是最小代价，因此剩下的节点即是符合条件的最大值。（其实最大匹配就是用最小割的思想罢🤔）



## 9、[方格取数问题](https://www.luogu.com.cn/problem/P2774)

**题意**：
有一个 $m$ 行 $n$ 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。

**题解**：
相邻格子不能同时取，容易想到对相邻格子建边，然后求总权值和减去最小割即可。



## 10、[汽车加油行驶问题](https://www.luogu.com.cn/problem/P4009)

**题意**：给定一个 $N \times N$ 的方形网格，设其左上角为起点◎，坐标$(1,1)$，$X$ 轴向右为正， $Y$ 轴向下为正，每个方格边长为 $1$ ，如图所示。



 ![](https://cdn.luogu.com.cn/upload/pic/12156.png) 

一辆汽车从起点◎出发驶向右下角终点▲，其坐标为 $(N,N)$。


在若干个网格交叉点处，设置了油库，可供汽车在行驶途中加油。汽车在行驶过程中应遵守如下规则:


1. 汽车只能沿网格边行驶，装满油后能行驶 $K$ 条网格边。出发时汽车已装满油，在起点与终点处不设油库。

2. 汽车经过一条网格边时，若其 $X$ 坐标或 $Y$ 坐标减小，则应付费用 $B$ ，否则免付费用。

3. 汽车在行驶过程中遇油库则应加满油并付加油费用 $A$。

4. 在需要时可在网格点处增设油库，并付增设油库费用 $C$(不含加油费用$A$ )。

5. $N,K,A,B,C$ 均为正整数， 且满足约束: $2\leq N\leq 100,2 \leq K \leq 10$。

设计一个算法，求出汽车从起点出发到达终点所付的最小费用。

**题解**：

容易想到将坐标 $X、Y$ 和油量 $K$ 作为一个状态的三个决定性信息，故使用分层图来表示这三个状态的互相转换。这样只需要在分层图上跑一种算法可以求出从起点到终点的最小费用即可，容易想到使用最短路算法，边的权值即是花费的费用。建边方式（假设现在位于 $(x,y,k)$）：
1.向 $(x+1,y,k-1)$ 与 $(x,y+1,k-1)$ 分别建立权值为 $0$ 的边，向$(x-1,y,k-1)$ 与 $(x,y-1,k-1)$建立权值为 $B$ 的边，注意特判 $k=0$ 的情况即可。。
2.如果 $(x,y)$ 有加油站，则向 $(x,y,K)$ 建立一条权值为 $A$ 的边。
3.向 $(x,y,K)$ 建立一条权值为 $A+C$ 的边。
4.源点为 $(1,1,K)$ ，终点为 $(n,m,\sum_{k=0}^{K}k)$
虽然说是用最短路解的，但是跑费用流也是可以的。



## 11、[家园 / 星际转移问题](https://www.luogu.com.cn/problem/P2754)

**题意**：
由于人类对自然资源的消耗，人们意识到大约在 2300 年之后，地球就不能再居住了。于是在月球上建立了新的绿地，以便在需要时移民。令人意想不到的是，2177 年冬由于未知的原因，地球环境发生了连锁崩溃，人类必须在最短的时间内迁往月球。
现有 $n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而太空船的容量是有限的，第 $i$ 艘太空船只可容纳  $h_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如 $(1,3,4)$ 表示该太空船将周期性地停靠太空站 $134134134\dots$。每一艘太空船从一个太空站驶往任一太空站耗时均为 $1$。人们只能在太空船停靠太空站(或月球、地球)时上、下船。
初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。

**题解**：
因为飞船在不同的时间在不同的节点，同一个节点在不同的时间有不同的性质，容易想到将所在的位置 $x$ 和现在的时间 $t$ 作为一个状态的两个决定性信息，那么考虑使用分层图，按照如下方式建边（假设位于空间站 $x$ ，时间为 $t$）:
1.与 $(x,t+1)$ 建立流量为 $INF$ 的边
2.与 $(此时在x的飞船的下一站y,t+1)$建立流量为飞船荷载的边
3.（地球，0）与源点建边，（月球，any）与汇点建边
但是，现在遇到一个问题，时间 $t$ 的上限也就是要求姐的答案，是不确定的，那么要用什么算法去利用这图呢？考虑不断增大 $t$，每次加入对应的边，并跑一遍残量网络流，用 $dinic$ 算法去跑，时间复杂度上也不算很差。































