# 基础

快速判断两个数字内奇数的个数

~~~C++
num=(r-l+!(l%2))/2+(l%2);
~~~



# 快速幂

用正常的方式来计算幂，时间复杂度为 $O(n)$，这样显然浪费了cpu的算力。因而可以高效地用**二分**的方法来算：
$$
a[n]=
\begin{cases}
a[n/2]*a[n/2] (n=2*k)\\
a[(n+1)/2]*a[(n-1)/2](n=2*k+1)\\
1 (n=1)
\end{cases}
$$
**递归写法**

~~~c++
int qpow(int a,int n)
{
    if (n==0) return 1;
    else if(n%2==1) return qpow(a,n-1)*a;
    else{
        int temp=qpow(a,n/2);  //不能将函数写两次，否则时间复杂度会退化到 O(n)
        return temp * temp;
    }
}
~~~

**非递归写法**

~~~c++
int qpow(int a,int n)
{
    int ans=1;
    while(n){
        if (n&1) ans*=a;
        a*=a;
        n>>=1;
    }
    return ans;
}
~~~

将 $n$ 用二进制表示，如果 $(n)2$ 的最后一位是一，则代表答案要乘上这一位。

每次循环a自乘一保证每次ans可以正确表示进制。

## 矩阵快速幂

[【模板】矩阵快速幂 - 洛谷](https://www.luogu.com.cn/problem/P3390)
给定 $n*n$ 的矩阵 $A$ ，求 $A^k$。

~~~c++
~~~



# 素数筛

## 埃氏筛

埃氏筛是一种 $O(nloglogn)$ 的算法，基本思路就是每遍历到一个新质数，就标记它的所有在 $n$ 范围内的合数。

~~~c++
int n,prime[MAXN],cnt=0;
bool notprime[MAXN];
void get_prime()
{
	for(int i=2;i<=n;++i){
		if(!notprime[i]) prime[++cnt]=i;
		for(int j=i*2;j<=n;j+=i)
			notprime[j]=true;
	}
}
~~~

---

## 欧拉筛

埃氏筛时间复杂度不是完全线性的原因在于其在标记合数的时候，会有一个合数被**多次标记**。
我们在埃氏筛的基础上保证每一个合数只能被其**最小质因数**和另一个数的乘积标记，以排除多次标记的情况，时间复杂度可以优化到 $O(n)$。

~~~c++
int n,prime[MAXN],cnt=0;
bool notprime[MAXN];
void get_prime()
{
	for(int i=2;i<=n;++i){
		if(!notprime[i]) prime[++cnt]=i;
		for(int j=1;1ll*prime[j]*i<=n;++j){
			notprime[prime[j]*i]=true;
			if(i%prime[j]==0) break;  //i是prime[j]的倍数，则退出
            						//假设不退出，prime[j+1]更新的合数的最质因数就是prime[j]
            						//而并非prime[j+1],这样子便会导致重复更新，故此时就退出循环
		}
	}
}
~~~

### 欧拉函数

**$1$~$n$ 中与 $n$ 互质的个数**被称为欧拉函数,一般用 $φ(n)$ 表示

- $φ(1)=1$。
- 若 $p$ 是质数，则 $φ(p) = p-1$。
- 若 $p$ 是质数，则 $φ(p^k)=(p-1)p^{k-1}$
- 积性函数: 若 $gcd(n,m)=1$ ，则 $φ(mn)=φ(n)φ(m)$

**证明**：

> **通过唯一分解定理 $n=\prod_{i=1}^{s}p_i^{α_i}...p_s^{α_s}$ 来得到 $φ(n)$。具体过程为：先使用性质③，在使用性质②，再用一次唯一分解定理，然后即可得到结果为 $n\times\frac{p_1-1}{p_1}\times...\times\frac{p_s-1}{p_s}$。说明欧拉函数仅由 $n$ 和质因数有关，与质因子的次数无关。**

求解一个数字的欧拉函数，可以通过试除法。也可以通过**筛法**来在线性时间内求解一段区间内的数字的欧拉函数。
我们用欧拉筛的原理来求每一个数字的欧拉函数：
① 假如选取数字是素数，则 $\phi(x) = x-1$；
②在素数标记合数的过程中，假如 $i$ 不是 $p_j$ 的倍数，说明这两个数字**互质**，则 $\phi(i*p_j)=\phi(i)*\phi(p_j)$，由于 $\phi(i)$ 之前已经被求解出来了，因而可以递推求出；
③ 假如 $i$ 是 $p_j$ 的**倍数**，则 $i$ 有 $m$ 有的所有素数，则可以得到递推关系 $\phi(m) = m\times\frac{p_1-1}{p_1}\times...\times\frac{p_s-1}{p_s}=p_j\times i\times\frac{p_1-1}{p_1}\times...\times\frac{p_s-1}{p_s}=p_j\times \phi(i)$ 。

~~~c++
int n,phi[MAXN],prime[MAXN],cnt=0;
bool notprime[MAXN];
void get_phi()
{
	for(int i=2;i<=n;++i){
		if(!notprime[i]){
			prime[++cnt]=i;
			phi[i]=i-1;
		}
		for(int j=1;1ll*i*prime[j]<=n;++j){
			ll temp=i*prime[j];
			notprime[temp]=1;
			if(i%prime[j]==0){
				phi[temp]=prime[j]*phi[i];
				break;
			}
			phi[temp]=(prime[j]-1)*phi[i];
		}
	}
}
~~~

### 约数个数

###  

# 费马小定理

**同余式**：如果两个整数 $a,b$ 模 $m$ 的余数相同，则称 $a,b$ 模 $m$ 同余，记为
$$
a\equiv b\pmod m
$$
**乘法逆元**：若 $a,b$ 互质，则满足同余方程 $ax \equiv 1 \pmod b$ ，则称 $x$ 为 $a$ 模 $b$ 的乘法逆元，记作 $a^{-1}$。

**费马小定理**：若 $p$ 是质数，且 $a,p$ 互质，则 $a^{p-1} \equiv 1 \pmod p$。  



# GCD

$gcd$ ，即最大公共因子，一般求它的方法是**辗转相除法**，详情见代码：

~~~c++
int gcd(int a, int b)
{
    if (b == 0)
        return a;
    else
        return gcd(b, a%b);
}
~~~

一般题目中不会有直接求 $gcd$ 这么简单的题目，一般会把 $gcd$ 和其他东西连在一起，比如线段树维护 $gcd$；有时候 $gcd$ 还会在一些奇怪的地方出现：

>**现给出一序列，可对该序列进行如下操作：选定序列重任意两个元素 a[i]>a[j], 并将 a[i] 置为 a[i]+a[j] 或者 a[i] - a[j], 求通过该操作序列能到达的正整数的最小值。**

这个操作与辗转相除法其实是一致的，所以最后的最小值必然是整个序列的 $gcd$（这其实是一个定理，），并且序列中所有可达的元素都是 $gcd$ 的倍数。



# 裴蜀定理

>**一定存在整数 $x,y$ ，满足 $ax+by=gcd(a,b)$。**

拓展：

>**一定存在整数 $x,y$ ，满足 $ax+by=n*gcd(a,b)$ 。**

再拓展

>**一定存在整数 $X_1...X_n$ ，满足 $\sum_{1}^{n}A_iX_i=n*gcd(A_1,A_2...A_n)$。** 



# 拓展欧几里得

## 求不定方程

>**求解 $ax+by=gcd(a,b)$的一组整数解**。

根据**欧几里得定理**有 $\gcd(a,b)=\gcd(b,a\%b)\\$
又有:$ax+by=\gcd(a,b),bx+(a\%b)y=\gcd(b,a\%b)\\$
所以有 $ax+by=bx+(a\%b)y$ 
经过化简得到：$ax+by=ay+b(x-\frac{a}{b}*y)$


通过辗转相除法层层即可求出**特解** $x_0,y_0$。

又有**通解**：
$$
\left\{
    \begin{array}{r}
        x=x_0+\frac{b}{gcd(a,b)}*k\\
        y=y_0+\frac{a}{gcd(a,b)}*k
    \end{array}
\right.
$$

## 同余方程

>**给定整数 $a,b,m$，求解同余方程 $ax \equiv b\pmod m$。**

因为这道题没有满足 $m$ 为**质数**的条件，所以不能够使用**费马小定理**。
因此考虑把**同余方程转化为不定方程**：
$$
ax\equiv b\pmod m \\
ax=m(-y)+b \\
ax+my=b
$$
又根据**裴蜀定理**有：当 $\gcd(a,m)|b$ 时有解，此时使用**扩展欧几里得**即可。

## 乘法逆元

> $a$ 与 $m$ 互质时，对于方程 $ax\equiv 1\pmod m$ 。即求 $a$ 的乘法逆元 $x\pmod m$ 。

解法与求**同余方程**一致。



# 中国剩余定理(CTR)

>**求解线性同余方程组**
>$$
>\left\{
>    \begin{array}{m}
>    	x\equiv r_1\pmod {m_1}\\
>    	x\equiv r_1\pmod {m_1}\\
>    	\vdots\\
>    	x\equiv r_1\pmod {m_1}\\
>    \end{array}
>\right.
>$$
>其中模数 $m_1,m_2,\dots,m_n$ 为两两互质的整数，求 $x$ 的最小非负整数解。











































