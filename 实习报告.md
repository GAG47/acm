# 动态规划

## 线性动态规划

### 线性dp

#### 最长上升子序列（LIS）

**求长度**

**最长上升子序列**（Longest Increasing Subsequence，**LIS**），是求数列中最长的单调增的子序列（不一定连续）的长度。

朴素的方法，使用dp记录以每个点为终点的LIS长度，然后遍历序列左侧的点寻找满足 $a[i] < b[j]$  的 $dp[i]$ 最大值，显然时间复杂度是 $O(N^2)$ 。那么接下来介绍一种时间复杂度为 $O(NlogN)$ 的算法。

依旧考虑维护一个数组 $dp[]$ ，$dp[i]$ 存储的是遍历到 $i$ 时填入 $LIS$ 的各个元素的最小值，用 $len$ 来表示数列长度。那么在遍历到下一个数字时候：进行的操作可分为：

$a[i + 1] > a[i]$ 时，将 $a[i + 1]$ 填入 $dp[++len]$ 。

 $a[i + 1] < a[i]$ 时，用 $a[i + 1]$ 替换 $dp$ 数组中大于 $a[i+1]$ 的第一个数 。

那么使用$二分查找$,则可以让时间复杂度降为 $O(NlogN)$ 。

 核心代码

~~~c++
int LIS()  //求最长上升子序列
{
	int len = 0;
	for (int i = 1; i <= n; ++i) {
		if (dp[len] < a[i]) {
			dp[++len] = a[i];
			ans[i] = len;
		}
		else {
			int k = lower_bound(dp + 1, dp + len + 1, a[i]) - dp;
			dp[k] = a[i];
			ans[i] = k;
		}
	}

	return len;
}
~~~

代码实现(以例题[导弹拦截](https://www.luogu.com.cn/problem/P1020)为例)

~~~c++
#include <bits/stdc++.h>
using namespace std;
int A[100005], dp[100005];
int main()
{
    int n = 0, len = 0;
    while (cin >> A[n])
        n++;
    memset(dp, 127, sizeof(dp)); // 其实这里只需要初始化dp[0]为INF即可
    for (int i = 0; i < n; ++i)
    {
        if (dp[len] >= A[i])
            dp[++len] = A[i];
        else
            *upper_bound(dp + 1, dp + len + 1, A[i], greater<int>()) = A[i];
    }
    cout << len << endl;
    len = 0;
    memset(dp, 0, sizeof(dp));
    for (int i = 0; i < n; ++i)
    {
        if (dp[len] < A[i])
            dp[++len] = A[i];
        else
            *lower_bound(dp + 1, dp + len + 1, A[i]) = A[i];
    }
    cout << len << endl;
    return 0;
}
~~~

**（Dilworth定理）**

> **对于一个偏序集，最少链划分等于最长反链长度。**

这道题的第二问可以用贪心来做，也可用上面这个定理来做（很像匈牙利算法中的一个定理）

**求具体元素**

如果要求LIS的具体序列，可以使用pre存储每个dp值前面的dp值

~~~c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 100;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n, a[MAXN], dp[MAXN], ans[MAXN]; //ans统计到这个位置的元素是在dp中的什么位置
stack <int> sta;

int LIS()
{
	int len = 0;
	for (int i = 1; i <= n; ++i) {
		if (dp[len] < a[i]) {
			dp[++len] = a[i];
			ans[i] = len;
		}
		else {
			int k = lower_bound(dp + 1, dp + len + 1, a[i]) - dp;
			dp[k] = a[i];
			ans[i] = k;
		}
	}
	return len;
}

int main()
{
	cin>>n;
	for(int i=1;i<=n;++i)
		cin>>a[i];

	int m = LIS();

	for (int i = n; i >= 1; i--) {
		if (ans[i] == m) {
			sta.push(a[i]);
			m--;
		}
	}

	while (!sta.empty()) {
		cout << sta.top() << " ";
		sta.pop();
	}

	return 0;
}
~~~

----

#### 最大连续子段和

基本问题概述：给出一个数组，求数组任意**子串的和的最大值**。
思路：遍历该数组，用 $dp$ 数组维护到达字串末尾围为第 $i$ 个元素时子串和的最大值。假如 $dp[i-1]+a[i]<a[i]$ 说明应当直接舍弃之前的字串，否则就应该继承。

~~~c++
for(int i=1;i<=n;++i)
{
    dp[i]=max(a[i],dp[i-1]+a[i]);
    ans=max(ans,dp[i]);
}
~~~

这里的 $dp[i]$ 可以直接用一个变量代替。

~~~c++
int cur=a[i];
for(int i=2;i<=n;++i)
{
    cur=max(a[i],cur+a[i]);
    ans=max(ans,dp[i]);
}
~~~

#### 限制元素的最大连续字段和

**长度至少为m**

上面那个问题实在是太简单，但是我们还可以扩展，求给出数组的**个数不少于m个**的最大连续字段和。
这个算法与之前算法最大的区别在于，对于 $dp$ 数组（连续字段某尾为 $i$ 的和最大值），仅仅**维护末端**是不够，我们还要维护**子段前端**。但由于每次在递推过程中，只有在舍弃前面字段的时候现在选取的字段会变短，**且长度变成1**，那我们直接将其**长度变为m**杰克，因此求法实际上与求一个的一致，只需在 $dp$ 数组更新的时候，如果舍弃前面的部分，需要将 $cur$ 值更新为连续 $m$ 个元素的和。

~~~c++
for(int i=1;i<=n;++i)
{
	pre[i]=a[i]+pre[i-1]; //前缀和
}
int cur=pre[m];
for(int i=m+1;i<=n;++i)
{
    cur+=a[i];
    cur=max(cur,pre[i]-pre[i-m]);
    ans=max(cur,ans);
}
~~~

**长度至多为m**

接下来考虑**元素不多于m个**的情况。那自然就是需要限制在**子段加长**的过程，也就是不舍弃之前字段的递推过程。接下俩考虑这个子段前端什么时候会更新：①在舍弃之前子段时；②之前子段长度已经到达 $m$ 。对于①情况，直接在递推的时候判断更新就可以了。对②情况，我们需要考虑将 $last$ 更新到什么位置使得 $dp[i]$ 最大，直接遍历找到最大的位置并赋值给 $last$ 即可（该位置应当尽量靠后）,这样子时间复杂度在极限条件下竟然到达了惊人的 $O(nm)$！咱们考虑一下怎么优化

~~~c++
//该模型未经过题目验证，有很大wa的可能，请谨慎使用
for(int i=1;i<=n;++i)
{
	pre[i]=a[i]+pre[i-1]; //前缀和
}
int cur=a[i],last=i
for(int i=2;i<=n;++i)
{
    cur+=a[i];
    if(a[i]>=cur) //由于我们希望求到尽量大的值 那我们应当希望子段尽可能的短，以留下更多位置
    {
        cur=a[i];
        last=i;
    }
    else if(i-last>=m) //该删去	
    {
        
    }
    ans=max(cur,ans);
}
~~~

**种类至少/至多为m**

再考虑**元素种类至少为m**个的情况。可以考虑使用**双指针**。

#### 可以取m段的最大连续字段和

**板子题**：[[题解\]HDU1024 Max Sum Plus Plus - Sinktank - 博客园 (cnblogs.com)](https://www.cnblogs.com/Sinktank/p/18092722)
注意：我在这道题里的解法 与 网上常规解法 并不相同。

---

### 状压dp

状压dp可以用于解决许多需要**枚举**子集或排列的问题。

首先将每个节点**抽象出两个状态**（如选取或不选取），分别用01表示，将所有节点的状态情况按序排列可以得到一个**二进制数**，该二进制数即可不重复不遗漏地表示节点状态的所有可能情况。将二进制转化为十进制，并作为递归数组的 $key$ ，那么即可遍历所有可能的状态。

由于 $2^{20}$ 已达到 $1e6$ 次，因而状压dp只适用于状态节点数较少的情况。

经典的状压dp问题有 **旅行商问题（求哈密顿图的最短简单通路）**，**集合划分问题**，**矩阵链乘法问题**，**数独问题**等等。

#### 状压dp求具体排列

**例题**：[Doing Homework - HDU 1074 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/HDU-1074#author=GPT_zh)
题目大意：给出两个长度为 $n(n\le15)$ 的数组 $c$ 和 $d$ ，可以任意同时改变两个数组的顺序，定义整个数组的代价为
$$
\sum_{i=1}^{n}(\sum_{j=1}^{i}d[j]-c[i])
$$
求最小代价以及取到最小代价的数组排序（如果有多个，输出字典序最小的）。
题解：对于不同的选取点的状态，每次选到新的点时增加的代价值都不同，同时这道题目的 $n$ 值很小，考虑抽象点是否选取为01值得**状压dp**。其中 $dp$ 键是选点状态，值是到达当前状态的最小代价值。那么进行**双层遍历**，外层遍历状态，从0开始；内层遍历将要被考虑的点，遍历数组即可。具体过程：遍历前除了 $dp[0]$ 为 $0$ ，其他都为$INF$。遍历外层从 “$000..000$”开始，即一个都没有被选取；内层遍历每个点，先考虑是否被选取过（二进制判断改位是否为1），若未被选取，考虑在外层状态已经花费的时间和（一样通过二进制判断），再更新加点后的状态 $dp[j+(1<<(i-1))]$ 为自己与 $dp[j]$ 加上时间的最小值即可。至于输出排序，从 “$111..111$” 的情况逆序遍历，每次删除最靠后符合条件的节点（可以使该状态 $dp$ 值更新为最小的），然后记录，删除，不断循环即可。
代码详解题目链接。

#### 图上状压dp

选取**满足一定限制**的点，并求出有关于点的某个值的极值情况，在点的数目比较少的时候，可以考虑抽象**点是否选取的状态为01值**的状压dp。

例题：[D - General Weighted Max Matching (atcoder.jp)](https://atcoder.jp/contests/abc318/tasks/abc318_d)
题目大意：给出一个无向完全图，每条边有权值w，求不相邻边权值和的最大值。
题解：由于图的性质，两点之间有且只有一条边，那么可以用两个点来描述一条边的位置。如果一条边被选取了，则其两端的点则被占用。因此将顶点的状态看成状压dp的循环量。
AC代码：

~~~c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 100;
const int MAXK = 1e8 + 100;
const int MAXM = 1e8 + 10;
const int INF = 0x7fffffff;
const long long inf = 1e18;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;
#define lowbit(x) (x&(-x))

ll n,d[20][20];
ll dp[MAXN],ans=0;

int main()
{
    cin>>n;
    for(int i=1;i<n;++i){
        for(int j=i+1;j<=n;++j){
            cin>>d[i][j];
            d[j][i]=d[i][j];
        }
    }

    for(int i=1;i<n;++i){
        for(int j=i+1;j<=n;++j){
            for(int k=0;k<=(1<<n)-1;++k){
                int pnt = 0,cnt=k,u=0,v=0;
                while(cnt){ //判断某遍历中的边的两个端点是否已经被选取
                    pnt++;
                    if(pnt==i)
                        u=(cnt&1);
                    if(pnt==j)
                        v=(cnt&1);
                    cnt/=2;
                }

                if(u==1||v==1)continue;
                dp[(1<<(i-1))+(1<<(j-1))+k]=max(dp[(1<<(i-1))+(1<<(j-1))+k],dp[k]+d[i][j]);
                ans=max(ans,dp[(1<<(i-1))+(1<<(j-1))+k]);
            }
        }
    }

    cout<<ans;
    return 0;
}
~~~

关键字：记忆化搜索，状压
例题：[H-入_2024牛客暑期多校训练营5 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/81600/H)
题意：给定一个无向图，每个点有点权 $a_i$ 且互不相同。现任意构造每个点的点权，在图上做梯度下降算法（每次移动到相邻点权最小的点）求可经过的最大节点数目。$n<=40$。
题解：由于点数较小，考虑使用状压记录每个点的访问允许情况。考虑使用 $dfs$，每次经过一个点，在前往它的相邻节点时候，将所有与他相邻的点的状态均更新为 $1$ ，遍历直至无法继续继续梯度下降算法，记录访问点数取最大值即可。（注意：这里将所有点的相邻点的情况提前用二进制存储好，在更新状态的时候直接位运算即可，这个点非常的好）

~~~c++
vector<int>G[MAXN];
int n,m,ans=0;
ll vpos[MAXN];
map<pair<ll,int>,int> mp;
void init()
{
	ans=0;
}
void dfs(int s,ll pos,int cnt)
{
	ans=max(ans,cnt);
    if(mp[{pos,s}] >= cnt) return; //剪枝
	for(auto to:G[s]){
		if((pos&(1ll<<to))==0){ //可以访问
			dfs(to,pos|vpos[s],cnt+1); //将所有相邻点都记录为不可访问
		}
	}
}
void solve()
{
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		int u=read(),v=read();
		G[u].push_back(v);
		vpos[u]=(vpos[u]|(1ll<<v));
		G[v].push_back(u);
		vpos[v]=(vpos[v]|(1ll<<u));
	}
	for(int i=1;i<=n;++i){
		dfs(i,(1ll<<i),1);
	}
	cout<<ans;
	return;
}
~~~

 

### 背包模型

#### 九种背包

发现自己最简单的背包问题都经常搞不明白，确实是有点太fw了。

**背包问题**指是在物品有价值，重量；而背包有一定的重量限制，求符合条件的能拿到的最大物品价值和。

背包问题主要可以分为**01背包**和**多重背包**两种类型，前者每种物品只能拿一次，后者每种物品能拿无限次。

**01背包**

由于每种物品只能拿一次，可以根据每个物品拿或者不拿的情况进行dp。由于限制条件为物品的重量，我们可以把取到的物品数目作为第一个参数，$i$ 表示讨论范围为前 $i$ 个物品时的最大价值；背包的剩余重量作为另一个参数 $j$ ， $j$ 表示背包还可以放入重量为 $j$ 时的最大价值。那么显然从上一个物品到下一个物品的传递方程为

~~~c++
dp[i][j] = max(dp[i-1][j],dp[i-1][j-c[i]]+w[i])
~~~

那么进行二重循环，最终答案即为`dp[n][m]`;

~~~c++
for(int i=1;i<=n;++i){
    for(int j=c[i];j<=m;++j){
		dp[i][j]=max(dp[i-1][j],dp[i-1][j-c[i]]+w[i]);
    }
}
~~~

发现传递方程中，第一个限制参数 $i$ 在两种转移情况下都和 $i - 1$ 相对应，没有必要特意写出 $i$ ，可去掉以提升空间复杂度效率。

~~~c++
dp[j] = max(dp[j],dp[j-c[i]]+w[i]);
~~~

但是此时由于缺少 $i$ 的限制，第二层循环要逆向遍历，以防止一个物品的多次增加

~~~c++
for(int i=1;i<=n;++i){
    for(int j=m;j>=c[i];--j){
		dp[j]=max(dp[j],dp[j-c[i]]+w[i]);
    }
}
~~~

**完全背包**

多重背包由于可以对同一个物品进行多次选取，因而状态转移方程应为：

~~~c++
dp[i][j] = max(dp[i-1][j],dp[i][j-c[i]]+w[i]);
~~~

取第 $i$ 个物体的时候应该考虑从取了考虑过第 $i$ 个物品的情况。

代码书写情况和01背包类似：

~~~c++
for(int i=1;i<=n;++i){
    for(int j=c[i];j<=m;++j){
        dp[i][j]=max(dp[i-1][j],dp[i][j-c[i]]+w[i]);    
    }
}
~~~

那么优化方式也和01背包类似，只是变为正向遍历，在此不在书写。

接下来还有七种背包类型，均可在上述两种基础类型上稍加修改得出答案。

**多重背包**

多重背包是每个物品最多能拿 $s[i]$ 次的背包。

那么简单的方法是在直接遍历所有物品，时间复杂度为 $O(n*s)$ 。$(s[i] <= s)$

~~~c++
for(int i = 1; i <= n; ++i) {    
	for(int j = c[i]; j <= m; ++j) {
		for(int k = 1; k <= s[i] && j >= k*Vol[i]; ++k){
			dp[i][j] = max(dp[i][j], dp[i-1][j-k*c[i]]+k*w[i]);
		}
	} 
}
~~~

 优化的方式：考虑将 $s[i]$ 个物体直接放入背包，转化为01背包求解。但是这样时间复杂度仍然较高，那么考虑使用二进制优化，如 $s[i]$ 为 $5$ 时，用一般方法需要循环 $5$ 次，使用二进制将 $5$ 拆解为 $1 + 2 + 2$，则只需要 $3$ 次。此时时间复杂度优化为 $n*log(s)$ 。

~~~c++
for(int i = 1; i <= n; i++) {
	cin >> c >> w >> s;
	for(int k = 1; k <= s; k *= 2){
		s -= k;
		g.push_back({c*k,v*k});
	}
	if(s > 0) goods.push_back({volume*s, value*s});
}
~~~

**混合背包**

即上述三种背包的混合。那么完全背包和01背包拆开来求解，多重背包转化为01背包即可。

**二维背包**

多一个限制条件的背包，**多一层循环** 或者 使用**递归**。

#### 互相影响的多次遍历

在背包问题进行的时候，对于节点/物品 $i$ 往往存在**取/不取**两种情况，取或不取取决节点之间与当前状态的限制条件。而该模型则是研究在**多次遍历同一节点序列**，且**多次遍历之间会互相影响**的情况下，即节点不仅在单次遍历受其他节点与当前状态的限制，还受**其他遍历最终节点状态**的限制。

一般情况下，解决此类问题的一般方法是**在一次遍历中同时考虑所有遍历**。

例题：**汽车往返加油问题**[F - Fuel Round Trip (atcoder.jp)](https://atcoder.jp/contests/abc320/tasks/abc320_f)

大致题意：油箱容量为 $j$ 的汽车从起点 $0$ 出发，前往终点 $x$ 。起终点之间有 $n$ 个加油站，每个加油站可以选择花费 $w$ 获得 $c$ 油量。每个加油站只能使用一次，求汽车往返一次的最少花费？

题解：在一次遍历中**同时考虑**过去和回来的加油站使用情况。

~~~c++
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 2e5 + 100;
const int MAXK = 1e8 + 100;
const int MAXM = 1e8 + 10;
const int INF = 0x7fffffff;
const long long inf = 1e18;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;
#define lowbit(x) (x&(-x))

ll n,h;
ll x[MAXN],p[MAXN],f[MAXN],dp[330][330][330];

int main()
{
    cin>>n>>h;
    for(int i=1;i<=n;++i){
        cin>>x[i];
    }
    for(int i=1;i<n;++i){
        cin>>p[i]>>f[i];
    }

    for(int i=0;i<=n;++i){
        for(int j=0;j<=h;++j){
            if(i==0&&j==h)continue;
            for(int k=0;k<=h;++k){
                dp[i][j][k]=inf;
            }
        }
    }

    for(int i=1;i<=n;++i){
        for(int j=0;j+x[i]-x[i-1]<=h;++j){
            for(int k=x[i]-x[i-1];k<=h;++k){
                dp[i][j][k]=min(dp[i][j][k],dp[i-1][j+x[i]-x[i-1]][k-x[i]+x[i-1]]);
                ll t=dp[i-1][j+x[i]-x[i-1]][k-x[i]+x[i-1]];
                
                dp[i][min(j+f[i],h)][k]=min(dp[i][min(j+f[i],h)][k],t+p[i]); //j的加油更新
                
                if(k==h){
                    for(int q=0;q<=f[i];++q){
                        dp[i][j][k-q]=min(dp[i][j][k-q],t+p[i]);
                    }
                }                
                else if(k>=f[i])
                    dp[i][j][k-f[i]]=min(dp[i][j][k-f[i]],t+p[i]);  //k的加油逆转更新
            }
        }
    }

    ll ans = inf;
    for(int i=x[n]-x[n-1];i<=h;++i){
        ans=min(ans,dp[n][i][i]); //位于终点二者油量相等才合法
    }
    if(ans==inf) cout<<-1;
    else cout<<ans;
    return 0;
}
~~~





### 其他模型

#### 双变量模型

双变量模型中一般第一个变量代表**考虑前 $i$ 个状态的情况**，第二个变量是**额外的限制条件**，比如选取的总数目，选取的最后一个点等等。

#### 单调队列优化模型

如果每次dp可选择的不是下一个对象，而是一个范围内的对象，且满足 $[i+n,i+m]$ 的确定关系，那么可以使用单调队列维护。

#### 最长公共子序列：

~~~c++
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXN = 1e5 + 10;

int n;
int a[MAXN], b[MAXN];
int visa[MAXN], ba[MAXN];
int dp[MAXN], len = 0;

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		visa[a[i]] = i;
	}
	for (int i = 1; i <= n; i++) {
		cin >> b[i];
		ba[visa[b[i]]] = i;
	}
	for (int i = 1; i <= n; i++) {
		if (ba[i] > dp[len]) dp[++len] = ba[i];
		else *lower_bound(dp + 1, dp + len + 1, ba[i]) = ba[i];
	}
	cout << len;
	return 0;
}
~~~



## 树形动态规划

### 树上dp

[Problem - D - Codeforces](https://codeforces.com/contest/1988/problem/D)
**关键字**：树上染色变种。
**题意：**给出一个点有权值的树，给每一个点一个值 $w$，要求相邻点的 $w$ 不相等，求 $a_i * w$ 的最小值。
**题解：**注意到，**每一轮拿掉的点的和必然大于等于当前留在场上的点的权值和的一半** ，那就可以得出 $w$ 的范围为权值和的 $log$ 级别，那么用 $dp[i][j]$ 表示以第 $i$ 个节点为根的子树，且节点 $i$ 在第 $j$ 轮被拿掉时的最小值。代码实现上跑一边 $dfs$，每次遍历 $j$ ，时间复杂度为 $O(nlog^2)$。

~~~c++
void dfs(int s,int fa=0)
{
	for(auto to:G[s]){
		if(to==fa) continue;
		dfs(to,s);
	}
	for(int i=1;i<=30;++i){
		dp[s][i]=a[s]*i;
		for(auto to:G[s]){
			ll maxn=inf;
			for(int j=1;j<=30;++j){
				if(i==j) continue;
				maxn=min(maxn,dp[to][j]);
			}
			dp[s][i]+=maxn;
		}
	}
}
~~~



# 数据结构

## 并查集

**初始化**

~~~c++
int fa[MAX];
for (int i=1;i<=n;i++) fa[i]=i;
~~~

**find**查询。查找某个数字的最早祖先，以表示其所属集合。

~~~C++
int find(int s)
{
    if (fa[s]==s) return s;
    else return find(fa[s]);
}
~~~

**优化方式**:

特殊情况下**树**会退化成**链表**，则时间复杂度从 $O(logn)$ 级变为 $O(n)$ 级。此时让数字直接指向公共祖先，可以减少查询时的耗时。

~~~c++
int find(int s)
{
    return fa[s]==s?s:fa[s]=find(fa[s]);
}
~~~

**untie**合并：

~~~c++
void unite(int a,int b)
{
    int u=find(a),v=find(b);
    fa[u]=v;
    return;
}
~~~

优化后：**按秩合并**

将深度较小的树作为另一棵树的子树，可以使树更平衡

~~~c++
int ra[MAX];

...
    
void unite(int a,int b)
{
    int u=find(a),v=find(b);
    if (ra[u] < ra[v]) fa[u]=v;
    else if (ra[u]>ra[v]) fa[v]=u;
    else if (ra[u]==ra[v] && u!=v){
        ra[u]++; fa[v]=u;
    }
    return;
}
~~~

完整的板子

~~~c++
nt n, m, fa[MAXN], ra[MAXN];
void init() {
    for (int i = 1; i <= n; ++i) fa[i] = i;
}
int find(int s) 
{
    return (s==fa[s]? s:fa[s]=find(fa[s]));
}
void unite(int a, int b) 
{
    a = find(a), b = find(b);
    if (a == b) return;
    if (ra[a] > ra[b]) {
        fa[b] = a;
    } else {
        if (ra[a] == ra[b]) ra[b]++;
        fa[a] = b;
    }
}
bool query(int x, int y) {
    return find(x) == find(y);
}
~~~

**板子题**：
[D - Equals (atcoder.jp)](https://atcoder.jp/contests/arc097/tasks/arc097_b)   [P3367 【模板】并查集 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3367)

---

### 拓展域并查集

拓展域并查集相对于一般的并查集，最大的特点是开了**多倍**的空间，以解决某些元素之间是否可以在满足某种**传递关系**（一般是**二元**）的条件下归类到若干个集合中。
以简单的二元关系为例：定义 $<a,b>$ 表示 $a$ 和 $b$ 不能再同一个集合中的二元关系，那么所有与 $a$ 同集合的元素都不能与 $b$ 在同一个集合，而所有不能与 $a$ 在同一集合内的元素都可与 $b$ 在同一集合。那我们可以引入一个元素 $a+n$ （一般 $n$ 为元素个数），使得 $<a,a+n>$ 必然成立。加入现在有一对对立关系 $<a,b>$，则只需要将 $b$ 所在的集合与 $a+n$ 所在的集合合并即可表示 $<a,b>$。
可以得到结论：**拓展域并查集将元素放到不同的集合内，通过集合之间的关系来表示元素之间的关系。**

**例题**
1、[关押罪犯 ](https://www.luogu.com.cn/problem/P1525)
**题意**：将所有元素分为两个集合，部分元素在一个集合时会给该状态一个代价 $f(a,b)$，求最大代价的最小值。
**题解**：可以直接用上面例子的想法解出，也可以用用一个数组维护每个元素的上一个敌人。

~~~c++
bool query(int a, int b) {
    return find(a) == find(b);
}
void solve() {
    cin >> n >> m;
    init();
    for (int i = 0; i < m; ++i) cin >> th[i].a >> th[i].b >> th[i].c;
    sort(th, th + m); //从最大代价开始遍历
    for (int i = 0; i < m; ++i) {
        if (query(th[i].a, th[i].b) || query(th[i].a + n, th[i].b + n)) {
            cout << th[i].c;
            return;
        }
        merge(th[i].a, th[i].b + n);
        merge(th[i].a + n, th[i].b);
    }
    cout << 0;
}
~~~

2、[食物链](https://www.luogu.com.cn/problem/P2024)
**题意**：给出三个集合，三个集合内的元素都指向下一个集合内的元素，给出多个元素的指向关系，求里面矛盾的个数。
**题解**：这道题有两种解法，先介绍拓展域并查集的解法:

~~~c++
//a吃a+N a+n吃a+2*n a+2*n吃a+n
bool check(int opt, int u, int v)
{
	if (u > N || v > N) return false;
	if (opt == 1) {
		if (find(u + N) == find(v) || find(u + 2 * N) == find(v)) return false;
	}
	if (opt == 2) { //u吃v
		if (find(u + 2 * N) == find(v) || find(u) == find(v)) return false;
	}
	return true;
}
void solve()
{
	cin >> N >> K;
	for (int i = 1; i <= N * 3; i++) fa[i] = i;
	for (int i = 1; i <= K; i++) {
		int opt, u, v;
		cin >> opt >> u >> v;
		if (!check(opt, u, v)) ans++;
		else {
			if (opt == 1) { //假如u与v是同类 则u与v的天敌和食物也互为同类
				unite(u, v);
				unite(N + u, N + v);
				unite(2 * N + u, 2 * N + v);
			}
			else if (opt == 2) {
				unite(u, 2 * N + v);
				unite(N + u, v);
				unite(2 * N + u, N + v);
			}
		}
	}
	cout << ans;
	return 0;
}
~~~

---

### 带权并查集

**带权并查集**结局的问题与拓展域并查集一致，但是不在用集合的关系表示元素的关系，而是通过**元素和集合的关系间接得出元素之间的关系**。
同样举个对立关系的例子。现有两个对立关系 $<a,b>$ ，$<a,c>$ ，不妨假设 $a$ 为 $a$ 所在集合的祖宗/根节点，那么我们将 $b$ 和 $c$ 加入 $a$ 集合的时候，在 $b、c$ 与 $a$ 之间引入一个权值 $1$，则在询问 $b$ 与 $c$ 的关系的时候，我们查询他们到所在集合根节点的权值 $1、1$ ，两个 $1$ 相加对 $2$ 取余得到 $0$，说明 $b、c$ 不是对立关系。 
因而带权并查集的 $find$ 与 $unite$ 函数都要重写，引入一个权值数组维护**某个点到祖先的权值**，在 $find$ 的时候 $fa[s] = find(fa[s])$ 时注意权值的更新；在 $unite$ 时，则一定要**按秩合并**，更新较轻节点的祖宗节点，并同时更新权值。

**例题**

1、[食物链](https://www.luogu.com.cn/problem/P2024)
**题意**：同上
**题解**：这道题有两种解法，这里介绍带权并查集的解法:

~~~c++
//cjh的板子 好用！🤓☝️
int n, m, ans, fa[N], ra[N], va[N];//va-该点到祖先距离
void init() {
    for (int i = 1; i <= n; ++i) fa[i] = i;
}
int find(int a) {
    if (a == fa[a]) return a;
    int temp = find(fa[a]);
    va[a] = (va[a] + va[fa[a]]) % 3;
    fa[a] = temp;
    return fa[a];
}
void unite(int a, int b, int op) {
    int aa = find(a), bb = find(b);
    if (aa == bb) return;
    if (ra[aa] > ra[bb]) {
        fa[bb] = aa;
        va[bb] = (va[a] - va[b] - op + 3) % 3;
    }
    else {
        if (ra[aa] == ra[bb]) ra[bb]++;
        fa[aa] = bb;
        va[aa] = (va[b] - va[a] + op + 3) % 3;
    }
}
int query(int a, int b) {
    int aa = find(a), bb = find(b);
    if (aa != bb) return -1;
    else return (va[a] - va[b] + 3) % 3;
}
void solve() {
    cin >> n >> m;
    init();
    for (int i = 0; i < m; ++i) {
        int op, a, b;
        cin >> op >> a >> b;
        op--;
        if (a > n || b > n || op == 1 && a == b || query(a, b) != op && query(a, b) != -1) ans++;
        else unite(a, b, op);
    }
    cout << ans;
}
~~~

**2.[LCT](https://ac.nowcoder.com/acm/contest/81599/A)**
**关键词**：带权并查集
**题意**：给定一颗有根树，每次询问前 $i$ 条边组成的森林中，第 $c_i$ 个可到达的最长简单路径长度（**保证 $c_i$ 为树的根**）。
**题解**：这道题虽然名字叫LCT，但是LCT会被卡内存（？）。观察所给条件： $c_i$ 是树的根，原问题可以直接转化为求以 $c_i$ 为根的树的深度，容易想到使用带权并查集来维护每个集合/树的深度，合并时修改即可。

---

### 可持久化并查集

给定 $n$ 个集合，第 $i$ 个集合内初始状态下只有一个数，为 $i$。

有 $m$ 次操作。操作分为 $3$ 种：

 - `1 a b` 合并 $a,b$ 所在集合；
 - `2 k` 回到第 $k$ 次操作（执行三种操作中的任意一种都记为一次操作）之后的状态；
 - `3 a b` 询问 $a,b$ 是否属于同一集合，如果是则输出 $1$，否则输出 $0$。

可持久化并查集就是解决上述问题的一种特化数据结构。注意到，上述的问题核心在于 $fa[i]$，考虑是否有合适的数据结构来维护它，联想到可持久化线段树维护数组的板子，故考虑**主席树**。接下来考虑优化，并查集常见的优化方式有 路径压缩和按秩合并。由于路径压缩是均摊 $log(n)$ 的时间复杂度，单次查询的复杂度最高可为 $O(n)$，如果多次回溯到该情况下，有超时可能；故考虑**按秩合并**，时间复杂度严格为 $O(log(n))$。因而得出结论：**主席树+按秩合并**，用主席树同时维护 $fa$（父节点） 和 $rank$（秩大小） 数组。

~~~c++
//std::ios::sync_with_stdio(false);
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+10;
const int MAXM = 2e5+10;
typedef long long ll;
inline int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch>'9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - 48; ch = getchar(); }
    return x * f;
}

//用主席树维护fa数组
#define ls(x) tree[x].ls
#define rs(x) tree[x].rs
#define fa(x) tree[x].fa
#define ra(x) tree[x].ra
struct node
{ 
	int ls,rs,fa,ra;
}tree[MAXN*320];
int A[MAXN],roots[MAXN],n,m,cnt=1,cur=0;
void build(int l=1,int r=n,int p=1)
{
    if(l==r) fa(p)=l,ra(p)=1;
    else{
        ls(p)=++cnt,rs(p)=++cnt;
        int mid=(l+r)/2;
        build(l,mid,ls(p));
        build(mid+1,r,rs(p));
    }
}
void update_fa(int x,int d,int p,int q,int cl=1,int cr=n) //单点修改
{
    tree[q]=tree[p];
    if(cl==cr) fa(q)=d;
    else{
        int mid=(cl+cr)/2;
        if(x<=mid){
            ls(q)=++cnt;
            update_fa(x,d,ls(p),ls(q),cl,mid);
        }
        else{
            rs(q)=++cnt;
            update_fa(x,d,rs(p),rs(q),mid+1,cr);
        }
    }
}
void update_ra(int x,int d,int p,int q,int cl=1,int cr=n) //单点修改
{
    tree[q]=tree[p];
    if(cl==cr) ra(q)=d;
    else{
        int mid=(cl+cr)/2;
        if(x<=mid){
            ls(q)=++cnt;
            update_ra(x,d,ls(p),ls(q),cl,mid);
        }
        else{
            rs(q)=++cnt;
            update_ra(x,d,rs(p),rs(q),mid+1,cr);
        }
    }
}
int query_fa(int x,int p,int cl=1,int cr=n)
{
    if(cl>x||cr<x) return 0;
    else if(cl>=x&&cr<=x) return fa(p);
    else{
        int mid=(cl+cr)/2;
        if(x<=mid) return query_fa(x,ls(p),cl,mid);
		else return query_fa(x,rs(p),mid+1,cr);
    }
}
int query_ra(int x,int p,int cl=1,int cr=n)
{
    if(cl>x||cr<x) return 0;
    else if(cl>=x&&cr<=x) return ra(p);
    else{
        int mid=(cl+cr)/2;
        if(x<=mid) return query_ra(x,ls(p),cl,mid);
		else return query_ra(x,rs(p),mid+1,cr);
    }
}

//并查集
int find(int s) 
{
	int tfa=query_fa(s,roots[cur]);
	if(s==tfa) return s;
	else return find(tfa);	
}
void unite(int a, int b) 
{
    a = find(a), b = find(b);
    if (a == b) {
		roots[cur+1]=roots[cur];
	}
	int siz1=query_ra(a,roots[cur]),siz2=query_ra(b,roots[cur]);
    if (siz1>siz2) {
		roots[cur+1]=++cnt;
		update_fa(b,a,roots[cur],roots[cur+1]);
    } else {
		roots[cur+1]=++cnt;
        update_fa(a,b,roots[cur],roots[cur+1]);
        if (siz1 == siz2) {
			int temp=roots[cur+1];
			roots[cur+1]=++cnt;
			update_ra(b,siz2+1,temp,roots[cur+1]);
            //注意，这里的ra需要在已经更新过fa的树上建立新的树
		}
	}
}

void solve()
{
    n=read(),m=read();
    build();
    roots[0]=1;
    for(int i=1;i<=m;++i)
    {
		int op=read(),x=read();
		if(op==1){
			int y=read();
			unite(x,y);
		} else if(op==2){
			roots[cur+1]=roots[x];
		} else{
			int y=read();
			cout<<(find(x)==find(y)?"1\n":"0\n");
			roots[cur+1]=roots[cur];
		}
		cur++;
    }
}

int main()
{   
    int t=1; //cin>>t;
    while(t--)
    {
        solve();
    }
    return 0;
}
~~~

----

### 其他

链接：[Problem - 1157E - Codeforces](https://codeforces.com/problemset/problem/1157/E)
**题目大意**：给出两个长度为 $n$ 数组 $a$ $b$ ，$b$ 可随意排序，构造数组 $c = (a+b)%n$  求字典序最小的数组 $c$。
题目解法：一眼想法是对每个 $a[i]$ ,最佳的值是 $n-a[i]$，其次是比 $n-a[i]$ 大的值，再其次从最小的 $b[i]$ 开始。实现通过维护 $multiset$ ，然后二分查找。
但是还可以这么做：维护一个数组 $num$ ，存储 $b$ 中出现的数字的个数，对于每个 $a[i]$ ，查找 $num[n-a[i]]$ ，不存在则不断向后取，维护方法使用**并查集**的思想，维护一个数组 $nex$ 存储每个数字最合适的下一个数字，用 $find$ 的思想修改。 

## ST表

~~~c++
#include <iostream>
#include <stdio.h>
using namespace std;
const int MAXN=1e6+100;

inline int read()  //快读
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

int n, m, x, y;
int a[MAXN], lg[MAXN], f[MAXN][20];  //(1<<20) > 1e6+100
int main()
{
	n=read(),m=read();
	lg[1] = 0; 
    for(int i=2;i<=n;i++) lg[i]=lg[i>>1]+1;  //初始化得到log2的值
	for (int i=1;i<=n;i++) {
        cin >> f[i][0];
    }
	for (int j = 1; j <= lg[n]; j++) {
		for (int i = 1; i <= n - (1 << j) + 1; i++) {
			f[i][j] = max(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
		}
	}

	for (int i = 1; i <= m; i++) {
		x=read(),y=read();
		int l = lg[y - x + 1];
		cout << max(f[x][l], f[y - (1 << l) + 1][l]) << "\n";
	}
	return 0;
}
~~~

### 二维ST表

[Cornfields - OpenJ_Bailian 2019 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/OpenJ_Bailian-2019#author=GPT_zh)

## 树状数组

实现**单点修改**和**区间求值**时，综合考虑两种操作的时间复杂度，使用树状数组，可使两种都变为O（logn）级别。

![img](https://pic3.zhimg.com/80/v2-df001651925903a86ab640482b78c2d6_720w.webp)

如图，**树状数组**的基本原理在于建立一个数组来管理原先数组，该数组通过**二进制**的相关原理来达到查询与修改时候的跳跃式操作以减少时间复杂度。

假设存在大小为 $10$ 的数组 $1 ,2 ,3 ,4 ,5 ,6 ,7 ,8 ,9 ,10$。如果需要对该数组进行**修改值**以及**区间求和**的操作，可以考虑创建数组 $tree[11]$ 来维护某几个特定区间的值。在**树状数组**中，与前缀和不同的是，tree[i] 维护的是 $[i-lowbit(i),i]$ 的和值，其中 **lowbit(i) = (i &(-i))** 代表数字 i 在二进制的表示形式下第一次出现的 $1$ 所代表的大小 。因而，如果将数组tree中的每一个位置按照其维护的区间大小依次上下排列，就会形成如上图所示的**树形结构**，因而被称为树状数组。

树状数组在维护区间和的复杂度中的**单点修改**与**区间求和**两个操作，均可以达到 $O(logn)$ 级别。

**单点修改**操作：假设对 a[x] 增加 val 大小的值，那么找到 x 所在位置，对tree[x] 进行一个val的增加，后因为覆盖区间之间的倍数关系（即覆盖低级区间的次高级区间的维护范围必然是前者维护范围的两倍），对 x 进行一个lowbit(x)的增加，并进行维护。不断进行直至x超出数组范围。因为每次向下一个区间跳跃的时候，跳跃的大小会不断倍增，因而时间复杂度是 $O(logn)$ 

**区间求和**操作：假设要求查询 $[l,r]$ 范围内的和值，依次求出位置 r 与 l - 1 的前缀和然后相减即可。对于前缀和的求法与单点修改类似，以 r 为例，先获取 tree[r] 的值。然后再将 r 减去 lowbit（r）得到下一个维护区间的维护元素的位置，然后再次获取。不断进行直至 r 超出数组范围。时间复杂度依然是 $O(logn)$ 。



**① 单点修改，区间求值** 

~~~c++
#include <iostream>
using namespace std;
#define lowbit(x) x&(-x)

int n, m;
int a[500500], c[500500];

void add(int s,int val)  //更新树状数组
{
	for (int i = s; i <= n; i += lowbit(i)) c[i] += val;   //跳跃着前进
	return;
}

int ask(int s)    //求前s项和
{
	int ans = 0;
	for (int i = s; i >= 1; i -= lowbit(i)) ans += c[i];   //跳跃着后退求和
	return ans;
}

int main()
{
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		add(i, a[i]);
	}
	for (int i = 1; i <= m; i++) {
		int opt, x, y;
		cin >> opt >> x >> y;
		if (opt == 1) add(x, y);	
		else if (opt == 2) cout << ask(y) - ask(x - 1) << "\n";
	}
	return 0;
}
~~~



**② 单点求值，区间修改** 

该方法用**树状数组**来管理**差分数组**即可实现。

~~~c++
#include <iostream>
using namespace std;
const int MAXN = 500500;
#define lowbit(x) (x&(-x))

int n, m;
int tree[MAXN], a[MAXN];  //tree存的是差分数组的树状数组
void add(int s, int val)
{
	for (int i = s; i <= n; i += lowbit(i))
		tree[i] += val;
	return;
}
int ask(int s)
{
	int ans = 0;
	for (int i = s; i >= 1; i -= lowbit(i))
		ans += tree[i];
	return ans;
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= m; i++) {
		int opt, x, y, k;
		cin >> opt >> x;
		if (opt == 1) {
			cin >> y >> k;
			add(x, k); add(y + 1, -k);
		}
		else {
			cout << a[x] + ask(x) << "\n";
		}
	}
	return 0;
}
~~~

### 逆序对

树状数组还常见应用于求**逆序对**的题目中。转化为求**非严格正序对**，再变换得到逆序对数目。其中，树状数组维护的是每一个值的个数。

例如，我们要求5 4 1 3 2的逆序对。用ans记录非严格顺序对的数量。

![img](https://pic2.zhimg.com/80/v2-ec0a0dd0968f9e599d1e312e2dee2695_720w.webp)

我们按顺序去填充树状数组，第一个数字是5，这时没有数比5小，所以ans保持为0。我们把tree[5]填为1。

![img](https://pic2.zhimg.com/80/v2-b67518fb5b4944aa3832c8f98c951541_720w.webp)

下一个数字是1，这时也没有数比1小，ans仍为0。我们把tree[1]填为1。

![img](https://pic3.zhimg.com/80/v2-89037dfcae45ef605aca756eea070bae_720w.webp)

下一个数字是3，这时query(3)为1，有一个数比3小了，ans变为1。然后再填tree[3]。

![img](https://pic2.zhimg.com/80/v2-b2377fea1a6820a6c59e10ef74978bbd_720w.webp)

下一个数字是2，这时query(2)为1，说明前面有一个数比2小，ans再加1变为2。然后填tree[2]。

![img](https://pic3.zhimg.com/80/v2-0bac0074d0f14aef0711080fb12d7132_720w.webp)

最后一个数字是4，query(4)为3，说明前面有3个数比4小，ans加3变为5。所以非严格顺序对的总数就是5。那么逆序对共有 C52−5=5 个。

![img](https://pic1.zhimg.com/80/v2-d66c4d6d8a07772e05484047a7c1455c_720w.webp)



[小鱼比可爱](https://www.luogu.com.cn/problem/P1428)这道题可以暴力做，也可以使用树状数组。
其实**逆序对**问题的原理，是**二维偏序**的应用，二位偏序的内容在这里不详解。

### 求多元组

**例题**

**([CF61E ](https://codeforces.com/problemset/problem/61/E))** **Enemy is weak**
**关键词**：求三元组数目
**题目大意**：求数组中 $i<j<k$ 但 $a_i>a_j>a_k$ 的数目。
**题解**：先通过求**逆序对**的方法维护一个树状数组，在求逆序对的同时，再用一个树状数组维护每个元素 $j$ 符合 $i<j且a_i>a_j$ ，也就是逆序对的数目（将求逆序对中加的1转换为加逆序对数目）。这样讲有点抽象，上代码！

~~~c++
    //num用来求逆序对 v用来三元逆序对
	for(int i=1;i<=n;++i)
    {
        ll temp=ask(n,num)-ask(b[i],num);  
        ans += ask(n,v) - ask(b[i],v); 

        add(b[i],temp,v);
        add(b[i],1,num);  
    }
	//简单来说 这里的num数组求逆序对的方法是将 a[i]放到树状数组的指定位置 update(a[i],1)
	//同时每一个元素放入有多少个比他大的值已经放入 也就是ask(a[n])-ask(a[i])有多少个值
	//这里用一样的思想求三维逆序对 将a[i]已经有的逆序对的数目放入指定位置 update(a[i],num);
	//同时判断此时有几个逆序对组已经放入 将他们都加进来 也就是ask(a[n])-aks(a[i])
~~~



**([CF597C ](https://codeforces.com/problemset/problem/597/C))** **Subsequences**
**关键词**：求多元数组
**题目大意**：求长度为 $k(1<=k<=10)$ 的递增子数组的数目

~~~c++
    //这里的思路与上面基本一致
	for(int i=1;i<=n;++i)
    {
        temp=1;
        for(int j=0;j<k;++j)
        {
            add(b[i],temp,j);
            temp=ask(b[i]-1,j);
            if(j==k-1)
            {
                ans+=temp;
            }
        }
    }
~~~



### 偏序问题



### +离线

**例题**

[P1972 [SDOI2009\] HH的项链 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1972)
**关键词**：离散化+树状数组（经典板子题）。
**题目大意**：给出一串长度为 $n$ 的数组，给出 $m$ 个询问 ：$[l,r]$ 范围内有几个不同的数字。
**题解**：对于若干个询问的区间 $[l,r]$ ，如果**他们的 $r$ 都相等**的话，那么项链中出现的同一个数字，一定是**只关心出现在最右边的那一个的**。因而可以将存储所有询问，按照 $r$ 排列询问，然后遍历维护珍珠类型的数组，每向下遍历一个 $i$ ，回答所有 $r = i$ 的询问。而快速回答询问可以用**树状数组**维护，每遍历到一个新的 $i$ ，$add(i,1)$，同时将在它之前的 $last[i]$ 进行 $add(last[i],-1)$，然后使用 $ask(r) - ask(l)$ 就可以快速得到区间内不同的类型。
**代码**：

~~~c+++
...
int n,c[MAXN];
void add(int s,int val)  //更新树状数组
{
	for (int i = s; i <= n; i += lowbit(i)) c[i] += val;   //跳跃着前进
	return;
}
int ask(int s)    //求前s项和
{
	int ans = 0;
	for (int i = s; i >= 1; i -= lowbit(i)) ans += c[i];   //跳跃着后退求和
	return ans;
}

struct node
{
    int l, r,ans,id;
}q[MAXN];
int m,last[MAXN],a[MAXN],ans[MAXN];
bool cmp(node x,node y)
{
    return x.r<y.r;
}

void solve()
{
    n=read();
    for(int i=1;i<=n;++i)
    {
        a[i]=read();
    }
    m=read();
    for(int i=1;i<=m;++i)
    {
        q[i].l=read(),q[i].r=read();
        q[i].id=i;
    }
    sort(q+1,q+m+1,cmp);

    for(int i=1, j=1;i<=n;++i)
    {
        if(last[a[i]]!=0)
        {
            add(last[a[i]],-1);
        }
        add(i,1);
        last[a[i]]=i;
        
        //debug(i<<" "<<ask(i));
        while(q[j].r<=i&&j<=m)
        {
            q[j].ans=ask(q[j].r)-ask(q[j].l-1);
            j++;
        }
    }

    for(int i=1;i<=m;++i)
    {
        ans[q[i].id]=q[i].ans;
    }
    for(int i=1;i<=m;++i)
    {
        cout<<ans[i]<<'\n';
    }
    return;
}
...
~~~



[F - Range Set Query (atcoder.jp)](https://atcoder.jp/contests/abc174/tasks/abc174_f?lang=en)
遇上面那道题基本一样。

### +离散化

树状数组有时候要维护数组的**值**，如果值范围很大可能无法存储进数组。此时如果值很分散，可以**离散化**，将值缩到较小的范围内，使得树状数组可以维护他们。

**例题**

[Problem - 540E - Codeforces](https://codeforces.com/problemset/problem/540/E)
**题目大意：** 有一个无限序列，所有正整数按递增顺序排列： p = {1, 2, 3, ...} 。我们对此序列执行了 n 个 交换 操作。 swap(a, b) 是交换序列中位置 a 和 b 上的元素的操作。您的任务是找出结果序列中的反转次数，即 i < j 和 pi > pj 这样的索引对 (i, j) 的数量。
**题解：** 假如数组的大小范围很小，可以直接使用**树状数组求逆序对**得到结果，但是数组最大值可达 $1e9$，但交换的数对数目只有 $1e5$，考虑使用**离散化**：需要 $swap$ 的数字单独作一组，计算逆序对时的贡献为1；夹在两个需要$swap$ 之间的数字集合作为一组，贡献即数字个数。这样可以保证树状数组需要维护的值最大不超过 $4e5$。
**代码**：

~~~C++
...

ll n,c[MAXN];
void add(ll s,ll val)  //更新树状数组
{
	for (int i = s; i <= n; i += lowbit(i)) c[i] += val;   //跳跃着前进
	return;
}
ll ask(ll s)    //求前s项和
{
	ll ans = 0;
	for (int i = s; i >= 1; i -= lowbit(i)) ans += c[i];   //跳跃着后退求和
	return ans;
}

struct node
{
    ll id, v;
}a[MAXN],d[MAXN];
ll m,b[MAXN];

bool cmp(node x,node y)
{
    return x.v<y.v;
}

void solve()
{
    cin>>n;
    for(int i=1;i<=n;++i)
    {
        cin>>a[i*2-1].v>>a[i*2].v;
        a[i*2-1].id=a[i*2].id=i;
        m=max(m,max(a[i*2-1].v,a[i*2].v));
    }
    sort(a+1,a+2*n+1,cmp);

    int cnt=0;
    for(int i=1;i<=2*n;++i) //进行离散化
    {
        if(a[i].v>a[i-1].v)
        {
            ++cnt;
            if(a[i].v-1>a[i-1].v)
            {
                d[cnt++].v = a[i].v-a[i-1].v-1;
            }
        }
        if(b[a[i].id*2-1]!=0)
        {
            b[a[i].id*2]=cnt;
        }
        else
        {
            b[a[i].id*2-1]=cnt;
        }
        d[cnt].v=1;
    }
    for(int i=1;i<=cnt;++i)
    {
        d[i].id=i;
    }
    for(int i=1;i<=n;++i)
    {
        swap(d[b[i*2-1]],d[b[i*2]]);
    }

    ll sum=0; n=cnt;
	for (int i = 1; i <= cnt; i++) { //求逆序对数目
		add(d[i].id, d[i].v);
        sum+=ask(d[i].id-1)*d[i].v;
        sum+=d[i].v*(d[i].v-1)/2;
	}
    sum=m*(m-1)/2-sum;
    cout<<sum;

    return;
}

int main()
{
    int t=1;

    while(t--)
    {
        solve();
    }
}
~~~



###  二维树状数组

这完全就是我的知识盲区，有时间可以补一补（虽然现在估计都没有时间就是了）。

**例题**

[Matrix - OpenJ_Bailian 2155 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/OpenJ_Bailian-2155)

### 思维题

一般树状数组，总重要的问题是找到充当 **树状数组的键** 和 **树状数组的值** 的两个值，然后通过树状数组的性质来解决问题。

**例题**：

[P5094 [USACO04OPEN\] MooFest G 加强版 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5094)
**关键词：**树状数组+思维
**题目大意**：给定两个长度为 $n$ 的序列 $v,x$ ，定义一个点对 $(i,j)(i \neq j) $ 的价值 $f(i,j) = max(v1,v2)*|x1-x2|$,求：
$$
\sum_{i=1}^{n}\sum_{j=1}^{n}f(i,j)[i\neq j]
$$
**题解：**考虑使用树状数组（为什么用树状数组？因为是树状数组专题里的）。由于点对的价值与 $max(v1,v2)$ 有关，而 $max$ 不好维护，我们考虑让序列**根据 $v$ 的大小进行排序**，这样就只需要考虑**靠后**的 $v$ ,这与树状数组**求逆序对的思想**类似。因此，遍历排序好后的树状数组，使用树状数组同时维护 **数目** 和 $x$ 即可：

~~~c++
        ans+=cow[i].v*(cow[i].x*ask(cow[i].x,num)-ask(cow[i].x,d)); 
        ans+=cow[i].v*((ask(m,d)-ask(cow[i].x,d))-(ask(m,num)-ask(cow[i].x,num))*cow[i].x);
        add(cow[i].x,1,num); //维护数目
        add(cow[i].x,cow[i].x,d); //维护x
~~~

---

[Problem - 652D - Codeforces](https://codeforces.com/problemset/problem/652/D)
**关键词：**树状数组+思维
**题解**：按照左端位置排序，求正序对数目。



## 线段树

### 线段树

<a id="Segment Tree">**线段树**</a>（Segment Tree）几乎是算法竞赛最常用的数据结构了，它主要用于维护**区间信息**（要求满足结合律）。与树状数组相比，它可以实现 O(log⁡ n) 的**区间修改**，还可以同时支持**多种操作**（加、乘），更具通用性。

**线段树的建立：**

线段树是一棵**平衡二叉树**。母结点代表整个区间的和，越往下区间越小。注意，线段树的每个**节点**都对应一条**线段（区间）**，但并不保证所有的线段（区间）都是线段树的节点，这两者应当区分开。

下图为线段树建立的过程

![动图](https://pic4.zhimg.com/v2-c2d11b12c87b6a7076e3df0bb3585423_b.webp)

对应的代码实现：

~~~c++
void build(ll l = 1, ll r = n, ll p = 1)
{
    if (l == r) // 到达叶子节点
        tree[p] = A[l]; // 用数组中的数据赋值
    else
    {
        ll mid = (l + r) / 2;
        build(l, mid, p * 2); // 先建立左右子节点
        build(mid + 1, r, p * 2 + 1);
        tree[p] = tree[p * 2] + tree[p * 2 + 1]; // 该节点的值等于左右子节点之和
    }
}
~~~

**区间修改**

类似于分块的思想，这里引入**懒标记**以取代朴素的递归，以增加时间效率。

*令l,r为所选修改的区间，cl，cr为递归的当前区间*

- 当r<cl或者l>cr的时候，舍去（剪枝）：

  ![img](https://pic1.zhimg.com/80/v2-794f7124f288eeae7661200d948f43a4_720w.webp)

- 当cl>=l并且cr<=r的时候，说明当前区间被所选区间包含，可直接更新该区间。

  ![img](https://pic3.zhimg.com/80/v2-abebb05b5e4c44821e7325c6e6b623fe_720w.webp)

- 其他情况，说明所选区间不完全包含当前区间。那么对当前区间分别处理，而在处理前需要将懒标记下移

  ![img](https://pic3.zhimg.com/80/v2-10c7ce5904b8300109f51e290ff2c14a_720w.webp)

~~~c++
void update(ll l, ll r, ll d, ll p = 1, ll cl = 1, ll cr = n)
{
    if (cl > r || cr < l) // 区间无交集
        return; // 剪枝
    else if (cl >= l && cr <= r) // 当前节点对应的区间包含在目标区间中
    {
        tree[p] += (cr - cl + 1) * d; // 更新当前区间的值
        if (cr > cl) // 如果不是叶子节点
            mark[p] += d; // 给当前区间打上标记
    }
    else // 与目标区间有交集，但不包含于其中
    {
        ll mid = (cl + cr) / 2;
        mark[p * 2] += mark[p]; // 标记向下传递
        mark[p * 2 + 1] += mark[p];
        tree[p * 2] += mark[p] * (mid - cl + 1); // 往下更新一层
        tree[p * 2 + 1] += mark[p] * (cr - mid);
        mark[p] = 0; // 清除标记
        update(l, r, d, p * 2, cl, mid); // 递归地往下寻找
        update(l, r, d, p * 2 + 1, mid + 1, cr);
        tree[p] = tree[p * 2] + tree[p * 2 + 1]; // 根据子节点更新当前节点的值
    }
}
~~~

可以将懒标记向下传递的过程用函数单独表示。

~~~c++
inline void push_down(ll p, ll len)
{
    mark[p * 2] += mark[p];
    mark[p * 2 + 1] += mark[p];
    tree[p * 2] += mark[p] * (len - len / 2);
    tree[p * 2 + 1] += mark[p] * (len / 2); // 右边的区间可能要短一点
    mark[p] = 0;
}
~~~

**区间求和**

区间求和的方法与区间更新类似。

~~~c++
ll query(ll l, ll r, ll p = 1, ll cl = 1, ll cr = n)
{
    if (cl > r || cr < l)
        return 0;
    else if (cl >= l && cr <= r)
        return tree[p];
    else
    {
        ll mid = (cl + cr) / 2;
        push_down(p, cr - cl + 1);
        return query(l, r, p * 2, cl, mid) + query(l, r, p * 2 + 1, mid + 1, cr); 
        // 上一行拆成三行写就和区间修改格式一致了
    }
}
~~~

完整的代码实现

~~~c++
#include <iostream>
using namespace std;
typedef long long ll;
const int MAXN = 100010;

ll n, m;
ll a[MAXN];
ll tree[MAXN * 4], lazy[MAXN * 4];

void build(ll p = 1, ll l = 1, ll r = n)
{
	if (l == r) tree[p] = a[l];
	else {
		ll mid = (l + r) / 2;
		build(p * 2, l, mid);
		build(p * 2 + 1, mid + 1, r);
		tree[p] = tree[p * 2] + tree[p * 2 + 1];
	}
	return;
}

inline void push_down(ll p, ll len)
{
	lazy[p * 2] += lazy[p];
	lazy[p * 2 + 1] += lazy[p];
	tree[p * 2] += (len - len / 2) * lazy[p];
	tree[p * 2 + 1] += lazy[p] * (len / 2);
	lazy[p] = 0;
	return;
}

void update(ll cl, ll cr, ll d, ll p = 1, ll l = 1, ll r = n)
{
	if (l > cr || r < cl) return;
	else if (l >= cl && r <= cr) {
		tree[p] += d * (r - l + 1);
		if (l < r) lazy[p] += d;
	}
	else {
		ll mid = (l + r) / 2;
		push_down(p, r - l + 1);
		update(cl, cr, d, p * 2, l, mid);
		update(cl, cr, d, p * 2 + 1, mid + 1, r);
		tree[p] = tree[p * 2] + tree[p * 2 + 1];
	}
	return;
}

ll ask(ll cl, ll cr, ll p = 1, ll l = 1, ll r = n)
{
	if (l > cr || r < cl) return 0;
	else if (l >= cl && r <= cr) return tree[p];
	else {
		ll mid = (l + r) / 2;
		push_down(p, r - l + 1);
		return ask(cl, cr, p * 2, l, mid) + ask(cl, cr, p * 2 + 1, mid + 1, r);
	}
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++) cin >> a[i];
	build();
	while (m--) {
		ll o, x, y, k;
		cin >> o >> x >> y;
		if (o == 1) {
			cin >> k;
			update(x, y, k);
		}
		else if (o == 2)
			cout << ask(x, y) << "\n";
	}
	return 0;
}
~~~

**线段树**除了可应用于区间修改与区间求值，还可用于求区间最值，gcd等等的题目，区间修改的方式也多种多样，熟练掌握后即可举一反三。

#### 乘法

~~~c++
#include <iostream>
#define ll long long 
using namespace std;
int n, m, a[1000005], mod;

struct node {
	ll sum, l, r, mu, add;
}t[1000005];

ll read() {
	ll x = 0; char ch = getchar();
	while (ch < '0' || ch>'9')ch = getchar();
	while (ch >= '0' && ch <= '9')x = (x << 1) + (x << 3) + (ch ^ 48), ch = getchar();
	return x;
}

void build(ll p, ll l, ll r) {
	t[p].l = l, t[p].r = r; t[p].mu = 1;
	if (l == r) { 
		t[p].sum = a[l] % mod;
		return; 
	}
	ll mid = (l + r) >> 1;
	build(p * 2, l, mid);
	build(p * 2 + 1, mid + 1, r);
	t[p].sum = (t[p * 2].sum + t[p * 2 + 1].sum) % mod;
}

void spread(ll p) {
	t[p * 2].sum = (ll)(t[p].mu * t[p * 2].sum + ((t[p * 2].r - t[p * 2].l + 1) * t[p].add) % mod) % mod;
	t[p * 2 + 1].sum = (ll)(t[p].mu * t[p * 2 + 1].sum + (t[p].add * (t[p * 2 + 1].r - t[p * 2 + 1].l + 1)) % mod) % mod;//add已经乘过mu啦

	t[p * 2].mu = (ll)(t[p * 2].mu * t[p].mu) % mod;
	t[p * 2 + 1].mu = (ll)(t[p * 2 + 1].mu * t[p].mu) % mod;

	t[p * 2].add = (ll)(t[p * 2].add * t[p].mu + t[p].add) % mod;
	t[p * 2 + 1].add = (ll)(t[p * 2 + 1].add * t[p].mu + t[p].add) % mod;

	t[p].mu = 1, t[p].add = 0;
}

void add(ll p, ll l, ll r, ll k) {
	if (t[p].l >= l && t[p].r <= r) {
		t[p].add = (t[p].add + k) % mod;
		t[p].sum = (ll)(t[p].sum + k * (t[p].r - t[p].l + 1)) % mod;
		return;
	}
	spread(p);
	t[p].sum = (t[p * 2].sum + t[p * 2 + 1].sum) % mod;
	ll mid = (t[p].l + t[p].r) >> 1;
	if (l <= mid)add(p * 2, l, r, k);
	if (mid < r)add(p * 2 + 1, l, r, k);
	t[p].sum = (t[p * 2].sum + t[p * 2 + 1].sum) % mod;

}

void mu(ll p, ll l, ll r, ll k) {
	if (t[p].l >= l && t[p].r <= r) {
		t[p].add = (t[p].add * k) % mod;
		t[p].mu = (t[p].mu * k) % mod;
		t[p].sum = (t[p].sum * k) % mod;
		return;
	}
	spread(p);
	t[p].sum = t[p * 2].sum + t[p * 2 + 1].sum;
	ll mid = (t[p].l + t[p].r) >> 1;
	if (l <= mid)mu(p * 2, l, r, k);
	if (mid < r)mu(p * 2 + 1, l, r, k);
	t[p].sum = (t[p * 2].sum + t[p * 2 + 1].sum) % mod;
}

ll ask(ll p, ll l, ll r) {
	if (t[p].l >= l && t[p].r <= r) {
		return t[p].sum;
	}
	spread(p);
	ll val = 0;
	ll mid = (t[p].l + t[p].r) >> 1;
	if (l <= mid)val = (val + ask(p * 2, l, r)) % mod;
	if (mid < r)val = (val + ask(p * 2 + 1, l, r)) % mod;
	return val;
}

int main() {
	cin >> n >> m >> mod;
	for (int i = 1; i <= n; i++) {
		a[i] = read();
	}
	build(1, 1, n);
	for (int i = 1; i <= m; i++) {
		int ty = read();
		if (ty == 1) {
			ll cn = read(), cm = read(), cw = read();
			mu(1, cn, cm, cw);
		}
		else if (ty == 2) {
			ll cn = read(), cm = read(), cw = read();
			add(1, cn, cm, cw);
		}
		else {
			ll cn = read(), cm = read();
			cout << ask(1, cn, cm) << endl;
		}
	}
}
~~~

---

### 可持久化线段树

下面给出洛谷上例题（[P3919 【模板】可持久化线段树 1（可持久化数组） - 洛谷 ](https://www.luogu.com.cn/problem/P3919)）的板子：

~~~c++
//std::ios::sync_with_stdio(false);
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e6+10;
const int MAXM = 1e6+10;
const int mode = 2023;
const int INF = 0x7fffffff;
const long long inf = 1e18;
typedef long long ll;
const int dx[] = { -1,0,1,0 }, dy[] = { 0,1,0,-1 };
#define lowbit(x) x&(-x)
#define debug(x) cout<<"?"<<x<<"?\n";
inline int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch>'9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - 48; ch = getchar(); }
    return x * f;
}

#define ls(x) tree[x].ls
#define rs(x) tree[x].rs
#define val(x) tree[x].val
#define mark(x) tree[x].mark
struct node
{
    ll val; int ls,rs;
}tree[MAXN*32];
int A[MAXN],roots[MAXN],n,m,cnt=1;
void build(int l=1,int r=n,int p=1)
{
    if(l==r) val(p)=A[l];
    else{
        ls(p)=++cnt,rs(p)=++cnt;
        int mid=(l+r)/2;
        build(l,mid,ls(p));
        build(mid+1,r,rs(p));
        val(p)=val(ls(p))+val(rs(p));
    }
}
//令x变成d, p表示原来版本的节点，q表示新版本的节点
void update(int x,int d,int p,int q,int cl=1,int cr=n) //单点修改
{
    if(cl==cr) val(q)=d;
    else{
        ls(q)=ls(p),rs(q)=rs(p);
        int mid=(cl+cr)/2;
        if(x<=mid){
            ls(q)=++cnt;
            update(x,d,ls(p),ls(q),cl,mid);
        }
        else{
            rs(q)=++cnt;
            update(x,d,rs(p),rs(q),mid+1,cr);
        }
        val(q)=val(ls(q))+val(rs(q));
    }
}
int query(int l,int r,int p,int cl=1,int cr=n)
{
    if(cl>r||cr<l) return 0;
    else if(cl>=l&&cr<=r) return val(p);
    else{
        int mid=(cl+cr)/2;
        return query(l,r,ls(p),cl,mid)+query(l,r,rs(p),mid+1,cr);
    }
}

void solve()
{
    n=read(),m=read();
    for(int i=1;i<=n;++i)
    {
        A[i]=read();
    }
    build();
    roots[0]=1;
    for(int i=1;i<=m;++i)
    {
        int v=read(),o=read();
        if(o==1){
            int x=read(),d=read();
            roots[i]=++cnt;
            update(x,d,roots[v],roots[i]);
        }
        else{
            int x=read();
            roots[i]=roots[v];
            printf("%d\n",query(x,x,roots[v]));
        }
    }
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    int t=1;
    //cin>>t;
    while(t--)
    {
        solve();
    }
    
    return 0;
}
~~~

## 单调栈

调栈则主要用于 O(n) 解决**NGE问题**（Next Greater Element），也就是，对序列中每个元素，找到下一个比它大的元素。（当然，“下一个”可以换成“上一个”，“比它大”也可以换成“比他小”，原理不变）。
我们维护一个栈，其中存的内容是“**待确定NGE的元素**”，然后遍历序列。每碰上一个新元素，我们知道，栈中元素越靠近栈顶的元素距离新元素越近。所以不断比较栈顶元素与新元素，如果新元素比栈顶元素大，则说明新元素是栈顶元素的NGE，然后弹出栈顶元素不断比较。直到遇到元素比新元素大或者栈为空，则将新元素加入栈中，继续遍历。

**代码实现**

~~~c++
#include <iostream>
#include <stack>
using namespace std;
const int MAXN = 3000300;

int n;
stack <int> sta;
int f[MAXN], ans[MAXN];

int main()
{
    ios::sync_with_stdio(false); 
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> f[i];
	for (int i = 1; i <= n; i++) {
		while (!sta.empty() && f[sta.top()] < f[i]) {   //如果栈顶元素比新元素小
			ans[sta.top()] = i;  //栈顶元素的NGE为新元素
			sta.pop();
		}
		sta.push(i);
	}
	for (int i = 1; i <= n; i++) cout << ans[i] << " ";
	return 0;
}
~~~

**相关例题**

[P5788 【模板】单调栈 - 洛谷 ](https://www.luogu.com.cn/problem/P5788)
[P1823 Patrik 音乐会的等待 - 洛谷 ](https://www.luogu.com.cn/problem/P1823)

### 离线解决 RMQ 问题

​	

## 单调队列

**单调队列**主要用于解决**滑动窗口**类的问题。例如，一串长为n的序列，求其中每个长度为m的区间的最值。时间复杂度为O（n），小于ST表和[线段树](#Segment Tree)的O（nlogn）。
单调队列的基本思想是，维护一个**双向队列**（deque），遍历序列，当一个元素的值可能成为区间最值的时候，才将它存储进队列中。
|可以用**残酷的算法竞赛**来类比。如果一个人比你年轻还比你强，那么你就提前毕业了。

~~~c++
#include <iostream>
#include <queue>
using namespace std;

int n, m, a[MAXN];
deque <int> deq;

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i <= n; i++) {
        if (!deq.empty() && deq.front() < i - m)  //正常毕业
            deq.pop_front();
        while (!deq.empty() && a[deq.back()] < a[i])  //被迫毕业
            deq.pop_back();
        deq.push_back(i); //新生入学
    }
}
~~~



# 图

## 储存方式

### **邻接矩阵**

因为题目给出的图一般是比较**稀疏**的，故用邻接矩阵的方式存图效率较低。

### **邻接表**

用**vector**进行存图操作。

缺点：常数较大。**寻找反向边**与**删边**操作较为困难。

### **链式前向星**

链式前向星是一种特殊的**边集数组**，我们把边集数组中的每一条边按照起点从小到大排序,如果起点相同就按照终点从小到大排序。

**建立**

~~~c++
struct edge{
    int to,w,next;
}edges[MAXM];
int head[MAXN],cnt;
inline void add(int from,int to,int w)
{
    edges[++cnt].w=w;
    edges[cnt].to=to;
    edges[cnt].next=head[from];
    head[from]=cnt;
}
~~~

邻接表是往后面存图，链式前向星则是往**前面**增加存图。

**遍历**

~~~c++
for (int i=head[p];i;i=edges[i].next){
    cout<<edges[i].to;
}
~~~







## 最短路

![img](https://img-blog.csdnimg.cn/img_convert/45c0b5f04c254019fa1d5dff2647d8c6.png)

当然，多源最短路时间复杂度最小的必然不是 $floyed$ 算法，还有做 $n$ 次 $O(nmlogn)$ 的 $Dijkstra$ 与适用负权的$Johnson$ 算法。

### 单源最短路

#### Dijkstra

（有向图版本）

~~~c++
typedef pair<int, int> P;

struct edge {
	int to, cost;
};
int n, m, s;
int d[100010];
vector <edge> G[100010];
priority_queue <P, vector<P>, greater<P>> que;

int main()
{
	cin >> n >> m >> s;
	for (int i = 1; i <= m; i++) {
		edge e; int a;
		cin >> a >> e.to >> e.cost;
		G[a].push_back(e);
	}
	fill(d + 1, d + 1 + n, 2147483647);
	que.push(P(0, s));
	d[s] = 0;
	while (!que.empty()) {
		P p = que.top(); que.pop();
		int v = p.second;
		if (d[v] < p.first) continue;
		for (int i = 0; i < G[v].size() ;i++) {
			edge e = G[v][i];
			if (d[e.to] > d[v] + e.cost) {
				d[e.to] = d[v] + e.cost;
				que.push(P(d[e.to], e.to));
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		cout << d[i] << " ";
	}
	return 0;
}
~~~

#### Bellman-Ford

Bellman-Ford 算法采用**动态规划**（毕竟是dp之父发明的算法）进行设计，实现的**时间复杂度**为 O(V*E)，其中 V 为顶点数量，E 为边的数量。

#### Heap优化：SPFA

该算法可以用来判断图中是否有**正权环**。

~~~c++
bool inque[MAXN];
int dist[MAXN],cnt[MAXN];
bool SPFA(int s)
{
    memset(dist,127,sizeof(dist));
    queue<int>que;
    que.push(s);
    dist[s]=0;
    while(!que.empty())
    {
        int q=que.front();
        que.pop();
        if(cnt[q]>n){
            return false;
        }
        inque[q]=false;
        for(auto e:G[q]){
            int to=e.to;
            if(dist[to]>dist[q]+e.w){
                dist[to]=dist[q]+e.w;
                if(!inque[to]){
                    que.push(to);
                    inque[to]=true;
                    cnt[to]++;
                }
            }
        }
    }
    return true;
}
~~~

[Currency Exchange - OpenJ_Bailian 1860 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/OpenJ_Bailian-1860)

### 多源最短路

#### Floyed

~~~c++
for(int k=1;k<=n;++j){
    for(int i=1;i<=n;++i){
        for(int j=1;j<=n;++j){
            d[i][j]=min(d[i][k]+d[k][i],d[i][j]);
        }
    }
}
~~~

#### Johnson

该算法为在每个点为原点跑 迪杰斯特拉/贝尔曼佛德，时间复杂度为 $O(n^2logn)$。

### 多层图的最短路

注意如果边的权值可以选择性的发生改变，考虑使用多层图。

## 一些模型

### 状压+最短路

状压+最短路，是将状态作为节点，状态之间的转移作为边，转移的代价作为权值，来计算某个状态到另一个状态的最小代价。与 **状压dp** 和 **状压dfs** 的思想有一定的相似性。

[软件补丁问题](https://www.luogu.com.cn/problem/P2761)
**关键字**：状压，最短路
**题意**：现有 $n$ 个错误，$m$ 个补丁。每个补丁只有在包含错误集合 $B1$，不包含错误集合 $B2$ 中任意元素的时候可以使用；使用效果为在 $t$ 时间内消除集合 $F1$ 的错误，并引入集合 $F2$ 的错误。求消除所有错误的最短时间，无解则输出 $0$。
**题解**：先观察题目中的 $n$ 和 $m$ 都较小，考虑使用状压。对于每个补丁，错误集合 $B1$ 用二进制表示（$0$ 表示该错误不属于集合，$1$ 则表示属于），再转化为十进制数 $b1$，若当前状态 $(f$ & $b1) $ ^ $b1==0$ ,则说明该状态包含错误集合 $B1$ ；对 $B2$，则是 $(f$ & $b2)==0$说明不包含 $B2$ 内的任何错误；对满足补丁使用条件的状态建立一条到 $(f$&$f1)|f2$ 状态，权值为 $t$ 的边。然后从满错误状态跑最短路，求到 $0$ 的距离即可。

~~~c++
int n,m,f[MAXN][5],t[MAXN],d[MAXM];
string str;
struct edge{
	int to,w;
	edge(){};
	edge(int To,int W){to=To,w=W;}
};
vector<edge>G[MAXM];
void dij(int s)
{
	memset(d,127,sizeof(d));
	priority_queue<pair<int,int>>que;
	que.push(make_pair(0,s));
	d[s]=0;
	while(!que.empty()){
		pair<int,int> p=que.top();
		que.pop();
		int u=p.second;
		if(d[u]<p.first) continue;
		for(auto e:G[u]){
			int to=e.to;
			if(d[to]>d[u]+e.w){
				d[to]=d[u]+e.w;
				que.push(make_pair(d[to],to));
			}
		}
	}
}
void solve()
{
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		cin>>t[i]>>str;
		for(int j=0;j<n;++j) {
			if(str[j]=='+'){
				f[i][1]+=(1<<j);  //先&1在^1 ==0
			}
			if(str[j]=='-'){
				f[i][2]+=(1<<j);  //&2 ==0
			}
		}
		cin>>str;
		for(int j=0;j<n;++j){
			if(str[j]!='-'){
				f[i][3]+=(1<<j);  //&3表示解决问题
			}
			if(str[j]=='+'){
				f[i][4]+=(1<<j); //|4加入问题
			}
		}
	}
	for(int i=((1<<n)-1);i>=0;--i){
		for(int j=1;j<=m;++j){
			if(((i&f[j][1])^f[j][1])==0&&(i&f[j][2])==0){
				int to=((i&f[j][3])|f[j][4]);
				G[i].push_back(edge(to,t[j]));
			}
		}
	}
	dij((1<<n)-1);
	if(d[0]==2139062143) d[0]=0;
	cout<<d[0];
	return;
}
~~~



### 删边最短路

该模型解决的是如何求 **删除图上任意一条边后的最短路** ？
先定义一些概念，方便后文讲述：最短路边构成的边集合用 $E$ 表示，编号为 $i$ 的边为 $e_i$。
首先讨论删边的位置：
若**删边不在 $E$ 上**，则直接输出原图最短路的长度。
若**删边在 $E$ 上**，则问题比较复杂。若直接删除改边，重跑跑一遍最短路，则时间复杂度最坏为 $O(nmlogn)$，这样必然会超时，因而我们不能逐一考虑 $E$ 中每条边被删除后对最短路的影响；而是反过来，**考虑图上任意一条非最短路边成为新的最短路时对 $E$ 中每条边答案的影响**，即必须区间修改。
接下来考虑这个新的最短路能更新 $E$ 中哪些边的答案。因为不容易考虑某条边的最短路，我们先考虑边上的点。首先可以得到一个定理：**删除一条边后，图上的新最短路$E'$ 必然只能与原图最短路 $E$ 有公共前缀与公共后缀。**通俗来讲，$E'$ 只能与 $E$ 在首尾有重合，而不能有多段重合（这其实很好证明，假设可以有多段，则说明有多端非重合，其中只能有一段是因为删边不能通过导致，由于最短路的性质，其他几段的长度必然大于等于直接选取在 $E$ 上的简单路径，与最短路矛盾，故只能有一段 ）。现做出以下定义：对于每个点 $x$， 设 $l_x$ 表示最小的 $i$，使得在某条 $1→x$ 的最短路上，$e_i$ 是第一条 $E$ 上的不在其中的边；$r_x$ 表示最大的 $i$，使得在某条 $x→n$ 的最短路上，$e_i$ 是最后一条 $E$ 上的不在其中的边。则对每条非最短路边 $e$，我们设它的端点为 $u,v$，则用 $d_{(1,u)} + w_{u,v}+d_{(v,n)}$ 更新区间 $[e_{l_u},e_{r_v}]$，用 $d_{(1,v)} + w_{v,u}+d_{(u,n)}$ 更新区间 $[e_{l_v},e_{r_u}]$。
接下来，只要有方法快速求出上面的几个参量的值即可。对于距离 $d$ ，可以分别从源点和终点跑最短路得到。先考虑 $l_x$ 与 $r_x$ ，对于 $E$ 上的边，直接更新其为 $i$ 与 $i-1$ 即可（$i$ 为边编号）；对于非最短路边，也按照求最短路的顺序更新，若边 $(u,v)$ 满足 $d_{1,u}+w_{u,v}=d_{1,v}$，则 $l_v=min⁡(l_v,l_u)$。可以将点按 $d$ 值排序，就不用重新跑最短路了。
最后，由于是区间修改，还需要使用线段树或者其他数据结构来维护 $E$ 中每条边的答案。这样子，最终的时间复杂度就为 $O(mlogn)$。

例题：[Problem - 1163F - Codeforces](https://codeforces.com/problemset/problem/1163/F)
**题意**：给一个 $n$ 个点，$m$ 条边的无向图，每条边连接点 $u, v$，并且有个长度 $w$。有 $q$ 次询问，每次询问给你一对 $t, x$，表示**仅当前询问**下，将 $t$ 这条边的长度修改为 $x$，请你输出当前 $1$ 到 $n$ 的最短路长度。
**题解**：可以把询问分成四种情况：
1、将非最短路上的边的权值减少，分别求出$d_{(1,u)} + w_{u,v}+d_{(v,n)}$ ， $d_{(1,v)} + w_{v,u}+d_{(u,n)}$ ，取和原最短路的三者最小值即可。
2、将最短路上的边的权值减小，此时直接最短路减去变化值即可。
3、将非最短路上的边的权值增大，直接输出最短路。
4、将最短路上的边的权值增大，输出 原最短路+变化值与删边最短路的小值即可。 

**拓展**：感觉对图/树这种非线性结构的区间做一些操作，都会想办法让其区间变成线性，然后是用线段树等数据结构。

## 最小生成树

kru算法(使用并查集)：

~~~c++
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXM = 2e5 + 10;
const int MAXN = 5e3 + 10;

struct edge {
	int u, v, w;
}G[MAXM];
int n, m, x[MAXM], y[MAXM], z[MAXM];
int fa[MAXN], ra[MAXN];

int find(int s)
{
	return fa[s] == s ? s : fa[s] = find(fa[s]);
}

void unite(int x, int y)
{
	int a = find(x), b = find(y);
	if (ra[a] > ra[b]) fa[b] = a;
	else if (ra[a] < ra[b]) fa[a] = b;
	else {
		fa[a] = b; ra[b]++;
	}
	return;
}

bool cmp(edge x, edge y)
{
	return x.w < y.w;
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> x[i] >> y[i] >> z[i];
		G[i].u = x[i];
		G[i].v = y[i];
		G[i].w = z[i];
	}
	sort(G + 1, G + m + 1, cmp);
	for (int i = 1; i <= n; i++) fa[i] = i;
	int sum = 0;
	for (int i = 1; i <= m; i++) {
		if (find(G[i].u) != find(G[i].v)) {
			unite(G[i].u, G[i].v);
			sum += G[i].w;
		}
	}
	int q = 0;
	for (int i=1;i<=n;i++){
		if (find(i) == i) q++;
	}
	if (q != 1) cout<<"orz";
	else cout << sum;
	return 0;
}
~~~

prim算法（仿迪杰斯特拉）：

~~~c++
mincost[1] = 0; int rec = 0;
	while (true) {
		int v = -1;
		for (int i = 1; i <= N; i++) {
			if (used[i] == 0 && (v == -1 || mincost[i] < mincost[v]) && mincost[i]!=2034567890) v = i;
		}
		if (v == -1) break;
		rec = rec + mincost[v];
		used[v] = 1;
		for (int i = 1; i <= N; i++) {
			mincost[i] = min(mincost[i], cost[v][i]);
		}
	}
~~~

### 唯一MST

判断方法：
1、遍历所有树边，**刨除**树边确认是否可以**重新构造**。
2、计算**非严格次小生成树的值**，若一样则不唯一。

例题：https://vjudge.net/contest/565164#problem/I 板子。

### 次小生成树

**定义**：对于一张无向图G，我们假令G的一颗最小生成树为T，并且一颗非最小生成树为T1，那么如果不存在任意一颗G的生成树T2使得W(T)<W(T2)<W(T1)，则称T1为G的次小生成树。

**非严格次小生成树**： 权值和最小生成树可以相等。

**严格次小生成树**：保证树的权值小于最小生成树。
[P4180 [BJWC2010\] 严格次小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4180)（kru算法+树上倍增lca维护/树上线段树维护）

次小生成树的**发散题**：

**链接**：[Qin Shi Huang's National Road System - HDU 4081 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/HDU-4081)
**题目大意**：有 $n$ 个坐标和人口给出的城市，秦始皇（我）要修路将它们连接起来，可以正常花费距离的代价修路，也可用一条魔法路径连接两个城市，求 (魔法路径连接城市的人口/正常修路的代价）的最大值。
**题目解法**：先求出最小生成树并得到全职，然后遍历所有边。若边属于 $MST$ ，则直接减去改变的权值；若不属于，则查找树中与该边两端点为首位的路径的最大权值，然后计算求解取最大值即可。思路与求次小生成树一致。（但是我是用lca倍增+kru+离散处理依旧 $TLE$ ，后来直接用 $dfs$ 暴力更新过了，我不理解）

## 匈牙利算法

### 二分图

>二分图又称作二部图，是图论中的一种[特殊模型](https://baike.baidu.com/item/特殊模型/19071206?fromModule=lemma_inlink)。 设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。

可以证明，不含奇数环的图都是二分图。

>![image-20230118231547828](C:\Users\滕俊宁\AppData\Roaming\Typora\typora-user-images\image-20230118231547828.png)

如何判断一个图是否为二分图：**染色法**

~~~c++
vector<int> G[maxn];  // 存边
int col[maxn];        // 标记顶点颜色
int n,m;         // 点和边的个数
bool bfs(){
  queue<int> q;
  q.push(1);     // 放入第一个点
  memset(col,0,sizeof(col));
  col[1] = 1;    // 先标记第一个点为1
  while(!q.empty()){
    int v = q.front();
    q.pop();
    for(int i=0;i<G[v].size();i++){
      int xx = G[v][i];
      if(col[xx] == 0){      // 判断这个点是否标记过
        col[xx] = -col[v];   // 没有标记过就标记上与v相反的颜色
        q.push(xx);
      }
      else{
        if(col[v] == col[xx]){    // 如果颜色冲突说明不是二分图
          return false;
        }
      }
    }
  }
  return true;
}
~~~





### 最大匹配数

是一种用于二分图的算法，用来求一个二分图的**最大匹配数**。

>
>
>![img](https://pic3.zhimg.com/80/v2-81f21981c992bc0b5b1acf04b37ff6c2_720w.webp)

即求类似于所给图的模型问题中：已知左右X与Y中元素需要一一对应，那么最多可以有多少条边。

**匈牙利算法**的核心是：**先到先得，能让则让**。如以上图为例，$X1$ 可以和 $Y2 Y4$ 配对，那么先默认和靠上的配对，即 $Y2$ 。然后看 $X2$ ，$X2$ 只能和 $Y2$ 配对，但是 $Y2$ 已经配对了，那么就回过头来看 $Y2$ 和谁配对，发现是 $X1$ ，此时如果 $X1$ 有其他元素可以配对，则选择其他元素，这里即是 $Y4$ 。如果没有，则 $X2$ 就没有配对元素。

**代码实现**

~~~c++
#include <iostream>
using namespace std;
const int MAXN = 10010;

int n, m;  //n,m表示左右集合对应的元素数目
int Map[MAXN][MAXN];   //邻接矩阵存图
int p[MAXN];      //记录当前右侧元素对应的左侧元素
bool vis[MAXN];   //记录右侧元素是否已被访问过

bool match(int i)
{
	for (int j = 1; j <= N; j++) {   //遍历右侧元素
		if (Map[i][j] && !vis[i]) {      //如果右侧元素未被访问过且二者有边相连
			vis[j] = true;             //标记已访问
			if (p[j] == 0 || match(p[j]) {               //如果右侧元素未有对应元素  或者  对应元素有其他元素对应
				p[j]=i; return true;          //找到
			}
		}
	}
	return false;
}

int Hungarain()
{
	int cnt = 0;
	for (int i = 1; i <= n; i++) {
		memset(vis, 0, sizeof(vis));  //重置vis数组  （个人认为vis数组是用在判断待判的右侧元素已经对应的左侧元素时，不把这在接受判断的左侧元素计入，同时也排除了不能配对的元素。
		if (match(i)) cnt++;
	}
	return cnt + ;
}

int mian()
{
	cin
}
~~~



### 最小覆盖点问题

另外一个关于二分图的问题是求**最小点覆盖**：我们想找到**最少**的一些**点**，使二分图所有的边都**至少有一个端点**在这些点之中。倒过来说就是，删除包含这些点的边，可以删掉所有边。

>
>
>![img](https://pic2.zhimg.com/80/v2-bfae6bb1c63b4ff1522b16a7bb81615d_720w.webp)

**（König定理）**

> 一个二分图中的最大匹配数**等于**这个图中的最小点覆盖数。

因而我们就可以用匈牙利算法来解决这个问题.



## 欧拉路径

**欧拉路径**为无向图/有向图中经过所有边但每条边只经过一次的路径。
欧拉路径分为欧拉回路与欧拉路径，即路劲终点是否与起点相同。

- **欧拉回路**
  1. 无向图：所有点的度数都是偶数。
  2. 有向图：所有点出度等于入度。
- **欧拉通路**
  1. 无向图：相比欧拉回路，可以看成有一个起点，一个终点，即可以有两个点的度数是奇数，开始搜索时，起点为其中一个奇点（七桥问题
  2. 有向图：同理，相比欧拉回路，可以看成有一个起点，一个终点，即可以有一个起点是出度=入度+1，一个终点是入度=出度+1
  3. 注意欧拉回路是欧拉路径的一种特殊情况，即要注意考虑没有奇点/所有点出入度都相同的情况。

判断直接通过遍历点的**入度**和**出度**即可。

如果要求完整的路径，可以使用 $Hierholzer$ 算法。该算法的精髓是当每次访问一条边的时候，删除这条边，当遍历完一个节点所连的所有节点后，才将该节点入栈，最后将栈中的节点反转，即可得到欧拉路径。时间复杂度为 $O(V+E)$。

~~~c++
vector<int>G[MAXN];
stack<int>ans;
int now[MAXN]; //now-记录某点已经访问到第几条边 
void Hierholzer(int s)
{
    for(int i=now[s];i<G[s].size();i=now[s]) 
    {
        now[s]++;
        Hierholzer(G[s][i]);
    }
    ans.push(s);
    return;
}
~~~

例题：[Problem - 1981D - Codeforces](https://codeforces.com/problemset/problem/1981/D)
题解：这道题是一个构造题，详情可见 题目训练。



## **拓扑排序**

**拓扑排序**是对**DAG**（有向无环图）上的节点进行排序，使得对于每一条有向边 u→v ， u 都在 v 之前出现。简单地说，是在不破坏节点**先后顺序**的前提下，把**DAG**拉成一条**链**。如果以游戏中的科技树*（虽然名字带树，其实常常不是树而只是DAG）*举例，拓扑排序就是找到一种**可能的**点科技树的**顺序**。

![算法学习笔记(53): 拓扑排序](https://pic1.zhimg.com/v2-ecb3af795e137fb78582689b9270d28d_720w.jpg?source=172ae18b)

拓扑排序最经典的算法是**Kahn算法**。时间复杂度为n*m，其中，n代表点，m代表边。

~~~c++
int deg[MAXN],a[MAXN];  //其中deg是入度，a是排序后的数组
   
bool toposort(int n)
{
    int cnt=0;
    queue <int> que;
    for (int i=1;i<=n;i++){
        if (deg[i]==0) que.push(i);
    }
    while(!que.empty()){
        int u=que.front();
        a[++cnt]=u;
        que.pop();
        for (int i=0;i<G[u].size();i++){     //G是储存边的vector容器
            int e=G[u][i].to;
            deg[e]--;
            if(deg[e]==0) que.push(e);
        }
    }
    return cnt==n;  //是否能排序 (若未成功则说明有环)
}
~~~

**例题**：洛谷P1347



### 判断图中是否有环

可以用拓扑排序来判断图中是否有环。







## 强连通分量

**定义**

**连通**：**无向图**中，从任意点 $i$ 可以到达 $j$ 。

**强连通**：**有向图**中，从任意点 $i$ 可以到达 $j$ 。

**弱联通**：把**有向图看成无向图**时，从任意点 $i$ 可以到达 $j$ 。

**强连通分量**是有向图的**极大**的强连通子图。所谓“极大”意味着，把图划分为若干个强连通分量后，不存在两个强连通分量相互可达。

**核心思想**

实现强连通分量的基本思路，是通过 **dfs** 从根节点开始遍历图，记录每一个点的**遍历序号** $(dfsn(i))$ 与通过有向边**可以回溯到的最早遍历序号** $(low(i))$，然后根据这两个点的值来确定强连通分量。

>![img](https://pic3.zhimg.com/80/v2-e7e7a4b03fac528b20756592334e03e2_720w.webp)

以 $1$ 为根节点开始进行遍历，注意，该dfs遍历是先进行传递遍历，再回溯进行值的读出。

考虑 $1$，则 $dfsn(1) = 1, low(1) = 1$。按序遍历，则到第二个点 $dfsn(2) = 2,low(2) = 2$， 第三个点中 $dfsn(3) = 3, low(3) = 3$，而因为第三个点可以通过有向边指向 $1$ ，所以 $low(3)$ 更新为 $1$ , 此时 $3$ 结束，则回溯到 $2$ ，$low(2)$ 也更新为 $1$ 。$2$ 开始继续遍历，则 $dfsn(4)=4,low(4)=4$ ,结束，回到 $2$ ，再回到 $1$。那么当遍历完全结束后，得到 $low$ 值如图：

>![img](https://pic3.zhimg.com/80/v2-b9d5bb59070317978fbfff3b224f3402_720w.webp)
>
>*不难看出，其中各个颜色的部分即为强连通分量。*

而当 **$dfs(n) = low(n)$** 时，表明 $n$ 点不可能通往与更早的时间点，可以得出该点是一个强连通分量的**根**。而为了统计以 $n$ 点为根的强连通分量还有什么点，可以构建一个**栈**，当**遍历的时候将点 $i$ 入栈**，如果访问到 $dfs(n) = low(n)$ 的点时，则**进行出栈操作直至 $n$ 点出栈**，其中出栈的点都与 $n$ 在同一个强连通分量中。

比如当遍历进行到 $4$ 的时候，栈中元素分别为 $1,2,3,4$ ，得到 $dfs(n) = low(n)$ ，则将 $4$ 弹出，$5,6,7,8$ 也是同理，不断弹出至 $5$ 弹出为止。

**代码实现**

~~~c++
stack<int> stk;
// instk：是否在栈中  scc：每个点所属的强连通分量编号  cscc：强连通分量的数量
int dfsn[MAXN], low[MAXN], instk[MAXN], scc[MAXN], cnt, cscc;
void tarjan(int p)
{
    low[p] = dfsn[p] = ++cnt;
    instk[p] = 1;
    stk.push(p); // 进栈
    for (auto q : edges[p])
    {
        if (!dfsn[q]) // 未访问过
        {
            tarjan(q); // 递归地搜索
            low[p] = min(low[p], low[q]);
        }
        else if (instk[q]) // 访问过，且q可达p
            low[p] = min(low[p], dfsn[q]);
        //这里写成 low[p] = min(low[p], low[q]);应该更好,不过应该没有影响
        
        ////2023.12.28 不可以写成 low[p]=min(low[p],low[q]),因为如果指向的节点已经被弹出栈
        ////说明该节点q和正在访问的节点p属于不同的强连通分量。
        ////但是p可以指向q，因此q不存在指向p的边，那么q的low值应该小于p。
        ////但是由于深度搜索的局限性，导致q先被访问，因而得到更高的low值
        ////该代码的存在是限制此bug的产生。
        
        //因为即使q的low可以更新，但是此时还没有回溯到q，q的信息没有更新完全，
        //low[q]依旧可能与dfsn[q]相等
        //low[q]的意义严谨来说是可以直接到达的最小dfsn序值
        //只要low[p]与dfsn[p]不相等就可以说明不是根
    }
    if (low[p] == dfsn[p]) // 回溯后发现强连通分量的根
    {
        int top;
        cscc++;
        do
        {
            top = stk.top();
            stk.pop();
            instk[top] = 0;
            scc[top] = cscc; // 记录所属的强连通分量
        } while (top != p); // 直到弹出p才停止
    }
}
~~~

因为图不一定是强连通的，因而需要一所有点为根节点进行一次遍历。

~~~c++
for (int i = 1; i <= n; ++i)
    if (!dfsn[i])
        tarjan(i);
~~~

**拓展**

给出一个**有向无环图**，如果要将它变为一个**强连通图**，需要的最小步骤数为**入度为零的点**的个数和**出度为零**的点的个数的较大值。



## 割点和桥

**定义**

如果删除**无向图**中的某个**点**会使无向图的**连通分量数**增多，则把这个点称为**割点**。

如果删除**无向图**中的某条**边**会使无向图的连通分量数增多，则把这个点称为**割边**或**桥**。

**核心思想**

同样是通过**tarjan**算法。首先递归遍历得到每个点的 $dfsn(n), low(n)$ ，那么如果某个点的 $dfsn(n) <=$ 他的子节点的 $low(m)$ ，则表明该点的子树，无法通过其他途径回到比它更早的点，而只能通过它，即可得到点 $n$ 为割点。

有一种特殊情况，即当 $n$ 是根节点时，则只要有**两个及以上子节点**，则说明根节点是割点。

~~~c++
int dfsn[MAXN], low[MAXN], cnt;
vector<int> cut; // 存储所有割点
void tarjan(int p, bool root = true)
{
    int tot = 0;
    low[p] = dfsn[p] = ++cnt;
    for (auto q : edges[p])
    {
        if (!dfsn[q])
        {
            tarjan(q, false);
            low[p] = min(low[p], low[q]);
            tot += (low[q] >= dfsn[p]); // 统计满足low[q] >= dfsn[p]的子节点数目
        }
        else
            low[p] = min(low[p], dfsn[q]);
    }
    if (tot > root) // 如果是根，tot需要大于1；否则只需大于0
        cut.push_back(p);
}
~~~

类似的，求**桥**的时候，只需要某个点的 $dfsn(n) <$ 他的子节点的 $low(m)$，则说明该边是桥。

与求**割点**不同的是，某个点不能通过指向其父节点的通路更新 $low$ 值。

~~~c++
vector<pair<int, int>> bridges;
int dfsn[MAXN], low[MAXN], fa[MAXN], cnt;
void tarjan(int p)
{
    low[p] = dfsn[p] = ++cnt;
    for (auto to : edges[p])
    {
        if (!dfsn[to])
        {
            fa[to] = p; // 记录父节点
            tarjan(to);
            low[p] = min(low[p], low[to]);
            if (low[to] > dfsn[p])
                bridges.emplace_back(p, to);
        }
        else if (fa[p] != to) // 排除父节点
            low[p] = min(low[p], dfsn[to]);
    }
}
~~~







## 传递闭包

从数学上来说，传递闭包是在集合 $X$ 上求包含关系 $R$ 的最小传递关系。

从关系图的角度来说，就是如果原关系图上有 $i$ 到 $j$ 的**路径**，则其传递闭包的关系图上就应有从 $i$ 到 $j$ 的**边**。通俗地讲，就是确定每个点是否能到达其他每个点。

而这，把Floyd最短路算法稍微改一下即可。设 $E$ 是原来的关系矩阵，则可以这样写：

```c++
for (int k = 1; k <= n; ++k)
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            if (E[i][k] && E[k][j])
                E[i][j] = 1;
```

复杂度为 $O(n^3)$。



# 树上问题

## 树基础

**遍历方式**

**前序**遍历：中左右。**中序**遍历：左中右。**后序**遍历：左右中。

中序遍历和前序/后序遍历已知，二叉树**唯一确定**。前序遍历和后序遍历已知，二叉树**有多种可能**：这种可能个数可以通过求**只有一个子叶**的节点数确定，而在前序遍历中是 $AB$ 在后序遍历中是 $BA$ 的是

### 树重心

计算以无根树每个点为根节点时的**最大子树大小**，这个值最小的点称为无根树的**重心**。
树重心的五个性质：

>1、某个点是树的**重心**等价于它最大子树大小**不大于**整棵树大小的**一半**。
>2、树**至多有两个**重心。如果树有两个重心，那么它们**相邻**。此时树一定有**偶数**个节点，且可以被划分为两个大小相等的分支，每个分支各自包含一个重心。
>3、树中所有点到某个点的**距离和**中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样。反过来，距离和最小的点一定是重心。
>4、往树上增加或减少一个**叶子**，如果原节点数是奇数，那么重心可能**增加**一个，原重心**仍是重心**；如果原节点数是偶数，重心可能**减少**一个，剩下的另一个重心**仍是重心**。
>5、把两棵树通过一条边相连得到一棵新的树，则新的重心在**较大**的一棵树一侧的**连接点**与**原重心**之间的**简单路径**上。如果两棵树大小一样，则重心就是两个连接点。

~~~c++
int n, sz[MAXN], mss[MAXN]; //n：总结点数（请从外部传入），sz：树的大小，mss：最大子树大小
vector<int> ctr; //重心
void dfs(int s, int fa = 0) //找重心
{
    sz[s] = 1, mss[s] = 0;
    for (auto [to, w] : edges[s])
        if (to != fa)
        {
            dfs(to, s);
            mss[s] = max(mss[s], sz[to]);
            sz[s] += sz[to];
        }
    mss[s] = max(mss[s], n - sz[s]); //考虑父节点那一半的子树大小
    if (mss[s] <= n / 2) ctr.push_back(s); //获取重心
}
~~~

例题：[P1395 会议 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1395)

### 树直径

**树的直径是指树中最长的简单路径的长度。** 这意味着要找到树中两个最远的节点之间的距离。求树的直径有两种方法：**深搜**和**树形dp**。

**法一**：跑两遍dfs

容易证明，距离树上任意一点**距离最远的点**必然是直径的端点（证明用**反证法**，假设距离最远的点不是直径端点，用距离最远的点替换直径端点，则可以得到更长的树上简单路径，与直径定义矛盾，得证）。那么取树上任意一点，跑一遍 $dfs$ 找到距离最远的点，即是直径的一个端点；在用该端点跑一遍 $dfs$ 即可求到另一个端点。

~~~c++

~~~

**法二**：树形dp

相比于深搜，树形dp可以处理**边权值为负数**的情况。

**例题**

[Problem - 7452 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=7452)
**关键词**：树上dfs，求树的直径，分类讨论
**题目大意**：对于一个节点 $i$ 的成长，先将这个节点变为 $d_i$ 边型（ $d_i$ 为这个点的度数），然后将原本与这个点相连的边随机匹配多边形上的点，再随机删除由这个点变化成的多边形上的一条边。特别的，对于一个度数为0或1的点，进行成长将不会发生变化。对于一棵树的成长，定义为树上所有的节点进行一次成长。
求经过 $m$ 次成长后所给树最长的可能直径长度（这里定义树的直径的长度为直径上的点数。）
**题解**：注意到，一个度数为 $d$ 的节点，经过一次成长，对使树变长的最大贡献为 $d-1$，即得到 $d-1$ 个度为 $2$ 的节点，并且在新链的末端重新得到一个与原节点度数相同的一个节点（容易证明此种扩展方式是使树成长为最长情况的其中一种），那么一个度数为 $d$ 的节点，经过 $m$ 次成长，就会贡献 $(2^m-1)*(d-1)$ 个节点。那么根据 $m$ 的大小将情况分为两种：$m$ 较小的时候，同时考虑直径原长和度数的影响（因为不会被取模影响取大小）；$m$ 较大的时候，只考虑度数的影响（增长的足够多，仅考虑增长幅度），但是总度数和一样的时候根据原长排序。用求树直径的方法跑两编 $dfs$ 即可。

~~~c++
ll n,m,deg[MAXN],rt,d[MAXN],dep[MAXN];
//deg-度数 d-deg-1的和 dep-节点数目和
vector<int>G[MAXN];
void init()
{
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		G[i].clear();
		deg[i]=d[i]=dep[i]=0;
	}
}
ll cal(int s)
{
	ll w=1e9;
	if(m<30) w=qpow(2,m)-1; //m较小的时候
	return 1ll*w*(d[s]-1)+dep[s];	
}
void dfs(int s,int fa=0)
{
	if(cal(s)>cal(rt)) rt=s;
	for(auto to:G[s]){
		if(to==fa) continue;
		d[to]=deg[to]-1+d[s];
		dep[to]=dep[s]+1;
		dfs(to,s);
	}
}
void solve()
{
	for(int i=1;i<n;++i){
		int u=read(),v=read();
		G[u].push_back(v);
		G[v].push_back(u);
		deg[u]++,deg[v]++;
	}
	rt=1;
	d[1]=deg[1]-1;
	dep[1]=1;
	dfs(1,1);
	d[rt]=deg[rt]-1;
	dep[rt]=1;
	dfs(rt);
	ll ans=(((qpow(2,m)-1)*d[rt])%mode+dep[rt])%mode;
	cout<<ans<<'\n';
	return;
}
~~~





## 最近公共祖先(LCA)

朴素的做法，先通过dfs求出每个点的深度。

再将较低的点向上爬直至与零、另一点同高。一起向上爬直至找到LCA。查询的时间复杂度为 $O(n)$。

~~~c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int MAXN = 100100;

int N, M, p;
vector <int> G[MAXN];
int dep[MAXN], fa[MAXN];
bool vis[MAXN];

void dfs(int cur, int fath)   //dfs以求出每一个点的深度
{
	if (vis[cur]) return;
	vis[cur] = true;
	dep[cur] = dep[fath] + 1;
	for (int i = 0; i < G[cur].size(); i++)
		dfs(G[cur][i], cur);
	return;
}

int lca(int a, int b)    //求lac
{
	if (dep[a] > dep[b]) swap(a, b);        //不妨假设a比较浅
	while (dep[a] != dep[b]) b = fa[b];     //保证同等高度
	if (a == b) return a;
	for (int k = dep[a]; k >= 0; k--) {     //一起向上
		if (fa[a] != fa[b]) {
			a = fa[a]; b = fa[b];
		}
	}
	return fa[a];
}

int main()
{
	cin >> N >> M;
	for (int i = 1; i <= M; i++) {     //构树
		int u, v; cin >> u >> v;
		G[u].push_back(v);
		fa[v] = u;
	}
	dfs(1, 0);
	cin >> p;
	while (p--) {                 //求lca
		int u, v;
		cin >> u >> v;
		cout << lca(u, v);
	}
	return 0;
}
~~~

$O(n)$ 的时间复杂度显然很容易超时，可以使用倍增的算法使时间复杂度降为 $O(logn)$ 。

~~~c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int MAXN = 5e5 + 10;

int N, M, S;
int fa[MAXN][25], dep[MAXN], lg[MAXN], vis[MAXN];
//fa中第二项的常数主要是根据数据范围决定，一般情况下25足够
vector <int> G[MAXN];

void dfs(int s, int fath = 0)
{
	if (vis[s]) return;
	vis[s] = true;
	dep[s] = dep[fath] + 1;
	fa[s][0] = fath;
	for (int i = 1; i <= lg[dep[s]]; i++) {
		fa[s][i] = fa[fa[s][i - 1]][i - 1];
	}
    //倍增的主要思想
	for (int i = 0; i < G[s].size(); i++) {
		dfs(G[s][i], s);
	}
	return;
}

int lca(int a, int b)
{
	if (dep[a] > dep[b]) swap(a, b);
	while (dep[a] != dep[b]){
        b = fa[b][lg[dep[b] - dep[a]]];
	}
	if (a == b) return a;
	for (int k = lg[dep[a]]; k >= 0; k--) {
		if (fa[a][k] != fa[b][k])
			a = fa[a][k], b = fa[b][k];
	}
	return fa[a][0];
}

int main()
{
	cin >> N >> M >> S;
	for (int i = 1; i < N; i++) {
		int u, v;
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	lg[1] = 0; for (int i = 2; i <= N; i++) lg[i] = lg[i >> 1] + 1;
	dfs(S);
	for (int i = 1; i <= M; i++) {
		int u, v;
		cin >> u >> v;
		cout << lca(u, v) << '\n';
	}
	return 0;
}
~~~



## 重链剖分

基本思路：一种对树中元素进行分类的一种方式。将每个节点中节点最多的子树称为**重子节点**，其他的称为**轻子节点**。那么从根开始，所有的节点都指向重子节点，就会形成一条条**链**，即重链剖分。
重链剖分有一个重要的性质：**对于节点数为 $𝑛$ 的树，从任意节点向上走到根节点，经过的轻边数量不超过 $log⁡𝑛$** 。（这个结论会在**树上启发式合并**中用到）。

> 这是因为，如果一个节点连向父节点的边是轻边，就必然存在子树不小于它的兄弟节点，那么父节点对应子树的大小一定超过该节点的两倍。每经过一条轻边，子树大小就翻倍，所以最多只能经过 $log⁡𝑛$ 条。

![img](https://pic1.zhimg.com/80/v2-4a2b4cb96b4ce1f40595e0e61ff06fd8_720w.webp)

第一次 $dfs$，求出每个节点的**子树大小**、**父节点**、**重子节点**。基本思路与求树的重心一致。

~~~c++
void dfs1(int s, int h = 1)
{
	int size = 1, ma = 0;
	dep[s] = h;
	for (auto q : G[s]) {
		if (!dep[q]) {
			dfs1(q, h + 1);
			fa[q] = s;
			size += sz[q];
			if (sz[q] > ma) {
				ma = sz[q];
				hson[s] = q;
			}
		}
	}
	sz[s] = size;
}
~~~

第二次 $dfs$，求出每一个节点的链头

~~~c++
void dfs2(int s)
{
	for (auto q : G[s]) {
		if (!top[q]) {
			if (hson[s] == q) {
				top[q] = top[s];
			}
			else {
				top[q] = q;
			}
			dfs2(q);
		}
	}
}
~~~

### 求LCA

~~~c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int MAXN = 5e5 + 10;

int N, M, S;
vector <int> G[MAXN];

int fa[MAXN], dep[MAXN], sz[MAXN], hson[MAXN], top[MAXN];
void dfs1(int s, int h = 1)
{
	int size = 1, ma = 0;
	dep[s] = h;
	for (auto q : G[s]) {
		if (!dep[q]) {
			dfs1(q, h + 1);
			fa[q] = s;
			size += sz[q];
			if (sz[q] > ma) {
				ma = sz[q];
				hson[s] = q;
			}
		}
	}
	sz[s] = size;
}
void dfs2(int s)
{
	for (auto q : G[s]) {
		if (!top[q]) {
			if (hson[s] == q) {
				top[q] = top[s];
			}
			else {
				top[q] = q;
			}
			dfs2(q);
		}
	}
}

int lca(int a, int b)
{
	while (top[a] != top[b]) {
		if (dep[top[a]] > dep[top[b]]) {
			a = fa[top[a]];
		}
		else {
			b = fa[top[b]];
		}
	}
	return dep[a] > dep[b] ? b : a;
}

int main()
{
	cin >> N >> M >> S;
	for (int i = 1; i < N; i++) {
		int u, v;
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs1(S);
	top[S] = S;
	dfs2(S);
	for (int i = 1; i <= M; i++) {
		int u, v;
		cin >> u >> v;
		cout << lca(u, v) << "\n";
	}
	return 0;
}
~~~

### +数据结构

通过求 $lca$ 可以快速得到树上两个点之间的简单路径的长度，只需要将深度相减再相加即可。
现在将问题扩展：每个点都有权值，要对该树进行两个操作：修改点 $x,y$ 之间所有点的权值；求点 $x,y$ 为端点的简单路径的权值和。
初步来看，这有一点类似于**线段树**的区间修改和区间查询，我们考虑将树上的节点划分为**一个个连续的区间**，恰好重链剖分将树划分为了一条条链。因此可以使用树链剖分+线段树的方式来解决上述问题。

板子：[P3384 【模板】重链剖分/树链剖分 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P3384)

~~~c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+10;
const int MAXM = 1e5+10;
const int INF = 0x7fffffff;
const long long inf = 1e18;
typedef long long ll;
const int dx[] = { -1,0,1,0 }, dy[] = { 0,1,0,-1 };
#define lowbit(x) x&(-x)
#define debug(x) cout<<"?"<<x<<"?\n";
inline int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch>'9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - 48; ch = getchar(); }
    return x * f;
}

int n,m,r,mode,w[MAXN];
vector<int>G[MAXN];

//重链剖分部分
int fa[MAXN],dep[MAXN],sz[MAXN],hson[MAXN],top[MAXN];
void dfs1(int s,int d=1)
{
    int size=1,ma=0;
    dep[s]=d;
    for(auto to:G[s]){
        if(!dep[to]){
            dfs1(to,d+1);
            fa[to]=s;
            size+=sz[to];
            if(sz[to]>ma)
                hson[s]=to,ma=sz[to];
        }
    }
    sz[s]=size;
}
int cnt=0,dfsn[MAXN],rdfsn[MAXN];
void dfs2(int s)
{
    dfsn[s]=++cnt;
    if(hson[s]!=0)
    {
        top[hson[s]]=top[s];
        dfs2(hson[s]);
    }
    for(auto to:G[s])
    {
        if(!top[to])
        {
            top[to]=to;
            dfs2(to);
        }
    }
    rdfsn[s]=cnt;
}

//线段树部分
ll a[MAXN];
ll tree[MAXN * 4], lazy[MAXN * 4];
void build(ll p = 1, ll l = 1, ll r = n)
{
	if (l == r) tree[p] = a[l];
	else {
		ll mid = (l + r) / 2;
		build(p * 2, l, mid);
		build(p * 2 + 1, mid + 1, r);
		tree[p] = tree[p * 2] + tree[p * 2 + 1];
        tree[p]%=mode;
	}
	return;
}
inline void push_down(ll p, ll len)
{
	lazy[p * 2] += lazy[p];
	lazy[p * 2 + 1] += lazy[p];
    lazy[p*2]%=mode;
    lazy[p*2+1]%=mode;
	tree[p * 2] += (len - len / 2) * lazy[p];
	tree[p * 2 + 1] += lazy[p] * (len / 2);
    tree[p*2]%=mode;
    tree[p*2+1]%=mode;
	lazy[p] = 0;
	return;
}
void update(ll cl, ll cr, ll d, ll p = 1, ll l = 1, ll r = n)
{
	if (l > cr || r < cl) return;
	else if (l >= cl && r <= cr) {
		tree[p] += d * (r - l + 1);
        tree[p]%=mode;
		if (l < r) lazy[p] = (lazy[p]+d)%mode;
	}
	else {
		ll mid = (l + r) / 2;
		push_down(p, r - l + 1);
		update(cl, cr, d, p * 2, l, mid);
		update(cl, cr, d, p * 2 + 1, mid + 1, r);
		tree[p] = (tree[p * 2] + tree[p * 2 + 1])%mode;
	}
	return;
}
ll ask(ll cl, ll cr, ll p = 1, ll l = 1, ll r = n)
{
	if (l > cr || r < cl) return 0;
	else if (l >= cl && r <= cr) return tree[p];
	else {
		ll mid = (l + r) / 2;
		push_down(p, r - l + 1);
		return (ask(cl, cr, p * 2, l, mid) + ask(cl, cr, p * 2 + 1, mid + 1, r))%mode;
	}
}

//快速改变/求树上值部分
void update_path(int x,int y,int z)
{
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])
            swap(x,y);
        update(dfsn[top[x]],dfsn[x],z);
        x=fa[top[x]];
    }
    if(dep[x]<dep[y]) swap(x,y);
    update(dfsn[y],dfsn[x],z);
}
ll ask_path(int x,int y)
{
    ll ans=0;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        ans+=ask(dfsn[top[x]],dfsn[x]);
        ans%=mode;
        x=fa[top[x]];
    }
    if(dep[x]<dep[y]) swap(x,y);
    ans+=ask(dfsn[y],dfsn[x]);
    return ans%mode;
}
void update_subtree(int x,int z)
{
    update(dfsn[x],rdfsn[x],z);
}
ll ask_subtree(int x)
{
    return ask(dfsn[x],rdfsn[x]);
}

void solve()
{
    cin>>n>>m>>r>>mode;
    for(int i=1;i<=n;++i)
    {
        cin>>w[i];
    }
    for(int i=1;i<n;++i)
    {
        int u=read(),v=read();
        G[u].push_back(v);
        G[v].push_back(u);
    }

    dfs1(r);
    top[r]=r;
    dfs2(r);
    for(int i=1;i<=n;++i)
    {
        a[dfsn[i]]=w[i];
    }
    build();

    for(int i=1;i<=m;++i)
    {
        int op=read(),x=read();
        if(op==1)
        {
            int y=read(),z=read();
            update_path(x,y,z);
        }
        if(op==2)
        {
            int y=read();
            cout<<ask_path(x,y)%mode<<'\n';
        }
        if(op==3)
        {
            int z=read();
            update_subtree(x,z);
        }
        if(op==4)
        {
            cout<<ask_subtree(x)%mode<<'\n';
        }
    }
    return;
}

int main()
{
    int t=1;
    //cin>>t;
    while(t--)
    {
        solve();
    }
}
~~~



## 树上启发式合并

**树上启发式合并**，是一种解决某些**树上离线问题**的算法，尤其常被用于解决“对每个节点，询问关于其子树的某些信息”这样的问题。
假设我们要对树上的每个节点 $p$ 求 $ans[p]$ ，且这个 $𝑎𝑛𝑠[𝑝]$ 可以通过合并 $𝑝$ 的子节点的某些信息得知，一般来说我们可以用树形DP解决。但如果“子节点的某些信息”的规模较大，简单的树形DP在时间和空间上都可能爆炸。所以我们不能存储每个节点的信息，而是要实现某种**资源复用**。

**（[CF600E](https://codeforces.com/problemset/problem/600/E)）Lomsat gelral**

> You are given a rooted tree with root in vertex 1. Each vertex is coloured in some colour.
> Let's call colour *c* dominating in the subtree of vertex *v* if there are no other colours that appear in the subtree of vertex *v* more times than colour *c*. So it's possible that two or more colours will be dominating in the subtree of some vertex.
> The subtree of vertex *v* is the vertex *v* and all other vertices that contains vertex *v* in each path to the root.
> For each vertex *v* find the sum of all dominating colours in the subtree of vertex *v*.

**题意**：给树的节点染色，子树中出现最多次的颜色（可能有多个）称为占领该子树，对每个节点，求占领该节点所对应子树的颜色的编号之和。
在本题中， $𝑎𝑛𝑠[𝑝]$ 表示占领 𝑝 所对应子树的颜色的编号之和，我们需要对树上的每个节点 $𝑝$ 求 $𝑎𝑛𝑠[𝑝]$。诚然，可以给每个节点 𝑝 分配一个桶 $𝑐𝑛𝑡[𝑝]$ ，表示其子树中各个颜色的数量，通过合并 $𝑝$ 的子节点的信息可以计算 $𝑐𝑛𝑡[𝑝]$，进而算出 $𝑎𝑛𝑠[𝑝]$ 。然而，这样复杂度太大了。为了解决这个问题，我们不能对每个节点都维护其信息，而要进行资源的**复用** 。
朴素的优化方式，更新每个点的时候都用**同一个**桶，每次更新完就清空。这样子空间复杂度合格了，但是必然会$TLE$。不难发现，递归计算节点 $s$ 的数据后，可以不清空其**最后一个子节点**对桶的影响，因为其在计算 $s$ 对 $s$ 父节点的贡献时也会产生影响，即使被清空也会被重新加入，这样子就有了一定的优化。如何使优化最大？令最后一个子节点最大。容易想到用**树链剖分**的思想快速得到每个节点的重子节点，将其作为不清空的最后一个子节点，由于还有结论：对于节点数为 $𝑛$ 的树，从任意节点向上走到根节点，经过的轻边数量不超过 $log⁡𝑛$，因而时间复杂度就为 $O(nlogn)$ 了。
**代码**：

~~~c++
//std::ios::sync_with_stdio(false);
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+10;
const int MAXM = 1e5+10;
#define ll long long 
#define debug(x) cout<<"?"<<x<<"?\n";
inline int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch>'9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - 48; ch = getchar(); }
    return x * f;
}

int n,col[MAXN];
vector<int>G[MAXN];

int dep[MAXN], sz[MAXN], hson[MAXN];
void dfs1(int s, int h = 1)
{
	int size = 1, ma = 0;
	dep[s] = h;
	for (auto q : G[s]) {
		if (!dep[q]) {
			dfs1(q, h + 1);
			size += sz[q];
			if (sz[q] > ma) {
				ma = sz[q];
				hson[s] = q;
			}
		}
	}
	sz[s] = size;
}

ll ans[MAXN],sum,cnt[MAXN],maxn;
void add(int s)
{
    int temp=++cnt[col[s]];
    if(temp>maxn) {
        maxn=temp,sum=col[s];
    } else if(temp==maxn) {
        sum+=col[s];
    }
}
void del(int s)
{
    --cnt[col[s]];
}
void addsubtree(int s,int fa=-1)
{
    add(s);
    for(auto to:G[s])
    {
        if(to!=fa) 
            addsubtree(to,s);
    }
}
void delsubtree(int s,int fa=-1)
{
    del(s);
    for(auto to:G[s])
    {
        if(to!=fa) 
            delsubtree(to,s);
    }
}
void dfs(int s,int fa=-1,bool keep=1)
{
    for(auto to:G[s])
    {
        if(to!=fa&&to!=hson[s])
            dfs(to,s,0);
    }
    if(hson[s]) dfs(hson[s],s,1);
    add(s);
    for(auto to:G[s])
    {
        if(to!=fa&&to!=hson[s])
            addsubtree(to,s);
    }
    ans[s]=sum;
    if(!keep){
        delsubtree(s,fa);
        maxn=sum=0;
    }
}

void solve()
{
    n=read();
    for(int i=1;i<=n;++i)
    {
        col[i]=read();
    }
    for(int i=1;i<n;++i)
    {
        int u=read(),v=read();
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs1(1);
    dfs(1);
    for(int i=1;i<=n;++i)
    {
        printf("%lld ",ans[i]);
    }
    return;
}

int main()
{
    int t=1;
    //cin>>t;
    while(t--)
    {
        solve();
    }
}
~~~

**例题**

[Problem - 7435 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=7435)
关键字：树上启发式合并，树状数组
题目大意：
题解：



## 点分治

**点分治**主要用来求树上路径的问题。

假如要遍历统计树上每条边的信息，朴素的算法是依次对每一个点进行**dfs**，时间复杂度 $O(n^2)$ 。

考虑使用分治。将路径分为**经过某节点**与**不经过某节点**的，经过根节点的部分转化为**遍历子树**的问题即可；而不经过的则可以**递归**的进行处理，通过删除原来的根节点，再寻找新的根节点，重复上述操作直到遍历所有边。从而将原问题变为一个个简单的子问题，递归实现，以提高效率。

如果所给的树是一条**链**，逐一的删点，则时间复杂度会退化为 $O(n^2)$ 。如果每次选取的都是树的**重心**，则每次删点后得到的多棵子树的大小均会小于原子树的一半，则时间复杂度为 $O(nlogn)$ 。

那么点分治的题目就可以分为大致三个模块：

**寻找树的重心**，比较的模板，不多解释。

~~~c++
void dfs(int s, int fa = 0)  //查找重心
{
	sz[s] = 1;
	int mss = 0;
	for (auto to : G[s]) {
		if (to != fa && !del[to]) {
			dfs(to, s);
			if (ctr != -1) return; //找到重心即可退出
			mss = max(mss, sz[to]);
			sz[s] += sz[to];
		}
	}
	mss = max(mss, n - sz[s]);
	if (mss <= n / 2) {
		ctr = s;
		sz[fa] = n - sz[s]; //更新根节点遍历时候的父节点的树大小，以便后面分治使用·1
	}
	return;
}
~~~

**对问题的求解**。改模块代码根据题目而定。

**递归的实现**。即删除原根节点，在子树中寻找新的根节点并继续解决问题。

~~~c++
void run(int s)
{
	/*
	    统计过根节点的答案。
	*/
    //
	
	//统计不经过根节点的答案
	del[s] = 1; //将根节点删除
	for (auto to : G[s]) {  //删掉原来节点，寻找新的根节点
		if (!del[to]) {
			n = sz[to];  //因为只再子树内操作，因而不会改变其他子树中节点的sz大小
			ctr = -1;  
			dfs(to);
			run(ctr); //进行下一次操作
		}
	}
}

int solve()  //进行点分治。
{
	ctr = -1;
	dfs(1);
	run(ctr);
	return ans; //返回答案
}

~~~



例题：

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 1e5 + 10;
const int MAXK = 5e2 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n, k, u, v;
vector <int> G[MAXN];
bool del[MAXN];

int sz[MAXN], ctr;
void dfs(int s, int fa = 0)  //查找重心
{
	sz[s] = 1;
	int mss = 0;
	for (auto to : G[s]) {
		if (to != fa && !del[to]) {
			dfs(to, s);
			if (ctr != -1) return; //找到重心即可退出
			mss = max(mss, sz[to]);
			sz[s] += sz[to];
		}
	}
	mss = max(mss, n - sz[s]);
	if (mss <= n / 2) {
		ctr = s;
		sz[fa] = n - sz[s]; //更新根节点遍历时候的父节点的树大小
	}
	return;
}

//cntt用来构建temp数组，temp存入路径长；
//lens维护的是前面遍历过的子树出现过的边长数目，cnt则是答案；
int cntt = 0, cnt = 0, lens[MAXK], temp[MAXN];
void dfs2(int s, int fa, int len) //遍历子树，求经过根节点路径为k的道路数目
{
	if (len > k) return;
	//左边是到其他子树，右边是到根节点
	cnt += lens[k - len] + (len == k);  //更新答案
	temp[cntt++] = len;  //存入新的路径长
	for (auto to : G[s]) {
		if (!del[to] && to != fa) {
			dfs2(to, s, len + 1);  //继续遍历子树
		}
	}
}

void run(int s)
{
	for (auto to : G[s]) {
		if (!del[to]) {
			dfs2(to, s, 1);
			for (int i = 0; i < cntt; ++i) {
				lens[temp[i]]++; //遍历完一个子树后，更新距离的数目，为下面的遍历打好基础
			}
			cntt = 0;
		}
	}
	fill(lens, lens + MAXK, 0); //更换根节点时也要变换lens数组
	//统计不经过根节点的答案
	del[s] = 1;
	for (auto to : G[s]) {  
		if (!del[to]) {
			n = sz[to];  
			ctr = -1;  
			dfs(to);
			run(ctr);
		}
	}
}

int solve()
{
	ctr = -1;
	dfs(1);
	run(ctr);
	return cnt;
}

int main()
{
	cin >> n >> k;
	for (int i = 1; i < n; i++) {
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	cout << solve() << '\n';
	return 0;
}
~~~

