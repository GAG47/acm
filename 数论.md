# 快速幂

用正常的方式来计算幂，时间复杂度为 $O(n)$，这样显然浪费了cpu的算力。因而可以高效地用**二分**的方法来算：
$$
a[n]=
\begin{cases}
a[n/2]*a[n/2] (n=2*k)\\
a[(n+1)/2]*a[(n-1)/2](n=2*k+1)\\
1 (n=1)
\end{cases}
$$
**递归写法**

~~~c++
int qpow(int a,int n)
{
    if (n==0) return 1;
    else if(n%2==1) return qpow(a,n-1)*a;
    else{
        int temp=qpow(a,n/2);  //不能将函数写两次，否则时间复杂度会退化到 O(n)
        return temp * temp;
    }
}
~~~

**非递归写法**

~~~c++
int qpow(int a,int n)
{
    int ans=1;
    while(n){
        if (n&1) ans*=a;
        a*=a;
        n>>=1;
    }
    return ans;
}
~~~

将 $n$ 用二进制表示，如果 $(n)2$ 的最后一位是一，则代表答案要乘上这一位。

每次循环a自乘一保证每次ans可以正确表示进制。

## 矩阵快速幂

[【模板】矩阵快速幂 - 洛谷](https://www.luogu.com.cn/problem/P3390)
给定 $n*n$ 的矩阵 $A$ ，求 $A^k$。

~~~c++
~~~



# 素数筛

## 埃氏筛

埃氏筛是一种 $O(nloglogn)$ 的算法，基本思路就是每遍历到一个新质数，就标记它的所有在 $n$ 范围内的合数。

~~~c++
int n,prime[MAXN],cnt=0;
bool notprime[MAXN];
void get_prime()
{
	for(int i=2;i<=n;++i){
		if(!notprime[i]) prime[++cnt]=i;
		for(int j=i*2;j<=n;j+=i)
			notprime[j]=true;
	}
}
~~~

---

## 欧拉筛

埃氏筛时间复杂度不是完全线性的原因在于其在标记合数的时候，会有一个合数被**多次标记**。
我们在埃氏筛的基础上保证每一个合数只能被其**最小质因数**和另一个数的乘积标记，以排除多次标记的情况，时间复杂度可以优化到 $O(n)$。

~~~c++
int n,prime[MAXN],cnt=0;
bool notprime[MAXN];
void get_prime()
{
	for(int i=2;i<=n;++i){
		if(!notprime[i]) prime[++cnt]=i;
		for(int j=1;1ll*prime[j]*i<=n;++j){
			notprime[prime[j]*i]=true;
			if(i%prime[j]==0) break;  //i是prime[j]的倍数，则退出
            						//假设不退出，prime[j+1]更新的合数的最质因数就是prime[j]
            						//而并非prime[j+1],这样子便会导致重复更新，故此时就退出循环
		}
	}
}
~~~

### 欧拉函数

**$1$~$n$ 中与 $n$ 互质的个数**被称为欧拉函数,一般用 $φ(n)$ 表示

- $φ(1)=1$。
- 若 $p$ 是质数，则 $φ(p) = p-1$。
- 若 $p$ 是质数，则 $φ(p^k)=(p-1)p^{k-1}$
- 积性函数: 若 $gcd(n,m)=1$ ，则 $φ(mn)=φ(n)φ(m)$

>证明：

所以通过**唯一分解定理** $n=\prod_{i=1}^{s}p_i^{α_i}...p_s^{α_s}$ 来得到 $φ(n)$。具体过程为：先使用性质③，在使用性质②，再用一次唯一分解定理，然后即可得到结果为 $n\times\frac{p_1-1}{p_1}\times...\times\frac{p_s-1}{p_s}$。说明欧拉函数仅由 $n$ 和质因数有关，与质因子的次数无关。

求解一个数字的欧拉函数，可以通过试除法。也可以通过**筛法**来在线性时间内求解一段区间内的数字的欧拉函数。
我们用欧拉筛的原理来求每一个数字的欧拉函数：
① 假如选取数字是素数，则 $\phi(x) = x-1$；
②在素数标记合数的过程中，假如 $i$ 不是 $p_j$ 的倍数，说明这两个数字**互质**，则 $\phi(i*p_j)=\phi(i)*\phi(p_j)$，由于 $\phi(i)$ 之前已经被求解出来了，因而可以递推求出；
③ 假如 $i$ 是 $p_j$ 的**倍数**，则 $i$ 有 $m$ 有的所有素数，则可以得到递推关系 $\phi(m) = m\times\frac{p_1-1}{p_1}\times...\times\frac{p_s-1}{p_s}=p_j\times i\times\frac{p_1-1}{p_1}\times...\times\frac{p_s-1}{p_s}=p_j\times \phi(i)$ 。

~~~c++
int n,phi[MAXN],prime[MAXN],cnt=0;
bool notprime[MAXN];
void get_phi()
{
	for(int i=2;i<=n;++i){
		if(!notprime[i]){
			prime[++cnt]=i;
			phi[i]=i-1;
		}
		for(int j=1;1ll*i*prime[j]<=n;++j){
			ll temp=i*prime[j];
			notprime[temp]=1;
			if(i%prime[j]==0){
				phi[temp]=prime[j]*phi[i];
				break;
			}
			phi[temp]=(prime[j]-1)*phi[i];
		}
	}
}
~~~

### 约数个数















