待解决：
[P4180 [BJWC2010\] 严格次小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4180)

[CUGBACM22级暑假专题训练#3 最小生成树 - Virtual Judge (vjudge.net)](https://vjudge.net/contest/636310#problem/I) 想法证明

[Dashboard - Codeforces Round 949 (Div. 2) - Codeforces](https://codeforces.com/contest/1981) 图论题



### 1.[构造新矩阵（二分）](https://www.acwing.com/problem/content/4866/)

$题目$

>给定一个 $$m$$ 行 $$n$$ 列的整数矩阵，行编号 $$1∼m$$，列编号 $$1∼n$$。
>
>其中，第 $$ i $$ 行第 $$ j $$ 列的元素为 $$p_{ij}$$。
>
>你可以任意抽取其中不超过 $$n−1$$ 行元素，这些元素之间保持同一行列关系不变，构成一个新矩阵。
>
>构成新矩阵后，我们可以确定一个最大的整数 $$L$$，使得新矩阵中每一列都至少存在一个元素不小于 $$L$$。
>
>我们希望通过合理构造新矩阵，使得 $$L$$ 的值尽可能大。
>
>请你计算并输出 $$L$$ 的最大可能值。
>
>**注意：矩阵一共有 $$m$$ 行，但是抽取的行数上限是 $$n−1$$ 行，而不是 $$m−1$$ 行，读题时不要搞混行和列。**
>
>#### 输入格式
>
>第一行包含整数 $$T$$，表示共有 $$T$$ 组测试数据。
>
>每组数据首先包含一个空行。
>
>第二行包含两个整数 $$m, n$$。
>
>接下来 $$m$$ 行，每行包含 $$n$$ 个整数，其中第 $$i$$ 行第 $$j$$ 个整数表示 $$p_{ij}$$。
>
>#### 输出格式
>
>每组数据输出一行结果，一个整数，表示 $$L$$ 的最大可能值。
>
>#### 数据范围
>
>前三个测试点满足 $$1≤T≤5$$，$$2≤n×m≤10^5$$。
>所有测试点满足 $$1≤T≤10^4$$，$$2≤n$$，$$2≤n×m≤10^5$$，$$1≤p_{ij}≤10^9$$，一个测试点内所有数据的 $$n×m$$ 值相加不超过 $$10^5$$。
>
>#### 输入样例1：
>
>```
>5
>
>2 2
>1 2
>3 4
>
>4 3
>1 3 1
>3 1 1
>1 2 2
>1 1 3
>
>2 3
>5 3 4
>2 5 1
>
>4 2
>7 9
>8 1
>9 6
>10 8
>
>2 4
>6 5 2 1
>7 9 7 2
>```
>
>#### 输出样例：
>
>```
>3
>2
>4
>8
>2
>```

解题思路：

首先分析题干，题目给出$$T$$个矩阵，其中在矩阵中选出列数减一的行数使得每一列都有数大于$$L$$，求最大的L。因为直接求出$$L$$是比较困难的，因而可以先猜测L的值再进行判断，故采用**二分**。

沿用一般二分的思路，先寻找二分的**最小值**和**最大值**。由题，$1≤p_{ij}≤10^9$ ，故最小值为1，最大值为 $10^9$ 。

然后确定**判断条件**。在 $m$ 行中取 $n-1$ 行使得取得的部分每一列都有元素大于等于$L$，可以推得原矩阵中每一列都应有数字大于等于 $L$。如果条件是取 $n$ 行，则只需要满足前面那个条件即可，但是条件为取 $n-1$ 行，则根据**抽屉原理**，必须要有一行中有两个元素大于 $L$ 。

再判断**时间复杂度**。其中，二分复杂度为 $O(\lg n)$ ,即 $O(30)$ 。再来判断条件部分，条件部分为遍历矩阵，因为一个测试点内所有数据的 $$n×m$$ 值相加不超过 $$10^5$$，所以时间复杂度为 $O(10^5)$ 。则总的时间复杂度为 $O(3*10^6)$ ，显然不会超时。

代码部分：

~~~c++
#include <iostream>
#include <vector>
#include <string.h>
#include <string>
using namespace std;
const int N = 1e5 + 10;

int T, n, m;
vector <int> G[N]; //显然用数组会爆内存
bool st[N]; //记录每一行是否有两个大于L得元素

bool C(int s)
{
    for (int i = 1; i <= m; i++) st[i] = 0;
	bool boo = false;  //判断是否行有两个元素大于L
	for (int i = 1; i <= n; i++) {
		bool succee = false;
		for (int j = 1; j <= m; j++) {
			if (G[j][i] >= s) {
				succee = true;
				if (st[j]) boo = true;
				st[j] = true;
			}
		}
		if (!succee) return false;
	}
	return boo;
}

int main()
{
	cin >> T;
	while (T--) {
		cin >> m >> n;
		for (int i = 1; i <= m; i++) {
			G[i].resize(n + 1);
			for (int j = 1; j <= n; j++) cin >> G[i][j];
		}
		int l = 1, r = 1e9;
		while (l < r) {
			int mid = (l + r + 1) / 2;
			if (C(mid)) l = mid;  //如果mid成立，不能代表mid+1成立
			else r = mid - 1;
		}
		cout << r << "\n";
	}
	return 0;
}
~~~









### 2.[加减乘（dp 数学）](https://www.acwing.com/problem/content/4808/)

>规定两种数字操作：
>
>- 加减操作，将数字加 $1$ 或减 1，代价为 $x$。
>- 乘法操作，将数字乘 $2$，代价为 $y$。
>
>每种操作的使用次数不限。
>
>请你计算，通过上述操作，将 $0$ 变为 $n$，所需花费的最小代价。
>
>#### 输入格式
>
>共一行，包含三个整数 $n,x,y$。
>
>#### 输出格式
>
>一个整数，表示最小代价。
>
>#### 数据范围
>
>前 $5$ 个测试点满足 $1≤n≤100$。
>所有测试点满足 $1≤n≤10^7$，$1≤x,y≤10^9$。
>
>#### 输入样例1：
>
>```
>8 1 1
>```
>
>#### 输出样例1：
>
>```
>4
>```
>
>#### 输入样例2：
>
>```
>8 1 10
>```
>
>#### 输出样例2：
>
>```
>8
>```

解题思路：

首先分析题目，求从0到n的最小花费，其中 $+，-$ 代价为 $x$， $*$ 代价为y，容易想到用**dp**来做。则dp的初始化为 $dp[0]=0$ ，终止条件为循环到n时结束。 因为代价可能溢出，故dp数组需开 long long，则空间复杂度为 $8*10^7 B$ ，不会爆TLE。

接下来分析较难的**dp递推关系**。首先分析操作中的一些限制条件：

1.加法和减法不可能相邻发生。显而易见，加法和减法互为逆运算，如果同时发生，只会使代价无效变大。

2.加法也不能相邻发生（逆推）。分析：

   1）当 $i$ 为偶数，如果加法相邻发生 $2k$ 次再进行除法，则代价为$2kx + y$，得到数字 $(n+2k)/2$。而如果先进行除法操作，再进行加法操作，则代价只要 $kx+y$  即可得到同样数字。

   2）当 $i$ 为奇数，加法进行 $2k+1$ 次，则代价为 $(2k+1)x+y$，得到数字 $(n+2k+1)/2$。而加一次就进行除法操作，则代价只要 $(k+1)x+y$。

很明显，x，y均为非负整数，则该假设成立。得到这两点推论性质后，即可推到dp递推关系。

1）当 $i$ 为偶数，

- $dp[i/2]+y$
- $dp[i-1]+x$

2）当 $i$ 为奇数

- $dp[i+1/2]+x+y$
- $dp[i-1]+x$

在上面四种情况选择代价最小的dp即可，时间复杂度为 $O(n)$，显然不会超时。

代码实现

~~~c++
#include <iostream>
using namespace std;
#define ll long long
const int MAXN=1e7+10;
const long long INF=1e15;

int n,x,y;
ll dp[MAXN];

int main()
{
    cin>>n>>x>>y;
    for (int i=1;i<=n;i++) dp[i]=INF;
    for (int i=1;i<=n;i++){
        if (i%2==1){
            dp[i]=min(dp[i],dp[(i+1)/2]+x+y);
            dp[i]=min(dp[i],dp[i-1]+x);
        }
        else{
            dp[i]=min(dp[i],dp[i/2]+y);
            dp[i]=min(dp[i],dp[i-1]+x);
        }
    }
    cout<<dp[n];
    return 0;
}
~~~





[4801. 强连通图](https://www.acwing.com/problem/content/4804/)





[4786. 闯关](https://www.acwing.com/problem/content/4789/)

如果输出一个内存超过int的数，不要输出式子，先赋值到一个long long大小的变量上在输出。否则会用科学计数法表示导致窄化。





### [3.删除序列 ](https://www.acwing.com/problem/content/4799/)

dp的推到关系再做一次。





### [4.构造序列（构造） ](https://www.acwing.com/problem/content/4790/)

>对于一个长度为 $n$ 的正整数序列 $a_1,a_2,…,a_n$ 我们这样规定该序列的价值：
>
>- 如果 $n$ 为偶数，则序列价值为 $gcd(a_1,a_2)+gcd(a_3,a_4)+…+gcd(a_{n−1},a_n)$。
>- 如果 $n$ 为奇数，则序列价值为 $gcd(a_1,a_2)+gcd(a_3,a_4)+…+gcd(a_{n−2},a_{n−1})$。
>
>请你构造一个长度为 $n$ 的正整数序列 $a_1,a_2,…,a_n$，要求：
>
>1. $a_i$ 两两不同。
>2. $1≤a_i≤10^9$。
>3. 序列价值恰好为 $m$。
>
>#### 输入格式
>
>共一行，两个整数 $n,m$。
>
>#### 输出格式
>
>共一行，如果序列不存在，则输出 `-1`，否则输出 $a_1,a_2,…,a_n$。
>
>如果答案不唯一，输出任意合理答案均可。
>
>#### 数据范围
>
>前 $7$ 个测试点满足 $1≤n≤10$。
>所有测试点满足 $1≤n≤10^5$，$0≤m≤10^8$。
>
>#### 输入样例1：
>
>```
>5 2
>```
>
>#### 输出样例1：
>
>```
>1 2 3 4 5
>```
>
>#### 输入样例2：
>
>```
>5 3
>```
>
>#### 输出样例2：
>
>```
>2 4 3 7 1
>```
>
>#### 输入样例3：
>
>```
>7 2
>```
>
>#### 输出样例3：
>
>```
>-1
>```

解题思路：

构造题，一般先考虑**特殊情况**：

当 $a_i != 1$ 而且 $a_{i+1} = a_i+1$ 时，$gcd(a_i,a_{i+1})=1$，那么一个元素为 $gcd(d,2d)=d$，那么只需要 $n - 2$ 与 $d$ 相加为 $m$ 即可。



[4781. 卡牌 - AcWing题库](https://www.acwing.com/problem/content/4784/)

### 5.[Well-defined Path Queries on a Namori（数学）](https://vjudge.net/problem/AtCoder-abc266_f)

># [ABC266F] Well-defined Path Queries on a Namori
>
>## 题面翻译
>
>### 题目描述
>
>给定一张有 $N$ 个点、$N$ 条边的简单连通无向图和 $Q$ 次询问，对于每次询问，给定 $x_i,y_i$，表示两点的编号，请你回答第 $x_i$ 个点和第 $y_i$ 个点之间是否**有且仅有**一条简单路径。
>
>+ 什么是简单路径？
>
>如果路径上的各顶点均不重复，则称这样的路径为简单路径。
>
>### 输入格式
>
>第一行包含一个整数 $N$；
>
>接下来 $N$ 行，每行两个整数 $u_i,v_i$，表示第 $i$ 条边连接的两个点；
>
>再接下来一行包含一个整数 $Q$；
>
>最后 $Q$ 行，每行两个整数 $x_i,y_i$，含义见题目描述。
>
>### 输出格式
>
>对于每次询问，输出一个字符串 `Yes` 或 `No`，分别表示两点之间是否仅存在一条简单路径，每个询问分别输出一行。
>
>### 样例
>
>见原题面。
>
>### 样例解析
>
>样例 #1 解析：
>
>对于第一次询问，从 $1$ 到 $2$ 有两条简单路径 $(1,2)$、$(1,3,2)$，所以输出 `No`。
>
>对于第二次询问，从 $1$ 到 $4$ 仅有一条路径 $(1,4)$，所以输出 `Yes`。
>
>对于第三次询问，从 $1$ 到 $5$ 有两条简单路径 $(1,2,5)$、$(1,3,2,5)$，所以输出 `No`。
>
>### 数据范围
>
>对于 $30\%$ 的数据，$N \le 100$，$Q \le \frac{N(N-1)}{2}$；
>
>对于 $100\%$ 的数据，$3 \le N \le 2 \times 10^5$，$1 \le u_i<v_i \le N$，$1 \le Q \le 2 \times 10^5$，$1 \le x_i < y_i \le N$，保证图没有重边或自环，且给定询问均不重复。
>
>翻译 by @CarroT1212
>
>## 题目描述
>
>[problemUrl]: https://atcoder.jp/contests/abc266/tasks/abc266_f
>
>頂点に $ 1 $ から $ N $ の番号がついた $ N $ 頂点 $ N $ 辺の連結な単純無向グラフ $ G $ が与えられます。$ i $ 番目の辺は頂点 $ u_i $ と頂点 $ v_i $ を双方向に結んでいます。
>
>以下の $ Q $ 個のクエリに答えてください。
>
>- 頂点 $ x_i $ から頂点 $ y_i $ に向かう単純パス（同じ頂点を $ 2 $ 度通らないパス）が一意に定まるか判定せよ。
>
>## 输入格式
>
>入力は以下の形式で標準入力から与えられる。
>
>> $ N $ $ u_1 $ $ v_1 $ $ u_2 $ $ v_2 $ $ \vdots $ $ u_N $ $ v_N $ $ Q $ $ x_1 $ $ y_1 $ $ x_2 $ $ y_2 $ $ \vdots $ $ x_Q $ $ y_Q $
>
>## 输出格式
>
>$ Q $ 行出力せよ。
>
>$ i\ (1\ \leq\ i\ \leq\ Q) $ 行目には、頂点 $ x_i $ から頂点 $ y_i $ に向かう単純パスが一意に定まる場合 `Yes`、そうでない場合 `No` を出力せよ。
>
>## 样例 #1
>
>### 样例输入 #1
>
>```
>5
>1 2
>2 3
>1 3
>1 4
>2 5
>3
>1 2
>1 4
>1 5
>```
>
>### 样例输出 #1
>
>```
>No
>Yes
>No
>```
>
>## 样例 #2
>
>### 样例输入 #2
>
>```
>10
>3 5
>5 7
>4 8
>2 9
>1 2
>7 9
>1 6
>4 10
>2 5
>2 10
>10
>1 8
>6 9
>8 10
>6 8
>3 10
>3 9
>1 10
>5 8
>1 10
>7 8
>```
>
>### 样例输出 #2
>
>```
>Yes
>No
>Yes
>Yes
>No
>No
>Yes
>No
>Yes
>No
>```
>
>## 提示
>
>### 制約
>
>- $ 3\ \leq\ N\ \leq\ 2\ \times\ 10^5 $
>- $ 1\ \leq\ u_i\ <\ v_i\leq\ N $
>- $ i\ \neq\ j $ ならば $ (u_i,v_i)\ \neq\ (u_j,v_j) $
>- $ G $ は $ N $ 頂点 $ N $ 辺の連結な単純無向グラフ
>- $ 1\ \leq\ Q\ \leq\ 2\ \times\ 10^5 $
>- $ 1\ \leq\ x_i\ <\ y_i\leq\ N $
>- 入力は全て整数
>
>### Sample Explanation 1
>
>頂点 $ 1 $ から $ 2 $ に向かう単純パスは $ (1,2),(1,3,2) $ と一意に定まらないので、 $ 1 $ 個目のクエリの答えは `No` です。 頂点 $ 1 $ から $ 4 $ に向かう単純パスは $ (1,4) $ と一意に定まるので、$ 2 $ 個目のクエリの答えは `Yes` です。 頂点 $ 1 $ から $ 5 $ に向かう単純パスは $ (1,2,5),(1,3,2,5) $ と一意に定まらないので、$ 3 $ 個目のクエリの答えは `No` です。

解题思路：

根据题意可知，如果两个所选点之间有经过环或者两个点有点在环上，显然简单路径就会不止一条。

![image-20230302215327930](C:\Users\滕俊宁\AppData\Roaming\Typora\typora-user-images\image-20230302215327930.png)

那么通过**拓扑排序**可以找到图中的环。然后以环上节点为根节点，跟新每个与这个根节点相连的节点的值/颜色，如果颜色值不同，则说明这两个节点之间会经过环，

![image-20230302215734120](C:\Users\滕俊宁\AppData\Roaming\Typora\typora-user-images\image-20230302215734120.png)

**环基树**的思想。

代码实现：

~~~c++
#include <iostream>
#include <queue>
using namespace std;
const int N = 2e6;

struct edge {
	int to, next;
}edge[N];
int head[N], cnt = 0;
int n, m, Q;
int vis[N], in[N], col_num, col[N];
//vis为false则说明该点不是环节点
//col[]为每个节点的颜色值。

void topo_sort()//朴实无华的拓扑排序~
{
	queue <int> que;
	for (int i = 1; i <= n; i++) {
		if (in[i] == 1) que.push(i);
	}
	while (!que.empty()) {
		int u = que.front(); que.pop();
		vis[u] = true;
		for (int i = head[u]; i; i = edge[i].next) {
			int to = edge[i].to;
			if (vis[to]) continue;
			in[to]--;
			if (in[to] == 1) que.push(to);
		}
	}
	return;
}

inline void add(int from, int to)//链式前向星基本增加操作
{
	edge[++cnt].to = to;
	edge[cnt].next = head[from];
	head[from] = cnt;
}

void col_dfs(int s)
{
	col[s] = col_num;
	for (int i = head[s]; i; i = edge[i].next) {
		int to = edge[i].to;
		if (!vis[to]||col[to]) continue;  //如果该点已经标记过颜色或者是环节点，则不进行遍历
		col_dfs(to);
	}
}

int main()
{
	cin >> m;
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		add(u, v);
		add(v, u); //链式前向星存图，之前都不会awa
		in[u]++, in[v]++; 
		n=max(max(u,v),n); //n在这里居然是不知道的，巨坑
	}
    //for (int i=1;i<=n;i++) cout<<in[i]<<" ";
	topo_sort();
	for (int i = 1; i <= n; i++) {
		if (vis[i]) continue;
		col_num++;
		col_dfs(i);
	}
	cin >> Q;
	for (int i = 1; i <= Q; i++) {
		int u, v;
		cin >> u >> v;
		if (col[u] == col[v]) cout << "Yes" <<"\n";
		else cout << "No" <<'\n';
	}
	return 0;
}
~~~





[Colorful Stamp](https://www.luogu.com.cn/problem/CF1669D)

[Eating Candies](https://www.luogu.com.cn/problem/CF1669F)







### 6.[LIS or Reverse LIS? ](https://www.luogu.com.cn/problem/CF1682C)

># LIS or Reverse LIS?
>
>## 题面翻译
>
>设一个长为 $n$ 的整数序列 $a$ 是 $\{a_1,a_2,a_3,\cdots,a_n\}$，那么 $a'$ 表示 $\{a_n,a_{n-1},a_{n-2},\cdots,a_1\}$，$\operatorname{LIS}(a)$ 表示 $a$ 的最长严格上升子序列的长度。
>
>现在给定 $a$ 数组，请你将 $a$ 数组重新排列，使得重排后的 $\min(\operatorname{LIS}(a),\operatorname{LIS}(a'))$ 最大。
>
>输入 $t$ 组数据，每组数据先输入 $n$ ，然后输入 $n$ 个整数，所有 $n$ 之和不超过 $2 \times 10^5$。
>
>输出 $t$ 行，每行一组数据的答案，按输入顺序输出。
>
>## 题目描述
>
>You are given an array $ a $ of $ n $ positive integers.
>
>Let $ \text{LIS}(a) $ denote the length of [longest strictly increasing subsequence](https://en.wikipedia.org/wiki/Longest_increasing_subsequence) of $ a $ . For example,
>
>- $ \text{LIS}([2, \underline{1}, 1, \underline{3}]) $ = $ 2 $ .
>- $ \text{LIS}([\underline{3}, \underline{5}, \underline{10}, \underline{20}]) $ = $ 4 $ .
>- $ \text{LIS}([3, \underline{1}, \underline{2}, \underline{4}]) $ = $ 3 $ .
>
>We define array $ a' $ as the array obtained after reversing the array $ a $ i.e. $ a' = [a_n, a_{n-1}, \ldots , a_1] $ .
>
>The beauty of array $ a $ is defined as $ min(\text{LIS}(a),\text{LIS}(a')) $ .
>
>Your task is to determine the maximum possible beauty of the array $ a $ if you can rearrange the array $ a $ arbitrarily.
>
>## 输入格式
>
>The input consists of multiple test cases. The first line contains a single integer $ t $ $ (1 \leq t \leq 10^4) $ — the number of test cases. Description of the test cases follows.
>
>The first line of each test case contains a single integer $ n $ $ (1 \leq n \leq 2\cdot 10^5) $ — the length of array $ a $ .
>
>The second line of each test case contains $ n $ integers $ a_1,a_2, \ldots ,a_n $ $ (1 \leq a_i \leq 10^9) $ — the elements of the array $ a $ .
>
>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot 10^5 $ .
>
>## 输出格式
>
>For each test case, output a single integer — the maximum possible beauty of $ a $ after rearranging its elements arbitrarily.
>
>## 样例 #1
>
>### 样例输入 #1
>
>```
>3
>3
>6 6 6
>6
>2 5 4 5 2 4
>4
>1 3 2 2
>```
>
>### 样例输出 #1
>
>```
>1
>3
>2
>```
>
>## 提示
>
>In the first test case, $ a $ = $ [6, 6, 6] $ and $ a' $ = $ [6, 6, 6] $ . $ \text{LIS}(a) = \text{LIS}(a') $ = $ 1 $ . Hence the beauty is $ min(1, 1) = 1 $ .
>
>In the second test case, $ a $ can be rearranged to $ [2, 5, 4, 5, 4, 2] $ . Then $ a' $ = $ [2, 4, 5, 4, 5, 2] $ . $ \text{LIS}(a) = \text{LIS}(a') = 3 $ . Hence the beauty is $ 3 $ and it can be shown that this is the maximum possible beauty.
>
>In the third test case, $ a $ can be rearranged to $ [1, 2, 3, 2] $ . Then $ a' $ = $ [2, 3, 2, 1] $ . $ \text{LIS}(a) = 3 $ , $ \text{LIS}(a') = 2 $ . Hence the beauty is $ min(3, 2) = 2 $ and it can be shown that $ 2 $ is the maximum possible beauty.、



这道题主要是一道思维题目。我们发现，如果有一个数字出现了**三次及以上**，那么第三次及更多次出现的数字对于队列的构造是**无效**的。那么在输出数组时，统计每个数字出现的次数，若不大于2次则有效数列的长度。最后将有效长度除以二即可。

**需要注意的点**：单调子序列可以不连续，这样便不需要分奇偶讨论。

~~~c++
#include <iostream>
#include <map>
using namespace std;

int t, n, a;
map <int, int> vis;

int main()
{
	cin >> t;
	while (t--) {
		cin >> n;
		int ans = 0;
		vis.clear();
		for (int i = 1; i <= n; i++) {
			cin >> a;
			vis[a]++;
			if (vis[a] <= 2) ans++;
		}
		cout << (ans + 1) / 2 << '\n';
	}
	return 0;
}
~~~



[Couple number](https://www.luogu.com.cn/problem/P1348)



[P1827 [USACO3.4\] 美国血统 American Heritage - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P1827)

为什么将前序遍历和中序遍历互换就会导致内存溢出？因为可能find找不到对应的值 输出-1 导致溢出。



[P2420 让我们异或吧 ](https://www.luogu.com.cn/problem/P2420)

完全的TLE，LCA大失败！



[校园网Network of Schools](https://www.luogu.com.cn/problem/P2746)

在考虑加多少边使得一个图变为强连通图的题目中，注意考虑 $cscc = 1$ 的情况，此时 $in[i] ==0$ 与 $out[i] == 0$ 的情况都是 $1$，但是已经没有必要**再增加边数**。



### 6.[判断等腰三角形（二分）](https://ac.nowcoder.com/acm/contest/52441/F)

>
>
>## 题目描述                    
>
>给定 nnn 个坐标，求其中 333 个坐标能表示一个等腰三角形的组数。
>
>三点共线不算三角形，等边三角形为特殊的等腰三角形。
>
>## 输入描述:
>
>```
>第一行一个整数 n(0≤n≤3000)n(0\le n\le3000)n(0≤n≤3000)。
>其后 nnn 行每行两个整数 xi,yi(−500≤xi,yi≤500)x_i,y_i(-500 \le x_i,y_i \le 500)xi,yi(−500≤xi,yi≤500)，保证没有重复坐标。
>```
>
>## 输出描述:
>
>```
>一行一个整数答案。
>```
>
> 示例1                        
>
>## 输入
>
>```
>4
>1 1
>-1 1
>-1 -1
>1 -1
>```
>
>## 输出
>
>```
>4
>```
>







## 春季训练16A

**A:** [图的遍历](https://vjudge.net/problem/洛谷-P3916)

这道题需要**反向建边**，然后**倒序**遍历。

如果正序遍历，可能会出现某个较小点A还未更新到最大值时，另一个较大的值B就因为这个较小的值的遍历搜索而更新，接下来这个较大的值B的跟新就不会进行。

~~~C++
4 4
1 2
2 4
4 3
3 1
~~~

**B:** 比较简单的题目，用dfs即可。

**C：**送分题,判断是否有 $a[i]$ 满足 $<=i$ 即可.

**D：**送分题,保证每次逆序操作后得到的数是奇数即可,则选择相邻的不是4的倍数的偶数.

**E:**





## abc_291:

***D:** 给出 $N$ 张牌，每张排正反面写着两个数字，每张牌可以翻面，需要保证每个相邻的牌正面数字不同，请问总共有几种翻牌方案（已知不翻也是一种方案）。

考虑使用**dp**，动态地推出每个牌正面朝上和反面朝上的状态方案数。

~~~c++
N
		if (b[i] != b[i - 1]) {
			dp[i][1] = (dp[i][1] + dp[i - 1][1]) % mode;
		}
	};
	cout << (dp[n][0] + dp[n][1]) % mode << '\n';
	return 0;
}
~~~

**E：** 已知一个长度为 $N$ 的排列，并给出 $M$ 对关系，其中关系描述的是某个位置的数字比另一个位置的数字小。求排列是否唯一确定。

大致思路：**理解成图**。将关系看成路，那么就可以得到一个有向图。如果排列唯一确定，那么即每个节点都有**唯一的拓扑序**。

做题的时候是考虑先保证图是联通的，然后再从入度为0的节点开始，保证每次都只更新一个数字。（不过大差不差。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e5 + 100;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n, m, indep[MAXN], outdep[MAXN], u, v, sum[MAXN];
vector <int> G[MAXN];
bool flag = true;

void topo(int s)
{
	int cnt = 0, pmt = 0;
	queue <int> que;
	que.push(s);
	while (!que.empty()) {
		int q = que.front();
		que.pop();
		pmt = 0;
		sum[q] = ++cnt;
		for (auto to : G[q]) {
			indep[to]--;
			if (indep[to] == 0) {
				que.push(to);
				pmt++;
			}
		}
		if (pmt >= 2) flag = false;
	}
	return;
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; ++i) {
		cin >> u >> v;
		G[u].push_back(v);
		indep[v]++;
		outdep[u]++;
	}
	u = v = 0;
	for (int i = 1; i <= n; ++i) {
		if (indep[i] == 0) {
			if (u != 0) flag = false;
			u = i;
		}
		if (outdep[i] == 0) {
			if (v != 0) flag = false;
			v = i;
		}
	}
	if (!flag) {
		cout << "No";
	}
	else {
		flag = true;
		topo(u);
		if (!flag) {
			cout << "No";
		}
		else {
			cout << "Yes\n";
			for (int i = 1; i <= n; ++i) {
				cout << sum[i] << " ";
			}
		}
	}
	return 0;
}
~~~

***F:** 给出一个有向无环图，且每个节点只能有指向 $[i+1,i+m]$ 的边。求挖掉某个点，$1$ 

到 $n$ 的最短路是多少，如果不连通则输出-1。

大致思路：跑两遍最短路算法，求出每个点到 $1$ 和 $n$ 的最短路。然后遍历边，复杂度为$O(mmn)$

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 1e5 + 100;
const int INF = 1e6;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n, m, d[MAXN], _d[MAXN];
vector <int> G[MAXN], _G[MAXN];

void dijiesitela(int s)
{
	fill(d + 1, d + n + 1, INF);
	priority_queue <P, vector <P>, greater <P>> que;
	que.push(P(0, s));
	d[s] = 0;
	while (!que.empty()) {
		P p = que.top();
		que.pop();
		int u = p.second;
		if (d[u] < p.first) continue;
		for (auto to : G[u]) {
			if (d[to] > d[u] + 1) {
				d[to] = d[u] + 1;
				que.push(P(d[to], to));
			}
		}
	}
	return;
}

void _dijiesitela(int s)
{
	fill(_d + 1, _d + n + 1, INF);
	priority_queue <P, vector <P>, greater <P>> que;
	que.push(P(0, s));
	_d[s] = 0;
	while (!que.empty()) {
		P p = que.top();
		que.pop();
		int u = p.second;
		if (_d[u] < p.first) continue;
		for (auto to : _G[u]) {
			if (_d[to] > _d[u] + 1) {
				_d[to] = _d[u] + 1;
				que.push(P(_d[to], to));
			}
		}
	}
	return;
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; ++i) {
		string str;
		cin >> str;
		for (int j = 0; j < m; ++j) {
			if (str[j] == '1') {
				G[i].push_back(j + i + 1);
				_G[j + i + 1].push_back(i);
			}
		}
	}
	dijiesitela(1);
	_dijiesitela(n);
	for (int k = 2; k < n; ++k) {
		int ans = INF;
		for (int i = k - m + 1; i <= k - 1; ++i) {
			for (auto j : G[i]) {
				if (j > k) ans = min(d[i] + _d[j] + 1, ans);
			}
		}
		if (ans == INF) cout << "-1 ";
		else cout << ans << " ";
	}
	return 0;
}
~~~









## abc_292:

感觉真的非常简单啊。

**A：**遍历将小写字母转化为大写的即可。

**B:**一个模拟题。有 $n$ 个球员比赛，$m$ 个事件，事件分为三种：给某个球员黄牌或者红牌，查看某个球员是否被罚下场。那么只要将黄牌看为1，红牌看为2，判断的时候判断每个球员的犯规值是否达到2即可。

**C：**给定一个正整数 $N$ ，求可能的四个数的次数使得 $A*B+C*D=N$. 那么只需要将 N 先拆成两个数相加的形式，然后再求这两个数分别可以写成几种两个数相乘的形式即可。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 1e6 + 10;
const int INF = 0x7fffffff;
typedef long long ll;
typedef pair<int, int> P;

ll n, sum;

ll check(ll s)
{
	bool flag = false;
	ll ans = 0;
	if (s == 1) return 1;
	else {
		for (int i = 1; i * i <= s; i++) {
			if (s % i == 0) ans++;
			if (s == i * i) flag=true;
		}
	}
	ans = ans * 2;
	if (flag) ans--;
	return ans;
}

int main()
{
	cin >> n;
	for (int i = 1; i < n; i++){
		sum += check(i) * check(n - i);
		//cout<<i<<" "<<check(i) << " " << check(n - i)<<'\n';
	}
	cout<<sum;
	return 0;
}
~~~

**D:** 给出一个无向图，判断这个图连通块的点和边数是否相等。

那么只需要用dfs遍历每一个连通块，分别统计遍历的连通块**的点数**以及点的**度数**，如果点数 $！=$ 度数 * 2，则说明不相等。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 0x7fffffff;
typedef long long ll;
typedef pair<int, int> P;

int n, m, indep[MAXN], vis[MAXN];
vector <int> G[MAXN];
int sum = 0;

int dfs(int s)
{
	if (vis[s]) return 0;
	vis[s] = 1;
	sum++;
	int d = indep[s];
	for (auto q : G[s]) {
		if (!vis[q]) d += dfs(q);
	}
	return d;
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
		indep[u]++;
		indep[v]++;
	}
	for (int i = 1; i <= n; i++) {
		sum = 0;
		if (!vis[i]) {
			if (dfs(i) != sum * 2) {
				cout << "No";
				return 0;
			}
		}
	}
	cout << "Yes";
	return 0;
}
~~~

**E:** 题目大意：给出一个有向图，求每个点间接能达到的点的个数。

那么对每个点进行bfs即可。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e3 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n, m, u, v, ans,vis[MAXN];
vector <int> G[MAXN];

void bfs(int s)
{
	memset(vis, 0, sizeof(vis));
	queue <int> que;
	vis[s] = 1;
//	cout<<s<<" ";//
	for (auto to : G[s]) {
		que.push(to);
		vis[to] = 1;
	}
	while (!que.empty()) {
		int u = que.front();
		que.pop();
	//	cout<<u<<" ";
		for (auto to : G[u]) {
			if(!vis[to]){
				que.push(to);
				vis[to] = 1;
				ans++;
			}
		}
	}
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; ++i) {
		cin >> u >> v;
		G[u].push_back(v);
	}
	for (int i = 1; i <= n; ++i) {
		bfs(i);
//		cout<<ans<<"\n";
	}
	cout << ans;
	return 0;
}
~~~

一开始想着用子树的大小来做啊，结果发现是有向图。

**F:** 数学题，求一个边长为 $n$ ，$m$ 的矩形中的最大等边三角形。首先，显然该三角形要有**两个点在矩形边上**，否则该三角形必然可以扩大直至满足前面那个条件。然后不妨以矩形的某点为原点建立直角坐标系，然后三角形一点在原点上，另一点设为在x轴上，令三角形边长为 $x$ ，则该点坐标为 $(x,0)$,根据转轮公式，求出另一点的坐标，只要保证该点在矩形内即可。





## abc_294

**D:** 请使用 **set** 吧，很方便的。

**E：**感觉很像分块？

基本思路：先按照题目愿意将第一行的数据输入结束，分别统计每一块的初始位置，某位置/长度，值大小。然后输入第二行的数据，统计一样的参数，并且使用**二分查找**第一行中起始位置恰好比现在的块起始位置小的部分，然后第一行的块不断后推直至完全离开现在的块的末位置，同时统计值的变化。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 0x7fffffff;
typedef long long ll;

struct node {
	ll l, val, len;
	friend bool cmp(node x, node y);
}a[MAXN],b[MAXN];
ll L, _l = 1, n1, n2;

bool cmp(node x, node y) {
	return x.l < y.l;
}

int main()
{
	ll ans = 0;
	cin >> L >> n1 >> n2;
	for (int i = 1; i <= n1; i++) {
		cin >> a[i].val >> a[i].len;
		a[i].l = _l;
		_l += a[i].len;
	}
	_l = 1;
	for (int i = 1; i <= n2; i++) {
		cin >> b[i].val >> b[i].len;
		b[i].l = _l;
		_l += b[i].len;
		int k = lower_bound(a + 1, a + n1 + 1, b[i], cmp) - a;
		cout<<k<<"\n";
		if (a[k].l != b[i].l) {  //为什么不能用小于，因为可能查找不到，指向n1+1的位置，a[n1+1].l大小不确定
			k--;
			//if (a[k].l < b[i].l) cout << "hhh\n"; 
		}
		cout<<k<<'\n';
		//cout << k <<"\n";
		while (a[k].l <= b[i].l + b[i].len - 1 && k <= n1) {
			if (a[k].val == b[i].val) {
				ans += min(a[k].l + a[k].len - 1, b[i].l + b[i].len - 1) - max(a[k].l, b[i].l) + 1;
				//cout << min(a[k].l + a[k].len - 1, b[i].l + b[i].len - 1) - max(a[k].l, b[i].l) + 1<< '\n';
				//cout << min(a[k].l + a[k].len - 1, b[i].l + b[i].len - 1) << " " << max(a[k].l, b[i].l) << "   1234\n";
				//cout << i << " " << k << "   123456\n";
			}
			k++;
		}
	}
	cout << ans;
	return 0;
}
~~~

***F：**基本思路：因为遍历所有可能的浓度值是不可能的，因而考虑直接**二分查找**第k位置的浓度值。

那么如何构造判断函数呢。可以用指定浓度cc去和A的每一个浓度值比较，得到每一杯水相对指定浓度值多了多少糖，然后排序。再遍历B的每瓶水的相对于cc的糖的多少x，查找A中有几瓶比x大，累加杰克得到有总共有几种得到浓度大于cc的可能。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 0x7fffffff;
typedef long long ll;

ll n, m, k;
double a[MAXN], b[MAXN], c[MAXN], d[MAXN], more[MAXN];
double cc;

ll check(double cc)
{
	for (int i = 0; i < m; ++i) {
		more[i] = c[i] - cc * d[i] / (1 - cc);
	}
	sort(more , more + m);
	ll cnt = 0;
	for (int i = 0; i < n; ++i) {
		double less = -(a[i] - cc * b[i] / (1 - cc));
		ll t = m - (upper_bound(more, more + m, less) - more);
		//cout << t << '\n';
		cnt += t;
	}
	return cnt;
}

int main()
{
	cin >> n >> m >> k;
	for (int i = 0; i < n; i++) {
		cin >> a[i] >> b[i];
	}
	for (int i = 0; i < m; i++) {
		cin >> c[i] >> d[i];
	}
	double low = 0, high = 1, mid;
	for (int i = 0; i < 100; i++) {
		mid = (low + high) / 2;
		if (check(mid) < k) {
			high = mid;  //如果k和check(mid)相等
		}
		else {
			low = mid;
		}
		//cout<<'\n';
	}
	printf("%.15lf", 100 * high);
	return 0;
}
~~~





## abc_296

**C**  简单的二分查找，使用lower_bound即可。

**D**

**E:**  理解成图，找环节点个数即可。

**F：**考虑和逆序对相关。

关于**逆序对和数列移动**的结论关系：

**定理1：** 序列中所有元素不相等，则交换序列的任意两个数，则若是奇排列，会变为偶排列；若是偶排列，会变成奇排列。
**定理2：** 任意一个n阶排列可经过一系列对换变成标准排列，并且所作对换次数的奇偶性与这个排列的奇偶性相同。

那么考虑**定理1**的证明：先证明两个**相邻**的元素对调，那么逆序对变化为 $1$ 。再考虑**去掉相邻**的特殊条件，假设两个数字相差 $m$ 个位置，则现将前一个数字移动m个位置，则逆序对**变化m次数**，再将后一个数字移动 $m - 1$ 次，则总次数为 $2*m-1$，显然逆序对变化个数为奇数个。那么定理1证明。（什么线性代数）

那么回到这道题，这道题给出两个数列，求每次独立翻转两个数列中的两个数，求是否可以使得两个数列完全相同。那么**先考虑数字是否相同**，可以multiset维护。在考虑能否反转成功，因为每次反转都改变逆序对的**奇偶性**，那么如果两个数列的奇偶性不同则必然不能反转得到形同数列，但是如果数列中有相同元素，则可以通过反转相同元素来改变奇偶，因而本题只需要做三次判断。

* 出现的数字是否完全相同
* 是否有重复元素出现
* 两个数列的逆序对奇偶性是否相同

根据条件一一判断即可。

~~~c++
~~~



**G：**









## abc_297:

**A:** 输入数列，依次遍历找到第一个 $a[i] > a[i - 1] + D$ 即可。

**B：**模拟题。根据题意判断即可。

**C：**遍历查找替换即可。

**D：**如果依据题目要求一次次进行减法处理，$1e18，1$ 的数据情况显然会超时。可以将相同操作合并处理。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 1e3 + 10;
const int INF = 0x7fffffff;
typedef long long ll;

ll n, m, cnt = 0;

int main()
{
	cin >> n >> m;
	while (n != m) {
		//	cout << n << m <<"\n";
		if (n > m) {
			ll k = (n - m) / m;
			if ((n - m) % m != 0)k++;
			cnt += k;
			n -= k * m;
		}
		else if (n < m) {
			ll k = (m - n) / n;
			if ((m - n) % n != 0)k++;
			cnt += k;
			m -= k * n;
		}
	}
	cout << cnt;
	return 0;
}
~~~

在做题时发现该操作并不会影二者最大公约数的变化，于是也可以用类似求gcd的方法来求。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 1e3 + 10;
const int INF = 0x7fffffff;
typedef long long ll;

ll n, m, cnt = 0;

ll gcd(ll x, ll y)
{
	if (x < y) swap(x, y);
	if (x % y == 0) return (x - y) / y;
	ll k = x % y;
	return (x - k) / y + gcd(k, y);
}

int main()
{
	cin >> n >> m;
	cout << gcd(n, m);
	return 0;
}
~~~

**E:** 

给出多个数字，数字可以任意个数的随意排练求出和，求出第k大的和的值。（题目大意。

分析题意，由于取数的个数不限，则穷尽的方法不太可行。考虑使用**set容器**维护价格，因为一种价格只有一次贡献，考虑使用普通的**set**即可。只需每次取出set的首位值并删除，再插入分别与各个数字相加的结果，直到第k个即可，考虑初始用 $0$ 来启动。时间复杂度约为 $O(K*logK)$ 。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 1e5 + 10;
const int INF = 0x7fffffff;
typedef long long ll;

ll n, m, a[MAXN], cnt = 0;
set <ll> s;

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	s.insert(a[0]);
	while (1) {
		ll k = *s.begin();
		for (int i=1;i<=n;i++){
			s.insert(k + a[i]);
		}
		s.erase(k);
		cnt++;
		if (cnt == m) break;
	}
	cout << *s.begin();
	return 0;
}
~~~



G：

**Nim问题**的变种。根据Nim问题的什么原则，可以将问题简化为只一堆的情况，再异或即可。

那么接下来考虑**只有一堆的情况**。由题目，因为每次只能移除数字范围为 $[l, r]$ 的石头个数，则显然个数 $n\in[0,l - 1]$ 的时候 $sg[n] = 0$；那么向上递推，易得 $n\in[l,l+l-1]$ 时候 $sg[n] = 1$ ，$n\in[j*l,(j+1)*l-1]$ 时候 $sg[n] = j$ 。直到 $n \in [m*l, r]$ 为止。那么当 $n\in[r+l,r+2*l-1]$，$n$ 无论如和减少都无法到 $sg = 0$ 的情况。 则 $sg[n]$ 为0。那么同理可得，$n\in[2*r+2*l,2*r+3*l-1]$ 的时候 $sg[n] = 0$ 。那么 $l+r$ 是一个循环。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 0x7fffffff;
typedef long long ll;

ll n, l, r, a[MAXN], sg[MAXN], sum;

int main()
{
	cin >> n >> l >> r;
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
		a[i] = a[i] % (l + r);
		if (a[i] < l) sg[i] = 0;
		else {
			a[i] -= (l - 1);
			sg[i] = ceil(1.0 * a[i] / l);
		}
		sum = sum ^ sg[i];
	}
	if (sum == 0) cout<<"Second";
	else cout<<"First";
	return 0;
}
~~~



## abc_299:

**A:** 给出一个由 $. | *$ 组成的字符串，请问 $*$ 是否在两个 $|$ 之间。

那么用一个数字记录是否经过了几次 | 即可。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 1e4 + 10;
const int MAXM = 1e2 + 10;
const int MAXK = 1e8 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n;
string str;
bool flag = false;

int main()
{
	cin >> n >> str;
	for (int i = 0; i < n; i++) {
		if (str[i] == '|' && !flag) {
			flag = true;
		}
	    else if (flag && str[i] == '|') {
			flag = false;
		}
		if (str[i] == '*') {
			if (flag) cout << "in";
			else cout << "out";
		}
	}
	return 0;
}
~~~

**B:** 给出$N$和$T$，以及两个大小为N的数组$C$与$R$，若有 $C$ 与 $T$ 相等，则输出相等的位置的 $R$ 的最大值；否者输出与 $1$ 的 $C$ 相等的 $R$ 的最大值。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e5 + 10;
const int MAXM = 1e2 + 10;
const int MAXK = 1e8 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

bool flag = false;
int n, t, c[MAXN], a[MAXN], s;

int main()
{
	cin >> n >> t;
	for (int i = 1; i <= n; i++) {
		cin >> c[i];
		if (c[i] == t) {
			flag = true;
			s = i;
		}
	}
	if (!flag) {
		t = c[1];
		s = 1;
	}
	for (int i = 1; i <= n; i++) cin >> a[i];
	for (int i = 1; i <= n; i++) {
		if (c[i] == t && a[i] > a[s]) {
			s = i;
		}
	}
	cout << s;
	return 0;
}
~~~

**C:** 给出一个字符串，形如 "ooo-" 或者 ”-ooo“ 的字符串为三级，输出最大级或者 $-1$ 当没有的时候。那么只要前往后，后往前各遍历一次即可。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n, maxn = 0, t = 0;
string str;

int main()
{
	cin >> n >> str;
	for (int i = 0; i < str.size(); i++) {
		if (str[i] == 'o') {
			t++;
		}
		if (str[i] == '-') {
			maxn = max(maxn, t);
		}
		if (str[i] != 'o') {
			t = 0;
		}
	}
	t = 0;
	for (int i = str.size() - 1; i >= 0; i--) {
		if (str[i] == 'o') {
			t++;
		}
		if (str[i] == '-') {
			maxn = max(t, maxn);
		}
		if (str[i] != 'o') {
			t = 0;
		}
	}
	if (maxn) cout << maxn;
	else cout << "-1";
	return 0;
}
~~~

**D：** 一道神奇的交互题，做的时候完全不能理解（反而做出了E题）。
大致题意：给出一个由0，1组成的字符串，但题目只给出其长度。输入“？x”即可得到x处的符号，找出一个两边不同的位置。已知字符串开头为0，末位为1。

那么这个已知，十分地有用，虽然字符串可能是”00100001“这样的，但是只要找到任意一个位置都可以，那么就直接二分。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 1e5 + 100;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n, x;

int main()
{
	cin >> n;
	int l = 1, r = n, mid = (l + r) >> 1;
	while (l < r - 1) {
		mid = (l+r)>>1;
		cout << "?" << mid << '\n';
		cin >> x;
		if (x == 0) l = mid;
		else r = mid;
	}
	cout << "!" << l << '\n';
	return 0;
}
~~~

**E：** 给出一个无向简单图。要求其中某些点距离为 $d[i]$ 的位置是黑色，而更近的位置都是白色，求是否有满足条件的可能，有则输出。

先用邻接表存图。然后初始化所有点为黑色，在用 **bfs** 每个有要求的点，距离小于d[i] 的都变为白色。最后在使用 **bfs** 统计每个有要求的点是否有符合条件的黑色点即可。

（抽象思路：满足两个条件，可以使得一个条件先大致满足，然后确保另一个条件满足，再会过来判断第一个条件是否满足）

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e3 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n, m, k, col[MAXN], vis[MAXN], D[MAXN];
vector <int> G[MAXN];

void bfs1(int s, int len) //第一次bfs
{
	memset(vis, 0, sizeof(vis));
	queue <P> que;
	que.push(P(s, 0));
	while (!que.empty()) {
		P p = que.front();
		que.pop();
		int u = p.first, d = p.second;
		vis[u] = 1; 
		if (d >= len) continue; 
		else if (d < len) { //小于d，涂黑
			col[u] = 1;
		}
		for (auto to : G[u]) {
			if (!vis[to]) {
				que.push(P(to, d + 1));
			}
		}
	}
	return;
}

int bfs2(int s, int len)
{
	memset(vis, 0, sizeof(vis));
	queue <P> que;
	que.push(P(s, 0));
	while (!que.empty()) {
		P p = que.front();
		que.pop();
		int u = p.first, d = p.second;
		vis[u] = 1;
		if (d > len) continue;
		else if (d == len) {
			if (col[u] == 0) return 1; //发现距离等于d的黑点
		}
		for (auto to : G[u]) {
			if (!vis[to]) {
				que.push(P(to, d + 1));
			}
		}
	}
	return 0; //没有发现距离等于d的黑点
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	cin >> k;
	for (int i = 1; i <= n; ++i) {
		D[i] = -1;
	}
	for (int i = 1; i <= k; ++i) {
		int u, d;
		cin >> u >> d;
		D[u] = d;
		bfs1(u, d);
	}
	for (int i = 1; i <= n; i++) {
		if (D[i] != -1 && bfs2(i, D[i]) == 0) {
			cout << "No\n";
			return 0;
		}
	}
	cout << "Yes\n";
	for (int i = 1; i <= n; ++i) {
		cout << 1 - col[i];
	}
	return 0;
}
~~~

ps：用dfs好像会超时？

**F：** 一开始想用pmt做，发现错的离谱。现在发现**会不了一点**。









## abc_300:

**A:** 给出两个数字与一串数列，找到数列中等于该两个数字的和的位置。

遍历查找即可。

**B:**给出两个图，图可以每一行都左移或者每一列都下移，询问第一个图是否可以百年城第二个图。

因为数据范围十分的小，遍历所有可能依次判断即可。

~~~c++
#include <iostream>
#include <vector>
#include <string>
using namespace std;

int H, W;
vector<string> A, B;

vector<string> shift_vertical(vector<string> grid) {
    vector<string> new_grid(H, "");
    for (int j = 0; j < W; j++) {
        string col = "";
        for (int i = 0; i < H; i++) {
            col += grid[i][j];
        }
        col = col.substr(1) + col[0];
        for (int i = 0; i < H; i++) {
            new_grid[i] += col[i];
        }
    }
    return new_grid;
}

vector<string> shift_horizontal(vector<string> grid) {
    vector<string> new_grid;
    for (int i = 0; i < H; i++) {
        string row = grid[i].substr(1) + grid[i][0];
        new_grid.push_back(row);
    }
    return new_grid;
}

int main() {
    cin >> H >> W;

    for (int i = 0; i < H; i++) {
        string line;
        cin >> line;
        A.push_back(line);
    }

    for (int i = 0; i < H; i++) {
        string line;
        cin >> line;
        B.push_back(line);
    }

    for (int s = 0; s < H; s++) {
        for (int t = 0; t < W; t++) {
            vector<string> C = A;
            for (int i = 0; i < s; i++) {
                C = shift_vertical(C);
            }
            for (int j = 0; j < t; j++) {
                C = shift_horizontal(C);
            }
            if (C == B) {
                cout << "Yes" << endl;
                return 0;
            }
        }
    }
    cout << "No" << endl;
    return 0;
}
~~~

**C：** 给出一个二维图，由 "x" 与"."组成，问其中由 ”x“ 组成的X形状的大小以及个数。



![image](https://img.atcoder.jp/ghi/abc300c_aa5161e20f55652dc61ad221348765bb002e4eed378c352bc0e44c7555148ebc.jpg)

如图，即是有两个x，左大小为1，右大小为2。

基本思路：遍历图形，如果发现”x“，寻找其[x+1,y+1],[x-1,y+1]等四个部分是否为’x‘，如果是，则将1替换为d，不断判断直至找到最大的d。用数组维护大小为d的X的数量即可。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 5e4+10;
const int MAXK = 5e2 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int h, w, f[110][110],s[110];

bool check(int x,int y)
{
	if(x<1||y<1||x>h||y>w) return false;
	if(f[x][y] == 0) return false;
	return true;
}

int main()
{
	cin >> h >> w;
	for (int i = 1; i <= h; ++i) {
		for (int j = 1; j <= w; ++j) {
			char c;
			cin >> c;
			if (c == '#') f[i][j] = 1;
		}
	}
	for (int i = 1; i <= h; ++i) {
		for (int j = 1; j <= w; ++j) {
			if(f[i][j] == 1){
				int n = 1;
				while(check(i+n,j+n)&&check(i+n,j-n)&&check(i-n,j+n)&&check(i-n,j-n)){
					n++;
				}
				s[n - 1]++;				
			}
		}
	}
	for (int i=1;i<=min(h,w);++i){
		cout<<s[i]<<" ";
	}
	return 0;
}
~~~

**D：**大致题意，给出一个数N，求有几个不同的质数 $p1,p2,p3$ 使得 $p1^2*p2*p3^2 <= N$ 。 

由于 $N$ 的范围为 $300≤ N ≤10^{12}$ 。那么 $p$ 的范围约到 $3*10^5$。那么使用**素数筛**求出该范围内的质数，然后逐一遍历判断是否符合条件即可。由于**时间复杂度**以及遍历 $p$ 相乘的时候可能会超过 $long long$ 范围，所以需要及时**剪枝**。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 5e5 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

vector <int> prime;
vector <bool> is_prime(MAXN,1);

void sieve(int n)
{
	is_prime[0] = is_prime[1] = true;
	for (ll i = 2; i <= n; ++i) {
		if (!is_prime[i]) continue;
		prime.push_back(i);
		for (ll j = i * i; j <= n; j+=i) {
			is_prime[j] = 0;
		}
	}
	return;
}

int main()
{
	sieve(300000);
	ll n, ans = 0;
	cin >> n;
	int sz = prime.size();
	for (int i = 0; i < sz; ++i) {
		ll p1 = prime[i];
		if (p1 * p1 > n) break; //剪枝
		for (int j = i + 1; j < sz; j++) {
			ll p2 = prime[j];
			if (p1 * p1 * p2 > n) break; //剪枝
			int k = sz - 1;
			while (p1 * p1 * p2 * prime[k] > n) k--; //剪枝
			while (p1 * p1 * p2 * prime[k] * prime[k] > n) k--;
			if (k <= j) break;
			ans += k - j; //统计答案
		}
	}
	cout << ans;
	return 0;
}
~~~

***E:** 题目大意：给出一个数字N。每次可以进行一次操作，将数字x乘以 $1,2,3,4,5,6$ ,每个数字等概率，数字x原来是 $1$ 。若数字x大于N则推出，求最后落到N的概率。

典型的概率dp题目。考虑使用从 $N$ 到 $1$ 的情况，（实际好像都一样？）。那么由于 $N$ 的范围比较大，考虑使用 **set** 存储在动态规划时候会经过的数字，再用 **map** 存储每个数字的概率。

ps：一开始考虑用的是queue，但是忘记去掉重复。后来发现开数组记录成本太大，于是使用set。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 1e3 + 100;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

ll n;
map <ll, ll> ma;
set <ll> se;

ll qpow(ll a, ll n)
{
	ll ans = 1.0;
	while (n) {
		if (n & 1) ans = (ans * a) % mode;
		a = (a * a) % mode;
		n >>= 1;
	}
	return ans;
}

int main()
{
	cin >> n;
	se.insert(n);
	int MOD = qpow(5, mode - 2);
	ma[n] = 1;
	while (!se.empty()) {
		set<ll>::iterator ip = se.end();
		ip--;
		ll s = *ip;
		se.erase(ip);
	//	if(s>0) cout<<s<<'\n';	
		for (int i = 2; i <= 6; ++i) {
			if (s % i == 0) {
				se.insert(s / i);
				ma[s / i] = (ma[s / i] + (ma[s] * MOD) % mode) % mode;
			}	
		}
	}
	cout << ma[1];
	return 0;
}
~~~





## abc_303

期末的时候顺便做一做，发现a了五个题，F也差点a出来，突然变强了（大概？

**A:** 判断两个字符串是否相等，其中 $l$ 与 $1$ 等效， $0$ 与 $o$ 等效。

那么遍历两个字符串，将数字均转化为字母后再判断即可。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 3e5 + 100;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n;
string s1, s2;

int main()
{
	cin >> n >> s1 >> s2;
	for (int i = 0; i < n; ++i) {
		if (s1[i] == '1') s1[i] = 'l';
		if (s1[i] == '0') s1[i] = 'o';
		if (s2[i] == '1') s2[i] = 'l';
		if (s2[i] == '0') s2[i] = 'o';
	}
	if (s1 == s2) cout << "Yes";
	else cout << "No";
	return 0;
}
~~~



**B:** 给出m个大小为n的数列，求出在这多个数列中均未相邻的数对的数目。

遍历所有数列，如果找到相邻在总数中减去一，并且记录是否已经被统计过即可。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 3e5 + 100;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n, m, a[100][100], vis[100][100], ans = 0;

int main()
{
	cin >> n >> m;
	ans = n * (n - 1) / 2;
	for (int i = 1; i <= m; ++i) {
		for (int j = 1; j <= n; ++j) {
			cin >> a[i][j];
			if (j != 1) {
				if (!vis[a[i][j]][a[i][j - 1]]) {
					ans--;
					vis[a[i][j]][a[i][j - 1]] = vis[a[i][j - 1]][a[i][j]] = 1;
				}
			}
		}
	}
	cout << ans;
	return 0;
}
~~~



**C:** 模拟题，按照题目要求完成即可。（但是这题表述似乎有点不太清楚

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 3e5 + 100;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n, m, h, k;
string str;
map <P, bool> ma;

int main()
{
	cin >> n >> m >> h >> k >> str;
	for (int i = 1; i <= m; ++i) {
		int x, y;
		cin >> x >> y;
		ma[P(x,y)] = 1;
	}
	int x = 0, y = 0;
	for (int i = 1; i <= n; ++i) {
		if (str[i - 1] == 'L') x--;
		if (str[i - 1] == 'R') x++;
		if (str[i - 1] == 'U') y++;
		if (str[i - 1] == 'D') y--;
		h--;
		if (h < 0) {
			cout << "No";
			return 0;
		}
		if (ma[P(x,y)] && h < k) {
			h = k;
			ma[P(x,y)] = 0;
		}
	}
	if(h>=0)cout << "Yes";
	else cout<<"No";
	return 0;
}
~~~



**D：** 给出三个数字，分别代表**直接打出字母** ，**shift+字母**，**切换Caps锁定键状态**。给出一段字符，一直默认Caps为小写状态，求打出这段字符所需的最小时间。

一眼**dp**，使用$dp[i][0]$表示打到第i个字符，Caps小写状态时的最小时间，$dp[i][1]$表示达到第i个字符，Caps大写状态时的最小时间。那么确定初始状态，状态转移方程即可。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 3e5 + 100;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

ll a, b, c, dp[MAXN][2]; //0是大写键关闭，1是大写键开启
string str;

//假如现在为第i个字符为A，且大写键开启
//那么可能来自于:
//1.大写键开启直接输入
//2.大写键开启先关闭在s输入在开启
//3.大写键关闭先s输入在开启
//4.大写键关闭先开启在输入

int main()
{
	cin >> a >> b >> c >> str;
	int n = str.size();
	if (str[0] == 'A') {
		dp[1][1] = min(dp[0][0] + b + c, dp[0][0] + c + a);
		dp[1][0] = min(dp[0][0] + c + a + c, dp[0][0] + b);
	}
	else if (str[0] == 'a') {
		dp[1][1] = min(dp[0][0] + a + c, dp[0][0] + c + b);
		dp[1][0] = min(dp[0][0] + c + b + c, dp[0][0] + a);
	}
    //先确定一下第一个字符的状态。
	for (int i = 2; i <= n; ++i) {
		if (str[i - 1] == 'A') {
			dp[i][1] = min(min(dp[i - 1][1] + a, dp[i - 1][1] + 2 * c + b), min(dp[i - 1][0] + b + c, dp[i - 1][0] + c + a));
			dp[i][0] = min(min(dp[i - 1][1] + a + c, dp[i - 1][1] + c + b), min(dp[i - 1][0] + c + a + c, dp[i - 1][0] + b));
		}
		if (str[i - 1] == 'a') {
			dp[i][1] = min(min(dp[i - 1][1] + b, dp[i - 1][1] + 2 * c + a), min(dp[i - 1][0] + a + c, dp[i - 1][0] + c + b));
			dp[i][0] = min(min(dp[i - 1][1] + b + c, dp[i - 1][1] + c + a), min(dp[i - 1][0] + c + b + c, dp[i - 1][0] + a));
		}
	}
	cout << min(dp[n][0], dp[n][1]);
	return 0;
}
~~~



**E:** （出乎意料的简单？）给出一张图，已知这张图是由几个“星图”末端相连组成，求组成的星图种类。已知星图是一个节点为中心，其他节点均只和中心节点相连的图，其中，2星是与有两个末端节点的星图。

那么由于是末端相连，那么**非中心节点的度最大只能为2**。那么只需要遍历每个节点，判断度的大小是否大于2，若是，则为对应星图，然后在总节点数中减去该星图的节点数。遍历完后剩下的节点即是由2星图构成的，特判即可。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e5 + 100;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n, u, v, dep[MAXN], sum = 0;
vector <int> ans;

int main()
{
	cin >> n;
	for (int i = 1; i < n; ++i) {
		cin >> u >> v;
		dep[u]++;
		dep[v]++;
	}
	for (int i = 1; i <= n; ++i) {
		if (dep[i] > 2) {
			sum += (dep[i] + 1);
			ans.push_back(dep[i]);
		}
	}
	sort(ans.begin(), ans.end());
	for (int i = 1; i <= (n - sum) / 3; ++i) cout << 2 << " ";
	for (int i = 0; i < ans.size(); ++i) cout << ans[i] << " ";
	return 0;
}
~~~



***F：**考虑使用二分。





## abc_304

**D:**二分查找确定 x 范围内的个数后，再在此基础上二分查找确定 y 范围内的个数，更新即可得到答案。

**E：**给出一个图，并且给出几个不能相通的节点。再询问q次，如果连接某两个节点，前面的条件是否能满足。

 种类并查集（两道并查集的题目会不会太多了？）。先将相连的点连再一起，再将不可相连的点用另一种方式连在一起。在讯问中判断是否将不能连的连在了一起即可。











## Codeforces Round 867 (Div. 3)

**A:**

大致题意：小蘑菇想要在吃饭的时候看视频，且要看的视频最有趣，给出每个视频的**时长**与**有趣值**。已知小蘑菇跳过一个视频要花 $1s$，输出小蘑菇可以看的最有趣视频的索引，或者输出 $-1$ 如果没有答案。

通过**struct** 维护每个视频的**位置**，**时长**，**有趣值**，然后根据有趣值排序，按序判断是否符合条件即可。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int q, n, a[MAXN], t;
bool flag = false;
struct node {
	int num, fun, time;
}b[MAXN];

bool cmp(node x, node y)
{
	return x.fun > y.fun;
}

int main()
{
	cin >> q;
	while (q--) {
		flag = false;
		cin >> n >> t;
		for (int i = 1; i <= n; i++) {
			cin >> b[i].time;
		}
		for (int i = 1; i <= n; i++) {
			cin >> b[i].fun;
			b[i].num = i;
		}
		sort(b + 1, b + n + 1, cmp);
		for (int i = 1; i <= n; i++) {
			int k = b[i].num - 1 + b[i].time;
			if (k <= t) {
				flag = true;
				cout << b[i].num << '\n';
				break;
			}
		}
		if (!flag) cout << -1 << '\n';
	}
	return 0;
}
~~~

**B：**

给出长度为 $n$ 的数列，可以**去掉其中任意个数字**（保证去掉后至少有两个元素）。求数列中相邻两数相乘的最大值。

因为可以去掉任意个数字，那么就相当于求出数列**任意两个数字**相乘的最大值即可。由于题中数列可正可负，因而最小的两个值相乘仍可能得到最大值。那么遍历数组，更新最大值，第二大值，最小值，第二小值即可。

~~~c++
#include <bits/std.c++>
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

ll t, n, a[MAXN];
ll min1, min2, max1, max2;

int main()
{
	cin >> t;
	while (t--) {
		cin >> n;
		min1 = min2 = 9223372036854775807;
		max1 = max2 = -9223372036854775808;
		for (int i = 1; i <= n; ++i) {
			cin >> a[i];
			if (a[i] <= min1) {
				min2 = min1;
				min1 = a[i];
			}
			else if (a[i] < min2) {
				min2 = a[i];
			}
			if (a[i] >= max1) {
				max2 = max1;
				max1 = a[i];
			}
			else if (a[i] > max2) {
				max2 = a[i];
			}
		}
		cout << max(max2 * max1, min1 * min2) << '\n';
	}
	return 0;
}
~~~

**C：**

观察题意，容易得到递推关系，即可求解答案。

~~~c++
#include <iostrea>
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;
 
ll t, n;
 
int main()
{
	cin >> t;
	while (t--) {
		cin >> n;
		cout << n * n + 2 * n + 2 << '\n';
	}
	return 0;
}
~~~

**D:**

构造长度为 $n$ 的数列，满足前 $i$ 项相加的和对 $n$ 取模均不相等。

打表可以发现，若 $n$ 为不为 $1$ 的奇数，则无法构造，若 $n$ 为偶数，则容易构造出
$$
n,n-1,2,n-3,4,......,n-4,3,n-2,1
$$
很显然，数列前 $i$ 项对 $n$ 的模的和在两边不断跳跃地逼近 $n/2$，不会重复。

~~~c++
#include <bits/std.c++>
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;
 
int t, n;
 
int main()
{
	cin >> t;
	while (t--) {
		cin >> n;
		if (n == 1) cout << 1 << '\n';
		else if (n % 2 == 1) cout << -1 << '\n';
		else {
			cout << n << " ";
			for (int i = 1; i < n; ++i) {
				if (i % 2 == 1) cout << n - i << " ";
				else cout << i << " ";
			}
			cout << '\n';
		}
	}
	return 0;
}
~~~

下面给出**证明**：

构造一个长度为 $n$ 的数列。则该**数列的第一个数字必然为** $n$，假设 $n$ 不在第一个位置，那么其为末位的子数列与前一个子数列的模必然相等。而剩下 $n-1$ 个数字，必须满足**任意一个子数列的和不是** $n$ **或者** $n$ **的倍数**，证明同 $n$ 的情况类似。而剩下数的求和为 $n*(n-1)/2$ ，如果 $n$ 为**奇数**，则该式子**必然为n的倍数**，则不满足上面条件；而如果 $n$ 为**偶数**，则可以构造。

**E：**

给出一个字符串，求最少几个步骤让他变成一个**反回文序列**，即对称的字母都不相等。输出 $-1$ 如果无法做到。

分析题目，显然当**字符串长度为奇数时**，无法做到。如果长度为偶数，若某个字母出现的次数大于 $n/2$，那么也无法做到。而长度为偶数并且字母出现次数均小于 $n/2$ 时，只要统计对称的位置出现了哪几个字母，各个字母出现了几次，如果某个字母出现的次数大于总次数的一半，则答案为该字母出现的次数；反之则为[总次数/2]。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int t, n, vis[30];
string str, s;
bool flag;

int main()
{
	cin >> t;
	while (t--) {
		memset(vis, 0, sizeof(vis));
		flag = false;
		cin >> n >> str;
		if (n % 2 == 1) {
			cout << -1 << '\n';
		}
		else {
			for (int i = 0; i < n; i++) {
				char c = str[i];
				vis[c - 'a']++;
			}
			for (int i = 0; i < 26; i++) {
				if (vis[i] > n / 2) {
					flag = true;
				}
			}
			if (flag) cout << -1 << '\n';
			else {
				memset(vis, 0, sizeof(vis));
				s = str.substr(n / 2, n / 2);
				reverse(s.begin(), s.end());
				for (int i = 0; i < n / 2; i++) {
					if (str[i] == s[i]) {
						char c = str[i];
						vis[c - 'a']++;
					}
				}
				int ans = 0, sum = 0;
				for (int i = 0; i < 26; ++i) {
					if (vis[i]) {
						ans = max(ans, vis[i]);
						sum += vis[i];
					}
				}
				if (ans > sum / 2) cout << ans << '\n';
				else cout << (sum + 1) / 2 << '\n';
			}
		}
	}
	return 0;
}
~~~

Ps:之前做题的时候是想要贪心的求出对称的两两交换后剩下的部分，这部分单独计算再加上两两交换的部分得到答案，代码如下：

~~~c++
for(int i = 0;i < 26; ++i){
					if(vis[i]){
						ans = abs(ans - vis[i]);
						sum += vis[i];
					}
				}
				cout << ans + (sum - ans) / 2 << '\n';
~~~

后来发现这个代码无法满足类似于 $4 5 6$ 这样**两个的和加起来和第三个抵消**的情况。

**F：**

大意：一棵以 $1$ 为根节点，边长度为 $k$，节点数目为 $n$  的树，每次可以花费 $c$ 来移动根节点到相邻节点，求最大利润值，已知利润值为根节点和最远的点的距离减去花费。

显然，**距离树上任意一点最远的点必然在直径端点上**，那么求出任意一点距离两个端点和点 $1$ 的距离，在遍历查询即可。

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <string>
#include <string.h>
using namespace std;
const int MAXN = 2e5 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;
 
int t, n, u, v, sa, sb;
int k, c, d[MAXN][3];
vector <int> G[MAXN];
 
void dfs(int s, int q, int fa = 0)
{
	d[s][q] = d[fa][q] + 1;
	if (q == 0) {
		if (d[s][q] > d[sa][q]) {
			sa = s;
		}
	}
	else if (q == 1) {
		if (d[s][q] > d[sb][q]) {
			sb = s;
		}
	}
	for (auto to : G[s]) {
		if (to != fa) {
			dfs(to, q, s);
		}
	}
	return;
}
 
int main()
{
	ios::sync_with_stdio(false);
	cin >> t;
	while (t--) {
		for (int i = 1; i <= n; i++) {
			G[i].clear();
		}
		sa = sb = 0;
		memset(d, 0, sizeof(d));	
		cin >> n >> k >> c;
		for (int i = 1; i < n; i++) {
			cin >> u >> v;
			G[u].push_back(v);
			G[v].push_back(u);
		}
		dfs(1, 0);
		dfs(sa, 1);
		dfs(sb, 2);
		ll ans = 0;
		for (int i = 1; i <= n; ++i) {
			ll sum = max((ll)(d[i][1] - 1), (ll)(d[i][2] - 1)) * (ll)k - (ll)(d[i][0] - 1) * (ll)c;
			ans = max(ans, sum);
		}
		cout << ans << '\n';
	}
	return 0;
}
~~~

如果将数组直接开为 $ll$ 会超时，所以在答案处转化。

## 贪心



## 模拟：

[Problem - C - Codeforces  ](https://codeforces.com/contest/1658/problem/C) Shinju and the Lost Permutation

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 2e5 + 100;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int t, n, p[MAXN];

void solve()
{
	cin >> n;
	bool flag = true;
	int exist = 0;
	for (int i = 1; i <= n; ++i) {
		cin >> p[i];
	}
	p[n + 1] = p[1];
	for (int i = 1; i <= n; ++i) {
		if (p[i] + 1 < p[i + 1]) flag = false;
		if (p[i] == 1) exist++;
	}
	if (exist == 1 && flag) cout << "YES\n";
	else cout << "NO\n";
	return;
}

int main()
{
	cin >> t;
	while (t--) {
		solve();
	}
	return 0;
}
~~~





## 2022暑期训练#1 

关键词：二进制，思维
题目链接：[Problem - B - Codeforces](https://codeforces.com/contest/1979/problem/B)
题目大意：给出任意两个数字，让其与自然数序列异或得到两个无限长的序列，求这两个序列的最长子序列的长度。

思路：观察样例，发现都是 $2^n$ 形式。

>证明：
>
>设 𝑎⊕𝑥=𝑏⊕𝑦且 𝑎⊕(𝑥−1)≠𝑏⊕(𝑦−1)。
>
>则这样的 *x* 与 *y* 一定是后面 𝑐𝑛𝑡 位全为 0、其余位单独构造使其满足上述条件的数字。
>
>那么根据定义，*a*,*b* 的第 𝑐𝑛𝑡 位一定不相等，这等价于如果加上大于等于 2𝑐𝑛𝑡 的数字则会发生进位，影响前面构造的结果。
>
>所以加上的数字属于闭区间 [0,2𝑐𝑛𝑡−1]，一共 2𝑐𝑛𝑡 个，即长度为 2𝑐𝑛𝑡。
>
>证毕。





