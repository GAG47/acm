## 2024“钉耙编程”中国大学生算法设计超级联赛（2）

[Problems (hdu.edu.cn)](https://acm.hdu.edu.cn/contest/problems?cid=1125) 杭电打的排名普遍不如牛客啊。
本次 Rank：233/848

### 鸡爪

>一个鸡爪是由 $4$ 个部分组成，一个点与三个与该点相邻的边，三个边的另一端点被认为**不在**鸡爪中。
>
>一个图上的鸡爪数是该图最多成形成几个鸡爪，使得图上每个点与边最多**在**一个鸡爪中（注意上文点与边是否在鸡爪中的定义）。
>
>现在给你 $n$ 条边，你可以使用任意个点，构造一个简单无向图（没有自环重边），要求最大化该图的鸡爪数，并输出 $n$ 条边的两端点。如果有多解，请让输出的 $2n$ 个数字在行优先遍历的顺序下，**字典序最小**。
>
>字典序：序列A的字典序小于序列B，当且仅当存在i ( $1≤i≤n$ )，使得 $A[i]<B[i]$ ，且对任意的 $j$  ( $1≤j<i$ )，$A[j]=B[j]$

题解：因为要让鸡爪数目尽可能多，那么**每三条边就一定会有一个鸡爪**，也就意味要加入一个新的点作为鸡爪节点；又因为字典序要最小，因而**编号小的点应连接尽量多的边**。只能形成一个鸡爪的时候：显然最佳方案为 $1,2,3,4$ 形成一个鸡爪；两个鸡爪的时候，$1,3,4,5$ 形成一个鸡爪， $2,1,3,4$ 形成第二个鸡爪；三个鸡爪的时候， $1,4,5,6$ ，$2,1,4,5$ ， $3,1,2,4$ 形成三个鸡爪；四个鸡爪的时候，$1,5,6,7$ ， $2,1,5,6$，$3,1,2,5$  ，  $4,1,2,3$；后面的节点都是一致的。容易的出规律，节点的总数为形成鸡爪数目 $+3$，大节点都通过与小节点的连边形成鸡爪，这样可以满足小节点连接更多节点，以使得字典序精良最小。

~~~c++
// xxc
#include<bits/stdc++.h>
using namespace std;

#define endl '\n'
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
#define ll long long
#define debug(x) cout << #x << ' ' << x << endl;

const int inf = 1e9 + 10;
const ll INF = 1e18 + 10;

void test(){
	int n;cin >> n;
	int nn = n / 3;
	int ptop = 2;
	vector<pair<int,int>> ve;
	if(nn == 1){
		ve.push_back({1,2});
		ve.push_back({1,3});
		ve.push_back({1,4});
		ptop = 5;
	}else if(nn == 2){
		ve.push_back({1,2});
		ve.push_back({1,3});
		ve.push_back({1,4});
		ve.push_back({1,5});
		ve.push_back({2,3});
		ve.push_back({2,4});
		ptop = 6;
	}else if(nn == 3){
		ve.push_back({1,2});
		ve.push_back({1,3});
		ve.push_back({1,4});
		ve.push_back({1,5});
		ve.push_back({1,6});
		ve.push_back({2,3});
		ve.push_back({2,4});
		ve.push_back({2,5});
		ve.push_back({3,4});
		ptop = 7;
	}else if(nn >= 4){
		for(int i = 4;i <= nn;i++){
			ve.push_back({1,i});
			ve.push_back({2,i});
			ve.push_back({3,i});
		}
		ptop = nn + 1;
		ve.push_back({1,2});
		ve.push_back({1,3});
		ve.push_back({2,3});
		ve.push_back({1,ptop});
		ve.push_back({2,ptop});
		ve.push_back({3,ptop});
		ptop++;
		ve.push_back({1,ptop});
		ve.push_back({2,ptop});
		ptop++;
		ve.push_back({1,ptop});
		ptop++;
	}
	while(n % 3){
		n--;
		ve.push_back({1,ptop});
		ptop++;
	}
	sort(ve.begin(),ve.end());
	for(auto [x,y] : ve){
		cout << x << ' ' << y << '\n';
	}
}

int main(){
	IOS
	int t = 1;cin >> t;
	while(t--){
		test();
	}
}
~~~



### 绝对不模拟的简单魔方

>小T最近有些疲惫，想找一些能够放松自己的事情去做，正好想起上次被队友用三阶魔方暴杀的经历，就想苦练一下魔方技术，好在下次的对战中击败他的队友。
>
>于是他在网上下单了一个魔方，让小C帮他去取快递。
>
>可是小C有些调皮，私自拆开了快递，随意的扭了这个魔方**不超过三次**（扭的是侧面，不是中间层，且扭的角度固定为90度），还弄掉了**同一个角上的两片贴纸**。
>
>小C的记性不太好，不太记得两片贴纸正确的位置了，所以随意的将两片贴纸贴了回去，并将这件事告诉了小T。
>
>但小T作为一个还在学习如何还原底层十字的小萌新，面对被小C打乱过的魔方很是束手无策。
>
>所以他向你寻求帮助，希望你告诉他小C有没有将两片贴纸正确的贴回去，如果没有的话，是哪一个角的贴纸贴错了呢。

虽然看起来是大模拟，但实际上是有点思维的大模拟。如果直接大模拟，那就是双端暴搜所有可能被拧到的情况，这样子不仅很难写，时间复杂度还很危险。**注意到**，无论如何旋转，模仿任意一个**角上的三个块的顺时针颜色排列必然与魔方对应的三个颜色的顺时针排列关系一致**，用这个性质一次检测每个角是否符合这个关系即可。

~~~c++
#include<bits/stdc++.h>
using namespace std;

#define endl '\n'
#define IOS ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);
#define ll long long
#define debug(x) cout << #x << ' ' << x << endl;

const int inf = 1e9 + 10;
const ll INF = 1e18 + 10;

char s[10][13];

int headx[] = {0,1,1,3,3,7,7,9,9};
int heady[] = {0,4,6,4,6,4,6,4,6};
int lx[] = {0,4,4,4,4,6,6,6,6};
int ly[] = {0,12,9,3,6,4,7,1,10};
int rx[] = {0,4,4,4,4,6,6,6,6};
int ry[] = {0,1,10,4,7,3,6,12,9};

void test(){
	for(int i = 1;i <= 9;i++){
		string ss;cin >> ss;
		ss = ' ' + ss;
		for(int j = 1;j <= 12;j++)
			s[i][j] = ss[j] - '0';
	}
	set<tuple<int,int,int>> se;
	se.insert({1,2,3});
	se.insert({1,3,4});
	se.insert({1,5,2});
	se.insert({1,4,5});
	se.insert({6,3,2});
	se.insert({6,4,3});
	se.insert({6,5,4});
	se.insert({6,2,5});
	set<tuple<int,int,int>> see;
	for(auto [h,l,r] : se){
		see.insert({h,l,r});
		see.insert({l,r,h});
		see.insert({r,h,l});
	}
	bool f = 0;
	vector<int> ans;
	for(int i = 1;i <= 8;i++){
		if(!see.count({s[headx[i]][heady[i]],s[lx[i]][ly[i]],s[rx[i]][ry[i]]})){
			f = 1;
			ans.push_back(s[headx[i]][heady[i]]);
			ans.push_back(s[lx[i]][ly[i]]);
			ans.push_back(s[rx[i]][ry[i]]);
//			break;
		}
	}
	if(f){
		sort(ans.begin(),ans.end());
		for(auto x : ans) cout << x << ' ';
		cout << '\n';
	}else{
		cout << "No problem\n";
	}
}

int main(){
	IOS
	int t = 1;cin >> t;
	while(t--){
		test();
	}
}
/*
***111******
***111******
***111******
222333444555
222333444555
222333444555
***666******
***666******
***666******
*/
~~~

### 传奇勇士小凯

这道题是许哥单挑出的a，没看题。

>传说在遥远的魔法大陆有着一个村庄叫做卡卡奇里奇，这里有n*n*座房屋，n−1*n*−1条道路，保证了任意两座房屋之间都可以通过道路相互可达。这里环境优美，居民幸福地生活着。
>
>但是有一天晚上，原本平静的村庄突然受到一不明寄生生命体的袭击，奇怪的怪物绑架了所有居民，并控制了所有房屋。凌晨时分，在外游历的勇士小凯收到了卡卡奇里奇国王的召唤来到了卡卡奇里奇，奉命消灭所有怪物，解救整个村庄。
>
>由于有人工智能Fairy的存在，卡卡奇里奇国王能够知道小凯和每个房屋的怪物的较量中的获胜概率是多少。在一场小凯和第i*i*个房屋的怪物较量中，小凯有pi1515*p**i*的概率获得胜利，成功消灭第i*i*个房屋的所有怪物，同时小凯有1−pi151−15*p**i*的概率失败，那么第i*i*个房屋的怪物会依旧存在，只能之后再挑战。由于没有被消灭怪物会在每个晚上恢复元气，所以每一天小凯对第i*i*个房屋的怪物的战斗胜率是固定的。
>
>经过了长途跋涉之后，小凯来到了卡卡奇里奇的**1号房屋**开始了战斗。每一天白天，小凯都会对当前他所在的房屋的怪物发起挑战，如果成功那么他会询问卡卡奇里奇国王然后在国王的建议之下选择一个**与当前房屋相邻的（有直接的道路相连的）**、**还存在怪物**的房屋前进（但是第二天才能对该房屋的怪物进行挑战），如果不存在这样的房屋，那么喜欢摸鱼的小凯便会**离开这个村庄**去摸鱼。如果挑战失败，那么小凯会在这个房屋门口休息一个晚上，等到下一天继续发起挑战。
>
>国王希望摸鱼的小凯在村庄呆的久一点，所以他想问你在他的控制之下，小凯最多期望在村庄里停留多少天？请你以最简分数的形式告诉他这个答案。

### URL划分

>给定一个 URL 字符串 S*S*，形如 `s3://hdu-oj-bucket/problem=1/type=data/`。
>
>字符串的格式规定具体如下：
>
>1. 首先是指定使用的**传输协议**，例如 `http`, `ftp`, `s3`，保证传输协议只由小写英文字母和数字构成。之后紧跟 `://`
>2. 接下来会紧跟一个字符串为其**网络位置**，以 `/` 为终止，在给定的例子中为 `hdu-oj-bucket`。
>3. 在网络位置之后的路径字符串，每个子结构都会紧跟一个 `/`，在给定的例子中传输协议后面可以看成是 `problem=1/`, `type=data/` 两个子结构组成的。假如说出现了 `/` 可以认为一定发生了子结构的切分。保证每个子结构中只会用到小写英文字母，数字，`-`，`=`，`/`。
>4. 在路径字符串的子结构中，如果存在形如 `A=B/` 的子结构，那就意味着在路径中声明了一些**环境变量**的值。在给定的例子中我们指定了 `problem=1`, `type=data`。为了方便解析我们保证 `A,B` 只由小写英文字母和数字构成，同时保证 `A` 是一个合法的变量命名。
>
>对于一个确定的 URL 字符串 S*S*，小 T 希望你帮忙解析这个字符串，输出这个 URL 所使用的**传输协议**，**网络位置**，以及其在路径字符串子结构中定义的**环境变量**。

签到模拟题，但是因为忽略了几个条件导致 $wa$ 了几发，非常痛苦。

### 女神的睿智

>Alice在玩一款名叫《闪耀!优俊少女》的游戏，在这个游戏中，有一个重要的道具叫做女神的睿智。
>
>为了获得女神的睿智，需要按顺序将88个知识碎片两两合成为结晶，再将44个结晶合成成为大结晶，最后将22个大结晶合成得到女神的睿智。
>
>女神的睿智有着三种颜色，知识碎片和结晶也有着三种颜色。
>
>在合成的碎片颜色相同时，结晶的颜色与碎片相同，在颜色不同时，结晶的颜色与左侧碎片相同。
>
>在合成的结晶颜色相同时，大结晶的颜色与结晶相同，在颜色不同时，大结晶的颜色与左侧结晶相同。
>
>在合成的大结晶颜色相同时，女神的睿智的颜色与大结晶相同，在颜色不同时，我们比较两种颜色的碎片在女神的睿智中出现的数量，选择出现数量多的碎片的颜色作为女神的睿智的颜色，碎片数量相同时，随机选择一个大结晶颜色作为女神的睿智的颜色。
>
>Alice想要知道最后能获得的女神的睿智的颜色。

许哥a的，听说也是签到题？

看了一眼，发现也是暴力模拟题，确实非常签到。

### 在 A 里面找有 C 的 B

>小 T 最近上班碰到了一个问题，怎么样才能用 Vscode 快速的**在 A 里面找有 C 的 B**。
>
>他想要在代码库的一个文件 A*A* 中，找到有哪些在 A*A* 中使用到的函数 B*B* 间接地调用了小 T 所指定的语句 C*C*。由于小 T 的需求比较简单，所以这里不考虑间接调用的函数中的调用关系，只需要看 B*B* 的声明中 B′*B*′ 是否包含 C*C* 即可。
>
>手动处理这个问题还是有相当大的重复工作量的，但是你是一个经验丰富的**SQL BOY/GIRL**，你对小 T 说："闹麻了，这不就是把 A 里面包含的 B，和包含 C 的 B JOIN 一下就行了吗。"
>
>虽然是的，但是这两张表哪来呢？
>
>为了圆你吹下的牛，现在你需要手写一个字符串解析器，用来**在 A 里面找有 C 的 B**。
>
>接下来我们会给定一个长字符串 A*A*，一个短字符串 C*C*，以及 n*n* 个短字符串 Bn*B**n*，以及其声明 Bn′*B**n*′。
>
>我们定义一个字符串 S*S* 在字符串 T*T* 中当且仅当存在一个 T*T* 的子串 p*p* 满足：S=p*S*=*p*。

题目含义与题目标题一致，在 A 里面找有 C 的 B。











