# 网络流

## 最大流

### FF

这是一种时间复杂度为 $O(fm)$ 的算法，$f$ 为最大流。

~~~c++
int n, m, s, t; // s是源点，t是汇点
bool vis[MAXN];
int dfs(int p = s, int flow = INF)
{
    if (p == t)
        return flow; // 到达终点，返回这条增广路的流量
    vis[p] = true;
    for (int eg = head[p]; eg; eg = edges[eg].next)
    {
        int to = edges[eg].to, vol = edges[eg].w, c;
        // 返回的条件是残余容量大于0、未访问过该点且接下来可以达到终点（递归地实现）
        // 传递下去的流量是边的容量与当前流量中的较小值
        if (vol > 0 && !vis[to] && (c = dfs(to, min(vol, flow))) != -1)
        {
            edges[eg].w -= c;
            edges[eg ^ 1].w += c;
            // 这是链式前向星取反向边的一种简易的方法
            // 建图时要把cnt置为1，且要保证反向边紧接着正向边建立
            return c;
        }
    }
    return -1; // 无法到达终点
}
inline int FF()
{
    int ans = 0, c;
    while ((c = dfs()) != -1)
    {
        memset(vis, 0, sizeof(vis));
        ans += c;
    }
    return ans;
}
~~~



### EK

这是一种时间复杂度上限为 $O(nm^2)$ 的算法。

~~~c++
...

struct Edge
{
    ll to,w,nex;
}edge[MAXM];
int head[MAXN],cnt=1;
void add(int from,int to,int w)
{
    edge[++cnt].to=to;
    edge[cnt].w=w;
    edge[cnt].nex=head[from];
    head[from]=cnt;
}

ll n,m,s,t,last[MAXN],flow[MAXN];
inline int bfs()
{
    memset(last,-1,sizeof(last));
    queue<int>que;
    que.push(s);
    flow[s]=INF;
    while(!que.empty())
    {
        int p=que.front();
        que.pop();
        if(p==t) //到达汇点 结束搜索
        {
            break;
        }
        for(int eg=head[p];eg;eg=edge[eg].nex)
        {
            ll to=edge[eg].to,val=edge[eg].w;
            if(val>0 && last[to]==-1) //残余容量大于0且未访问过
            {
                last[to]=eg;
                flow[to]=min(flow[p],val);
                que.push(to);
            }
        }
    }
    return last[t]!=-1;
}
inline ll EK()
{
    ll maxflow=0;
    while(bfs())
    {
        maxflow+=flow[t];
        for(int i=t;i!=s;i=edge[last[i]^1].to)
        {
            edge[last[i]].w-=flow[t]; //保证正反边恰好占据奇偶数
            edge[last[i]^1].w+=flow[t]; //并且不用0 1 （0为边界点）
        }
    }
    return maxflow;
}

void solve()
{
    cin>>n>>m>>s>>t;
    int u,v,w;
    for(int i=1;i<=m;++i)
    {
        cin>>u>>v>>w;
        add(u,v,w);
        add(v,u,0);
    }
    cout<<EK();
}
...
~~~

### Dinic

这是一种时间复杂度上限为 $O(n^2m)$ 的算法，在**稠密图**中，比 $EK$ 算法有更好的效率。

~~~c++
struct Edge
{
    ll to,w,next;
}edge[MAXM];
ll head[MAXN],cnt=1;
void add(int from,int to,ll w)
{
    edge[++cnt].to=to;
    edge[cnt].w=w;
    edge[cnt].next=head[from];
    head[from]=cnt;
}

ll n,m,s,t,lv[MAXN],cur[MAXN]; //lv是层数 cur是当前弧优化
inline bool bfs() //bfs负责分层
{
    memset(lv,-1,sizeof(lv));
    memcpy(cur,head,sizeof(head));
    lv[s]=0;
    queue<int>que;
    que.push(s);
    while(!que.empty())
    {
        int q=que.front();
        que.pop();
        for(int i=head[q];i;i=edge[i].next)
        {
            int to=edge[i].to,val=edge[i].w;
            if(val>0&&lv[to]==-1) //未更新过深度则更新
            {
                lv[to]=lv[q]+1,que.push(to);
            }
        }
    }
    return lv[t]!=-1;
}
ll dfs(int p=s,ll flow=INF)
{
    if(p==t) return flow;
    ll rmn=flow; //剩余的流量
    for(int i=cur[p];i&&rmn;i=edge[i].next) //没有剩余流量就退出
    {
        cur[p]=i; //当前弧优化
        ll to=edge[i].to,val=edge[i].w;
        if(val>0&&lv[to]==lv[p]+1) //只传向更深的层
        {
            int c=dfs(to,min(val,rmn));
            rmn-=c; //剩余流量减少
            edge[i].w-=c;
            edge[i^1].w+=c;
        }
    }
    if(rmn==flow) lv[p]=0; //如果一点没流出去，在这个dfs内就没必要再访问了
    return flow-rmn; //返回传递出去的流量大小
}
inline ll dinic()
{
    ll ans=0;
    while(bfs())
    {
        ans+=dfs();
    }
    return ans;
}
~~~

### ISAP

## 费用流

### EK+SPFA

~~~c++
int head[MAXN],cnt=1;
struct Edge
{
    int to,w,c,next;
}edge[MAXM*2];
inline void add(int from,int to,int w,int c)
{
    edge[++cnt].to=to;
    edge[cnt].w=w;
    edge[cnt].c=c;
    edge[cnt].next=head[from];
    head[from]=cnt;
}

int n,m,s,t,last[MAXN],flow[MAXN],inq[MAXN],dist[MAXN];
queue<int>que;
bool SPFA()
{
    while(!que.empty()) que.pop();
    memset(last,-1,sizeof(last));
    memset(inq,0,sizeof(inq));  //是否在队列中
    memset(dist,127,sizeof(dist));  //距离源点的最小距离
    flow[s]=INF;
    dist[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int q=que.front();
        que.pop();
        inq[q]=0;
        for(int i=head[q];i;i=edge[i].next)
        {
            int to=edge[i].to,val=edge[i].w;
            if(val>0&&dist[to]>dist[q]+edge[i].c)
            {
                last[to]=i; //记录上一条边
                flow[to]=min(flow[q],val); //更新下一个点的流量
                dist[to]=dist[q]+edge[i].c;
                if(!inq[to])
                {
                    que.push(to);
                    inq[to]=1;
                }
            }
        }
    }
    return last[t]!=-1;
}
int maxflow,mincost;
inline void MCMF()
{
    while(SPFA())
    {
        maxflow+=flow[t];
        mincost+=dist[t]*flow[t];
        for(int i=t;i!=s;i=edge[last[i]^1].to) 
        {
            edge[last[i]].w-=flow[t];
            edge[last[i]^1].w+=flow[t];
        }   
    }
}
~~~

## 二者取一模型



## 对偶图优化最小割

结论：**求一个网络流的最小割等价于求其对偶图的最短路**
这个结论十分具象且符合直觉，对偶图上的没一个经过所有点的简单路径，必然将原图的节点分为两个集合。这可以由对偶图的性质与定义简单得出。而一般在求解该问题时，不会直接求对偶图上的最短路，而是会把**图外连通块**所化的点分割为起点与终点，然后再跑最短路，一般情况下，时间复杂度可以将一个半级别。
![img](https://cdn.luogu.com.cn/upload/pic/63309.png)

[[ICPC-Beijing 2006] 狼抓兔子(对偶图求最小割板题)](https://www.luogu.com.cn/problem/P4001)



# 网络流24题



## 2、[飞行员配对方案问题](https://www.luogu.com.cn/problem/P2756)

**题意**：第二次世界大战期间，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的两名飞行员，其中一名是英国飞行员，另一名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。一共有 $n$ 个飞行员，其中有 $m$ 个外籍飞行员和 $(n - m)$ 个英国飞行员，**外籍飞行员从 $1$ 到 $m$ 编号**，**英国飞行员从 $m + 1$ 到 $n$ 编号**。 对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。

**题解**：网络流中最基础的一类题目：**二分图最大匹配**。英国和外籍分别作为一个集合，中间的边表示可以很好配合，求最大匹配即可。网络流的求法：所有的英国/外籍与源点建立流量为 $1$ 的边，另一个则与汇点建立流量为 $1$ 的边，求最大流即可。



## 3、[软件补丁问题 ](https://www.luogu.com.cn/problem/P2761)

**题意**：
T 公司发现其研制的一个软件中有 $n$ 个错误，随即为该软件发放了 $m$ 个补丁程序。
每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。
换句话说，对于任意一个补丁 $i$，都有四个与之相应的集合 $B1_i,B2_i,F1_i$ 和 $F2_i$。仅当软件包含 $B1_i$ 中的所有错误，而不包含 $B2_i$ 中的任何错误时，才可以使用补丁 $i$。补丁 $i$ 将修复软件中的某些错误集合 $F1_i$，而同时加入另一些错误 $F2_i$。另外，运行每个补丁都耗费一定的时间。
试设计一个算法，利用 T 公司提供的 $m$ 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的 $n$ 个错误和 $m$ 个补丁程序，找到总耗时最少的软件修复方案。

**题解**：
这道题其实不是网络流。(😡)，将错误状态用二进制表示，再转化为十进制数字来表示该状态，补丁作为边来连接节点（依靠 **|，&，^** 等位运算来判断与操作），跑最短路即可。



## 4、[负载平衡问题](https://www.luogu.com.cn/problem/P4016)

**题意**：
$G$ 公司有 $n$ 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 $n$ 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。

**题解**：
先对所有仓库的货物数量求和，求出仓库最后应当由的库存数量。
1、所有仓库与源点建立流量为**库存数量**，权值为 $0$ 的边。
2、所有仓库与汇点建立流量为**平均库存数量**，权值为 $0$ 的边。
3、相邻仓库之间建立权值为 $INF$ ，权值为 $1$ 的边。
求费用流的费用即可。





























