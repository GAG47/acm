# 网络流

## 最大流

### FF

这是一种时间复杂度为 $O(fm)$ 的算法，$f$ 为最大流。

~~~c++
int n, m, s, t; // s是源点，t是汇点
bool vis[MAXN];
int dfs(int p = s, int flow = INF)
{
    if (p == t)
        return flow; // 到达终点，返回这条增广路的流量
    vis[p] = true;
    for (int eg = head[p]; eg; eg = edges[eg].next)
    {
        int to = edges[eg].to, vol = edges[eg].w, c;
        // 返回的条件是残余容量大于0、未访问过该点且接下来可以达到终点（递归地实现）
        // 传递下去的流量是边的容量与当前流量中的较小值
        if (vol > 0 && !vis[to] && (c = dfs(to, min(vol, flow))) != -1)
        {
            edges[eg].w -= c;
            edges[eg ^ 1].w += c;
            // 这是链式前向星取反向边的一种简易的方法
            // 建图时要把cnt置为1，且要保证反向边紧接着正向边建立
            return c;
        }
    }
    return -1; // 无法到达终点
}
inline int FF()
{
    int ans = 0, c;
    while ((c = dfs()) != -1)
    {
        memset(vis, 0, sizeof(vis));
        ans += c;
    }
    return ans;
}
~~~



### EK

这是一种时间复杂度上限为 $O(nm^2)$ 的算法。

~~~c++
...

struct Edge
{
    ll to,w,nex;
}edge[MAXM];
int head[MAXN],cnt=1;
void add(int from,int to,int w)
{
    edge[++cnt].to=to;
    edge[cnt].w=w;
    edge[cnt].nex=head[from];
    head[from]=cnt;
}

ll n,m,s,t,last[MAXN],flow[MAXN];
inline int bfs()
{
    memset(last,-1,sizeof(last));
    queue<int>que;
    que.push(s);
    flow[s]=INF;
    while(!que.empty())
    {
        int p=que.front();
        que.pop();
        if(p==t) //到达汇点 结束搜索
        {
            break;
        }
        for(int eg=head[p];eg;eg=edge[eg].nex)
        {
            ll to=edge[eg].to,val=edge[eg].w;
            if(val>0 && last[to]==-1) //残余容量大于0且未访问过
            {
                last[to]=eg;
                flow[to]=min(flow[p],val);
                que.push(to);
            }
        }
    }
    return last[t]!=-1;
}
inline ll EK()
{
    ll maxflow=0;
    while(bfs())
    {
        maxflow+=flow[t];
        for(int i=t;i!=s;i=edge[last[i]^1].to)
        {
            edge[last[i]].w-=flow[t]; //保证正反边恰好占据奇偶数
            edge[last[i]^1].w+=flow[t]; //并且不用0 1 （0为边界点）
        }
    }
    return maxflow;
}

void solve()
{
    cin>>n>>m>>s>>t;
    int u,v,w;
    for(int i=1;i<=m;++i)
    {
        cin>>u>>v>>w;
        add(u,v,w);
        add(v,u,0);
    }
    cout<<EK();
}
...
~~~

### Dinic

这是一种时间复杂度上限为 $O(n^2m)$ 的算法，在**稠密图**中，比 $EK$ 算法有更好的效率。

~~~c++
struct Edge
{
    ll to,w,next;
}edge[MAXM];
ll head[MAXN],cnt=1;
void add(int from,int to,ll w)
{
    edge[++cnt].to=to;
    edge[cnt].w=w;
    edge[cnt].next=head[from];
    head[from]=cnt;
}

ll n,m,s,t,lv[MAXN],cur[MAXN]; //lv是层数 cur是当前弧优化
inline bool bfs() //bfs负责分层
{
    memset(lv,-1,sizeof(lv));
    memcpy(cur,head,sizeof(head));
    lv[s]=0;
    queue<int>que;
    que.push(s);
    while(!que.empty())
    {
        int q=que.front();
        que.pop();
        for(int i=head[q];i;i=edge[i].next)
        {
            int to=edge[i].to,val=edge[i].w;
            if(val>0&&lv[to]==-1) //未更新过深度则更新
            {
                lv[to]=lv[q]+1,que.push(to);
            }
        }
    }
    return lv[t]!=-1;
}
ll dfs(int p=s,ll flow=INF)
{
    if(p==t) return flow;
    ll rmn=flow; //剩余的流量
    for(int i=cur[p];i&&rmn;i=edge[i].next) //没有剩余流量就退出
    {
        cur[p]=i; //当前弧优化
        ll to=edge[i].to,val=edge[i].w;
        if(val>0&&lv[to]==lv[p]+1) //只传向更深的层
        {
            int c=dfs(to,min(val,rmn));
            rmn-=c; //剩余流量减少
            edge[i].w-=c;
            edge[i^1].w+=c;
        }
    }
    if(rmn==flow) lv[p]=0; //如果一点没流出去，在这个dfs内就没必要再访问了
    return flow-rmn; //返回传递出去的流量大小
}
inline ll dinic()
{
    ll ans=0;
    while(bfs())
    {
        ans+=dfs();
    }
    return ans;
}
~~~

### ISAP

## 费用流

### EK+SPFA

~~~c++
int head[MAXN],cnt=1;
struct Edge
{
    int to,w,c,next;
}edge[MAXM*2];
inline void add(int from,int to,int w,int c)
{
    edge[++cnt].to=to;
    edge[cnt].w=w;
    edge[cnt].c=c;
    edge[cnt].next=head[from];
    head[from]=cnt;
}

int n,m,s,t,last[MAXN],flow[MAXN],inq[MAXN],dist[MAXN];
queue<int>que;
bool SPFA()
{
    while(!que.empty()) que.pop();
    memset(last,-1,sizeof(last));
    memset(inq,0,sizeof(inq));  //是否在队列中
    memset(dist,127,sizeof(dist));  //距离源点的最小距离
    flow[s]=INF;
    dist[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int q=que.front();
        que.pop();
        inq[q]=0;
        for(int i=head[q];i;i=edge[i].next)
        {
            int to=edge[i].to,val=edge[i].w;
            if(val>0&&dist[to]>dist[q]+edge[i].c)
            {
                last[to]=i; //记录上一条边
                flow[to]=min(flow[q],val); //更新下一个点的流量
                dist[to]=dist[q]+edge[i].c;
                if(!inq[to])
                {
                    que.push(to);
                    inq[to]=1;
                }
            }
        }
    }
    return last[t]!=-1;
}
int maxflow,mincost;
inline void MCMF()
{
    while(SPFA())
    {
        maxflow+=flow[t];
        mincost+=dist[t]*flow[t];
        for(int i=t;i!=s;i=edge[last[i]^1].to) 
        {
            edge[last[i]].w-=flow[t];
            edge[last[i]^1].w+=flow[t];
        }   
    }
}
~~~

## 二者取一模型



## 对偶图优化最小割

结论：**求一个网络流的最小割等价于求其对偶图的最短路**
这个结论十分具象且符合直觉，对偶图上的没一个经过所有点的简单路径，必然将原图的节点分为两个集合。这可以由对偶图的性质与定义简单得出。而一般在求解该问题时，不会直接求对偶图上的最短路，而是会把**图外连通块**所化的点分割为起点与终点，然后再跑最短路，一般情况下，时间复杂度可以将一个半级别。
![img](https://cdn.luogu.com.cn/upload/pic/63309.png)

[[ICPC-Beijing 2006] 狼抓兔子(对偶图求最小割板题)](https://www.luogu.com.cn/problem/P4001)



# 网络流24题



## 2、[飞行员配对方案问题](https://www.luogu.com.cn/problem/P2756)

**题意**：第二次世界大战期间，英国皇家空军从沦陷国征募了大量外籍飞行员。由皇家空军派出的每一架飞机都需要配备在航行技能和语言上能互相配合的两名飞行员，其中一名是英国飞行员，另一名是外籍飞行员。在众多的飞行员中，每一名外籍飞行员都可以与其他若干名英国飞行员很好地配合。一共有 $n$ 个飞行员，其中有 $m$ 个外籍飞行员和 $(n - m)$ 个英国飞行员，**外籍飞行员从 $1$ 到 $m$ 编号**，**英国飞行员从 $m + 1$ 到 $n$ 编号**。 对于给定的外籍飞行员与英国飞行员的配合情况，试设计一个算法找出最佳飞行员配对方案，使皇家空军一次能派出最多的飞机。

**题解**：网络流中最基础的一类题目：**二分图最大匹配**。英国和外籍分别作为一个集合，中间的边表示可以很好配合，求最大匹配即可。网络流的求法：所有的英国/外籍与源点建立流量为 $1$ 的边，另一个则与汇点建立流量为 $1$ 的边，求最大流即可。



## 3、[软件补丁问题 ](https://www.luogu.com.cn/problem/P2761)

**题意**：
T 公司发现其研制的一个软件中有 $n$ 个错误，随即为该软件发放了 $m$ 个补丁程序。
每一个补丁程序都有其特定的适用环境，某个补丁只有在软件中包含某些错误而同时又不包含另一些错误时才可以使用。一个补丁在排除某些错误的同时，往往会加入另一些错误。
换句话说，对于任意一个补丁 $i$，都有四个与之相应的集合 $B1_i,B2_i,F1_i$ 和 $F2_i$。仅当软件包含 $B1_i$ 中的所有错误，而不包含 $B2_i$ 中的任何错误时，才可以使用补丁 $i$。补丁 $i$ 将修复软件中的某些错误集合 $F1_i$，而同时加入另一些错误 $F2_i$。另外，运行每个补丁都耗费一定的时间。
试设计一个算法，利用 T 公司提供的 $m$ 个补丁程序将原软件修复成一个没有错误的软件，并使修复后的软件耗时最少。对于给定的 $n$ 个错误和 $m$ 个补丁程序，找到总耗时最少的软件修复方案。

**题解**：
这道题其实不是网络流。(😡)，将错误状态用二进制表示，再转化为十进制数字来表示该状态，补丁作为边来连接节点（依靠 **|，&，^** 等位运算来判断与操作），跑最短路即可。



## 4、[负载平衡问题](https://www.luogu.com.cn/problem/P4016)

**题意**：
$G$ 公司有 $n$ 个沿铁路运输线环形排列的仓库，每个仓库存储的货物数量不等。如何用最少搬运量可以使 $n$ 个仓库的库存数量相同。搬运货物时，只能在相邻的仓库之间搬运。

**题解**：
先对所有仓库的货物数量求和，求出仓库最后应当由的库存数量。
1、所有仓库与源点建立流量为**库存数量**，权值为 $0$ 的边。
2、所有仓库与汇点建立流量为**平均库存数量**，权值为 $0$ 的边。
3、相邻仓库之间建立权值为 $INF$ ，权值为 $1$ 的边。
求费用流的费用即可。



## 5、[运输问题](https://www.luogu.com.cn/problem/P4015)

**题意**：

$W$ 公司有 $m$ 个仓库和 $n$ 个零售商店。第 $i$ 个仓库有 $a_i$ 个单位的货物；第 $j$ 个零售商店需要 $b_j$ 个单位的货物。货物供需平衡，即$\sum\limits_{i=1}^{m}a_i=\sum\limits_{j=1}^{n}b_j$。
从第 $i$ 个仓库运送每单位货物到第 $j$ 个零售商店的费用为 $c_{ij}$ 。
试设计一个将仓库中所有货物运送到零售商店的运输方案，使总运输费用最少。

**题解**：

网络流又一经典模型：**二分图最小权最大匹配**。将仓库当作一集合，零售店当作另一集合，运货作为边，运货费用作用边的权值。派一边费用流即可。



## 5、[(圆桌问题)](https://www.luogu.com.cn/problem/P3254)

**题意**：
有来自 $m$ 个不同单位的代表参加一次国际会议。第 $i$ 个单位派出了 $r_i$ 个代表。
会议的餐厅共有 $n$ 张餐桌，第 $i$ 张餐桌可容纳 $c_i$ 个代表就餐。
为了使代表们充分交流，希望从同一个单位来的代表不在同一个餐桌就餐。请给出一个满足要求的代表就餐方案。

**题解**：
依旧是**二分图求最大匹配**。单位和餐桌分别作为一个集合，单位与源点建立流量为 $r_i$ 的边，餐桌与汇点建立流量为 $c_i$ 的边，每个单位向每个餐桌指出一条流量为 $1$ 的边，跑一遍最大流。如果最大流不等于代表总数目则无方案；反之则有，此时遍历两个集合内的正向边，如果流量为 $0$ 说明该边已经被跑过，记录两个端点，如果分别为单位和餐桌，则记录答案。



## 6、[试题库问题](https://www.luogu.com.cn/problem/P2763)

**题意**：
假设一个试题库中有 $n$ 道试题。每道试题都标明了所属类别。同一道题可能有多个类别属性。现要从题库中抽取 $m$ 道题组成试卷。并要求试卷包含指定类型的试题。试设计一个满足要求的组卷算法。

**题解**：
二分图匹配问题。题目和试卷分别作为一个集合，题目与源点连接流量为 $1$ 的边，类型与汇点连接流量为题目数量的边，在通过题的属性连边，跑最大流即可。如果最大流不等于代表总数目则无方案；反之则有，此时遍历两个集合内的正向边，如果流量为 $0$ 说明该边已经被跑过，记录两个端点，如果分别为题目和试卷，则记录答案。（这道题和上一道基本一模一样）。



## 7、[骑士共存问题](https://www.luogu.com.cn/problem/P3355)

**题意**：

在一个 $n \times n$ 个方格的国际象棋棋盘上，马（骑士）可以攻击的棋盘方格如图所示。棋盘上某些方格设置了障碍，骑士不得进入。

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

对于给定的 $n \times n$ 个方格的国际象棋棋盘和障碍标志，计算棋盘上最多可以放置多少个骑士，使得它们彼此互不攻击。

**题解**：
在不考虑障碍的情况下，容易想到对所有一次可达的格子建边，转化为求图的**最大独立集**；现考虑障碍，只需要不将障碍所在节点放入图中即可。又容易发现，如果把棋盘上的格子分为奇偶两种类型（图中红黄），则马每次移动都会改变自己格子所在的奇偶性质，因而考虑使用**二分图**，将奇偶格子分别作为一个集合，那么有最大独立集=节点数-最小点覆盖，根据**康拓定理**，有最小点覆盖=最大匹配，因而该题可以转化为求**二分图最大匹配**，求出最大流后，答案即为 $ans=n*n-m-maxflow$。

或者用**最小割**的角度理解也可，我们用所有可放置马的节点建边，依旧按照奇偶格子建立二分图：
1、所有奇格子与源点建立流量为 $1$ 的边
2、所有偶格子与汇点建立流量为 $1$ 的边
3、可互相到达的奇偶格子建立流量为 $INF$ 的边
因为最小割=最大流，此时求出最大流即可。为什么？因为最小割是**割去边使得源点汇点分为两个互相不可达的集合的最小代价**，而这个建图方式中奇偶格子之间的边的权值都是无穷，不可能割去，因此只能割去边类型 $1$ 和类型 $2$ ，割去某个节点连接的边表示不取该节点，则剩下的节点保证不存在冲突，且由于最小割是最小代价，因此剩下的节点即是符合条件的最大值。（其实最大匹配就是用最小割的思想罢🤔）



## 9、[方格取数问题](https://www.luogu.com.cn/problem/P2774)

**题意**：
有一个 $m$ 行 $n$ 列的方格图，每个方格中都有一个正整数。现要从方格中取数，使任意两个数所在方格没有公共边，且取出的数的总和最大，请求出最大的和。

**题解**：
相邻格子不能同时取，容易想到对相邻格子建边，然后求总权值和减去最小割即可。



## 10、[汽车加油行驶问题](https://www.luogu.com.cn/problem/P4009)

**题意**：给定一个 $N \times N$ 的方形网格，设其左上角为起点◎，坐标$(1,1)$，$X$ 轴向右为正， $Y$ 轴向下为正，每个方格边长为 $1$ ，如图所示。



 ![](https://cdn.luogu.com.cn/upload/pic/12156.png) 

一辆汽车从起点◎出发驶向右下角终点▲，其坐标为 $(N,N)$。


在若干个网格交叉点处，设置了油库，可供汽车在行驶途中加油。汽车在行驶过程中应遵守如下规则:


1. 汽车只能沿网格边行驶，装满油后能行驶 $K$ 条网格边。出发时汽车已装满油，在起点与终点处不设油库。

2. 汽车经过一条网格边时，若其 $X$ 坐标或 $Y$ 坐标减小，则应付费用 $B$ ，否则免付费用。

3. 汽车在行驶过程中遇油库则应加满油并付加油费用 $A$。

4. 在需要时可在网格点处增设油库，并付增设油库费用 $C$(不含加油费用$A$ )。

5. $N,K,A,B,C$ 均为正整数， 且满足约束: $2\leq N\leq 100,2 \leq K \leq 10$。

设计一个算法，求出汽车从起点出发到达终点所付的最小费用。

**题解**：

容易想到将坐标 $X、Y$ 和油量 $K$ 作为一个状态的三个决定性信息，故使用分层图来表示这三个状态的互相转换。这样只需要在分层图上跑一种算法可以求出从起点到终点的最小费用即可，容易想到使用最短路算法，边的权值即是花费的费用。建边方式（假设现在位于 $(x,y,k)$）：
1.向 $(x+1,y,k-1)$ 与 $(x,y+1,k-1)$ 分别建立权值为 $0$ 的边，向$(x-1,y,k-1)$ 与 $(x,y-1,k-1)$建立权值为 $B$ 的边，注意特判 $k=0$ 的情况即可。。
2.如果 $(x,y)$ 有加油站，则向 $(x,y,K)$ 建立一条权值为 $A$ 的边。
3.向 $(x,y,K)$ 建立一条权值为 $A+C$ 的边。
4.源点为 $(1,1,K)$ ，终点为 $(n,m,\sum_{k=0}^{K}k)$
虽然说是用最短路解的，但是跑费用流也是可以的。



## 11、[家园 / 星际转移问题](https://www.luogu.com.cn/problem/P2754)

**题意**：

> **由于人类对自然资源的消耗，人们意识到大约在 2300 年之后，地球就不能再居住了。于是在月球上建立了新的绿地，以便在需要时移民。令人意想不到的是，2177 年冬由于未知的原因，地球环境发生了连锁崩溃，人类必须在最短的时间内迁往月球。**
> **现有 $n$ 个太空站位于地球与月球之间，且有 $m$ 艘公共交通太空船在其间来回穿梭。每个太空站可容纳无限多的人，而太空船的容量是有限的，第 $i$ 艘太空船只可容纳  $h_i$ 个人。每艘太空船将周期性地停靠一系列的太空站，例如 $(1,3,4)$ 表示该太空船将周期性地停靠太空站 $134134134\dots$。每一艘太空船从一个太空站驶往任一太空站耗时均为 $1$。人们只能在太空船停靠太空站(或月球、地球)时上、下船。**
> **初始时所有人全在地球上，太空船全在初始站。试设计一个算法，找出让所有人尽快地全部转移到月球上的运输方案。**

**题解**：
因为飞船在不同的时间在不同的节点，同一个节点在不同的时间有不同的性质，容易想到将所在的位置 $x$ 和现在的时间 $t$ 作为一个状态的两个决定性信息，那么考虑使用分层图，按照如下方式建边（假设位于空间站 $x$ ，时间为 $t$）:
1.与 $(x,t+1)$ 建立流量为 $INF$ 的边
2.与 $(此时在x的飞船的下一站y,t+1)$建立流量为飞船荷载的边
3.（地球，0）与源点建边，（月球，any）与汇点建边
但是，现在遇到一个问题，时间 $t$ 的上限也就是要求姐的答案，是不确定的，那么要用什么算法去利用这图呢？考虑不断增大 $t$，每次加入对应的边，并跑一遍残量网络流，用 $dinic$ 算法去跑，时间复杂度上也不算很差。(注意，$dinic$ 算法跑稀疏图的残量网络有很好的复杂度，但是可能会导致出现负环，所以需要避免出现新建的边把)



## 12、[太空飞行计划问题](https://www.luogu.com.cn/problem/P2762)

> **W 教授正在为国家航天中心计划一系列的太空飞行。每次太空飞行可进行一系列商业性实验而获取利润。现已确定了一个可供选择的实验集合 $ E = \{ E_1, E_2, \cdots, E_m \} $，和进行这些实验需要使用的全部仪器的集合 $ I = \{ I_1, I_2, \cdots, I_n \} $。实验 $ E_j $ 需要用到的仪器是 $ I $ 的子集 $ R_j \subseteq I $。**
> **配置仪器 $ I_k $ 的费用为 $ c_k $ 美元。实验 $ E_j $ 的赞助商已同意为该实验结果支付 $ p_j $ 美元。W 教授的任务是找出一个有效算法，确定在一次太空飞行中要进行哪些实验并因此而配置哪些仪器才能使太空飞行的净收益最大。这里净收益是指进行实验所获得的全部收入与配置仪器的全部费用的差额。**
> **对于给定的实验和仪器配置情况，编程找出净收益最大的试验计划。**

这道题是**最小割**的经典模型之一：**最大权值闭合图**，即给定一张有向图，每个点都有一个权值（可以为正或负或 ![0](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7))，你需要选择一个权值和最大的子图，使得子图中每个点的后继都在子图中。
该模型的解决方法为：对于正数权值节点，将其与源点连接**流量为权值的边**；对于负数权值节点，将其与汇点连接**流量为权值相反数的边**；原图中的边流量设置为 $\infty$ 。然后跑一遍最大流即可，答案即为**正权值之和减去最大流**。

下面给出**非严谨证明**： 

>1. 每一个符合条件的子图都对应流量网络中的一个割。因为每一个割将网络分为两部分，与 $s$ 相连的那部分满足没有边指向另一部分，于是满足上述条件。这个命题是充要的。
>2. 最小割所去除的边必须与 $s$ 和 $t$ 其中一者相连。因为否则边权是 $\infty$，不可能成为最小割。
>3. 我们所选择的那部分子图，权值和 $=$ 所有正权值之和 $-$ 我们未选择的正权值点的权值之和 $+$ 我们选择的负权值点的权值之和。当我们不选择一个正权值点时，其与 $s$ 的连边会被断开；当我们选择一个负权值点时，其与 $t$ 的连边会被断开。断开的边的边权之和即为割的容量。于是上述式子转化为：权值和 $=$ 所有正权值之和 $-$ 割的容量。
>4. 于是得出结论，最大权值和 $=$ 所有正权值之和 $-$ 最小割 $=$ 所有正权值之和 $-$ 最大流。



## 13、[航空路线问题 ](https://www.luogu.com.cn/problem/P2770)

>**给定一张航空图，图中顶点代表城市，边代表两城市间的直通航线，并且不存在任何两个城市在同一条经线上。现要求找出一条满足下述限制条件的且途经城市最多的旅行路线。**
>
>1. **从最西端城市出发，单向从西向东途经若干城市到达最东端城市，然后再单向从东向西飞回起点（可途经若干城市）。**
>
>2. **除起点城市外，任何城市只能访问一次。**
>
>**对于给定的航空图，试设计一个算法找出一条满足要求的最佳航空旅行路线。**

对于点上的限制，一般考虑将一个点**拆成两个点** $i$ 和 $i+n$，然后节点的入边对 $i$ 建边，出边对 $i+n$ 建边，再在 $i$ 和 $i+n$ 之间建边，并操作该边以满足对于该点的限制（为方便，下称之为**拆点内部边**）。
对于这道题目，因为每个点都只能通过一次，我们将拆点内部边的流量设置为 $1$ (除了首尾两个节点)。题目要求来回一次，因为**首到尾与尾到首等效**，该操作可以等效为从西端城市出发两次，两次旅行路线都不重复，到达最东端城市的最佳路线。那么直接将 $1$ 与 $s$ 建立一条流量为 $2$ 的边，将 $2*n$ 与 $t$ 建立一条流量为 $2$ 的边，跑一遍费用流即可。



## 14、[深海机器人问题](https://www.luogu.com.cn/problem/P4012)

>**深海资源考察探险队的潜艇将到达深海的海底进行科学考察。**
>**潜艇内有多个深海机器人。潜艇到达深海海底后，深海机器人将离开潜艇向预定目标移动。**
>**深海机器人在移动中还必须沿途采集海底生物标本。沿途生物标本由最先遇到它的深海机器人完成采集。**
>**每条预定路径上的生物标本的价值是已知的，而且生物标本只能被采集一次。**
>**本题限定深海机器人只能从其出发位置沿着向北或向东的方向移动，而且多个深海机器人可以在同一时间占据同一位置。**
>**用一个 $P\times Q$ 网格表示深海机器人的可移动位置。西南角的坐标为 $(0,0)$，东北角的坐标为 $(Q,P)$ 。**
>
>**![](https://cdn.luogu.com.cn/upload/pic/12215.png)** 
>
>**给定每个深海机器人的出发位置和目标位置，以及每条网格边上生物标本的价值。**
>**计算深海机器人的最优移动方案， 使深海机器人到达目的地后，采集到的生物标本的总价值最高。**



## 33、[志愿者招募](https://www.luogu.com.cn/problem/P3980)

>**申奥成功后，布布经过不懈努力，终于成为奥组委下属公司人力资源部门的主管。布布刚上任就遇到了一个难题：为即将启动的奥运新项目招募一批短期志愿者。经过估算，这个项目需要 $n$ 天才能完成，其中第 $i$ 天至少需要 $a_i$ 个人。布布通过了解得知，一共有 $m$ 类志愿者可以招募。其中第 $i$ 类可以从第 $s_i$ 天工作到第 $t_i$ 天，招募费用是每人 $c_i$ 元。新官上任三把火，为了出色地完成自己的工作，布布希望用尽量少的费用招募足够的志愿者，但这并不是他的特长！于是布布找到了你，希望你帮他设计一种最优的招募方案。**

这道题建模的难点在于：每个人一次只能干一个连续的时间，也就相当于**一个集合的元素和另一个集合的元素区间对应**。因此，直接通过将人对天数建边是不现实的。
容易想到，如果我们可以使用**负流**的话，只需要将每天都向下一天建立一条流量为 $-a[i]$，权值为 $0$ 的边，然后再在第 $s[i]$ 天到第 $t[i]$ 天建立一条流量为 $INF$，权值为 $c[i]$ 的边，然后在再其上跑**费用流**即可。但是没有办法建立负边，我们得考虑使用一种等价的方式来替代负边的建立。因为费用流是**流量最大**时候的**最小费用**流，因此，我们构造图使得该图的**最大流是一个大值**，然后再将天之间的节点的流量设置为 $INF-a[i]$，这样子为了保证最终流量是最大流，那么志愿者边就必须发力（雾）来**弥补在天数丢失的流量**，以达到负边需要其他地方匀流量的性质。建图后跑一边费用流即可。

























