# 网络流

## 最大流

### FF

这是一种时间复杂度为 $O(fm)$ 的算法，$f$ 为最大流。

~~~c++
int n, m, s, t; // s是源点，t是汇点
bool vis[MAXN];
int dfs(int p = s, int flow = INF)
{
    if (p == t)
        return flow; // 到达终点，返回这条增广路的流量
    vis[p] = true;
    for (int eg = head[p]; eg; eg = edges[eg].next)
    {
        int to = edges[eg].to, vol = edges[eg].w, c;
        // 返回的条件是残余容量大于0、未访问过该点且接下来可以达到终点（递归地实现）
        // 传递下去的流量是边的容量与当前流量中的较小值
        if (vol > 0 && !vis[to] && (c = dfs(to, min(vol, flow))) != -1)
        {
            edges[eg].w -= c;
            edges[eg ^ 1].w += c;
            // 这是链式前向星取反向边的一种简易的方法
            // 建图时要把cnt置为1，且要保证反向边紧接着正向边建立
            return c;
        }
    }
    return -1; // 无法到达终点
}
inline int FF()
{
    int ans = 0, c;
    while ((c = dfs()) != -1)
    {
        memset(vis, 0, sizeof(vis));
        ans += c;
    }
    return ans;
}
~~~



### EK

这是一种时间复杂度上限为 $O(nm^2)$ 的算法。

~~~c++
...

struct Edge
{
    ll to,w,nex;
}edge[MAXM];
int head[MAXN],cnt=1;
void add(int from,int to,int w)
{
    edge[++cnt].to=to;
    edge[cnt].w=w;
    edge[cnt].nex=head[from];
    head[from]=cnt;
}

ll n,m,s,t,last[MAXN],flow[MAXN];
inline int bfs()
{
    memset(last,-1,sizeof(last));
    queue<int>que;
    que.push(s);
    flow[s]=INF;
    while(!que.empty())
    {
        int p=que.front();
        que.pop();
        if(p==t) //到达汇点 结束搜索
        {
            break;
        }
        for(int eg=head[p];eg;eg=edge[eg].nex)
        {
            ll to=edge[eg].to,val=edge[eg].w;
            if(val>0 && last[to]==-1) //残余容量大于0且未访问过
            {
                last[to]=eg;
                flow[to]=min(flow[p],val);
                que.push(to);
            }
        }
    }
    return last[t]!=-1;
}
inline ll EK()
{
    ll maxflow=0;
    while(bfs())
    {
        maxflow+=flow[t];
        for(int i=t;i!=s;i=edge[last[i]^1].to)
        {
            edge[last[i]].w-=flow[t]; //保证正反边恰好占据奇偶数
            edge[last[i]^1].w+=flow[t]; //并且不用0 1 （0为边界点）
        }
    }
    return maxflow;
}

void solve()
{
    cin>>n>>m>>s>>t;
    int u,v,w;
    for(int i=1;i<=m;++i)
    {
        cin>>u>>v>>w;
        add(u,v,w);
        add(v,u,0);
    }
    cout<<EK();
}
...
~~~

### Dinic

这是一种时间复杂度上限为 $O(n^2m)$ 的算法，在**稠密图**中，比 $EK$ 算法有更好的效率。

~~~c++
struct Edge
{
    ll to,w,next;
}edge[MAXM];
ll head[MAXN],cnt=1;
void add(int from,int to,ll w)
{
    edge[++cnt].to=to;
    edge[cnt].w=w;
    edge[cnt].next=head[from];
    head[from]=cnt;
}

ll n,m,s,t,lv[MAXN],cur[MAXN]; //lv是层数 cur是当前弧优化
inline bool bfs() //bfs负责分层
{
    memset(lv,-1,sizeof(lv));
    memcpy(cur,head,sizeof(head));
    lv[s]=0;
    queue<int>que;
    que.push(s);
    while(!que.empty())
    {
        int q=que.front();
        que.pop();
        for(int i=head[q];i;i=edge[i].next)
        {
            int to=edge[i].to,val=edge[i].w;
            if(val>0&&lv[to]==-1) //未更新过深度则更新
            {
                lv[to]=lv[q]+1,que.push(to);
            }
        }
    }
    return lv[t]!=-1;
}
ll dfs(int p=s,ll flow=INF)
{
    if(p==t) return flow;
    ll rmn=flow; //剩余的流量
    for(int i=cur[p];i&&rmn;i=edge[i].next) //没有剩余流量就退出
    {
        cur[p]=i; //当前弧优化
        ll to=edge[i].to,val=edge[i].w;
        if(val>0&&lv[to]==lv[p]+1) //只传向更深的层
        {
            int c=dfs(to,min(val,rmn));
            rmn-=c; //剩余流量减少
            edge[i].w-=c;
            edge[i^1].w+=c;
        }
    }
    if(rmn==flow) lv[p]=0; //如果一点没流出去，在这个dfs内就没必要再访问了
    return flow-rmn; //返回传递出去的流量大小
}
inline ll dinic()
{
    ll ans=0;
    while(bfs())
    {
        ans+=dfs();
    }
    return ans;
}
~~~

### ISAP

## 费用流

### EK+SPFA

~~~c++
int head[MAXN],cnt=1;
struct Edge
{
    int to,w,c,next;
}edge[MAXM*2];
inline void add(int from,int to,int w,int c)
{
    edge[++cnt].to=to;
    edge[cnt].w=w;
    edge[cnt].c=c;
    edge[cnt].next=head[from];
    head[from]=cnt;
}

int n,m,s,t,last[MAXN],flow[MAXN],inq[MAXN],dist[MAXN];
queue<int>que;
bool SPFA()
{
    while(!que.empty()) que.pop();
    memset(last,-1,sizeof(last));
    memset(inq,0,sizeof(inq));  //是否在队列中
    memset(dist,127,sizeof(dist));  //距离源点的最小距离
    flow[s]=INF;
    dist[s]=0;
    que.push(s);
    while(!que.empty())
    {
        int q=que.front();
        que.pop();
        inq[q]=0;
        for(int i=head[q];i;i=edge[i].next)
        {
            int to=edge[i].to,val=edge[i].w;
            if(val>0&&dist[to]>dist[q]+edge[i].c)
            {
                last[to]=i; //记录上一条边
                flow[to]=min(flow[q],val); //更新下一个点的流量
                dist[to]=dist[q]+edge[i].c;
                if(!inq[to])
                {
                    que.push(to);
                    inq[to]=1;
                }
            }
        }
    }
    return last[t]!=-1;
}
int maxflow,mincost;
inline void MCMF()
{
    while(SPFA())
    {
        maxflow+=flow[t];
        mincost+=dist[t]*flow[t];
        for(int i=t;i!=s;i=edge[last[i]^1].to) 
        {
            edge[last[i]].w-=flow[t];
            edge[last[i]^1].w+=flow[t];
        }   
    }
}
~~~

## 二者取一模型



## 对偶图优化最小割

结论：**求一个网络流的最小割等价于求其对偶图的最短路**
这个结论十分具象且符合直觉，对偶图上的没一个经过所有点的简单路径，必然将原图的节点分为两个集合。这可以由对偶图的性质与定义简单得出。而一般在求解该问题时，不会直接求对偶图上的最短路，而是会把**图外连通块**所化的点分割为起点与终点，然后再跑最短路，一般情况下，时间复杂度可以将一个半级别。
![img](https://cdn.luogu.com.cn/upload/pic/63309.png)

[[ICPC-Beijing 2006] 狼抓兔子(对偶图求最小割板题)](https://www.luogu.com.cn/problem/P4001)











