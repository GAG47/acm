# æ ‘åŸºç¡€

**éå†æ–¹å¼**

**å‰åº**éå†ï¼šä¸­å·¦å³ã€‚**ä¸­åº**éå†ï¼šå·¦ä¸­å³ã€‚**ååº**éå†ï¼šå·¦å³ä¸­ã€‚

ä¸­åºéå†å’Œå‰åº/ååºéå†å·²çŸ¥ï¼ŒäºŒå‰æ ‘**å”¯ä¸€ç¡®å®š**ã€‚å‰åºéå†å’Œååºéå†å·²çŸ¥ï¼ŒäºŒå‰æ ‘**æœ‰å¤šç§å¯èƒ½**ï¼šè¿™ç§å¯èƒ½ä¸ªæ•°å¯ä»¥é€šè¿‡æ±‚**åªæœ‰ä¸€ä¸ªå­å¶**çš„èŠ‚ç‚¹æ•°ç¡®å®šï¼Œè€Œåœ¨å‰åºéå†ä¸­æ˜¯ $AB$ åœ¨ååºéå†ä¸­æ˜¯ $BA$ çš„æ˜¯

## æ ‘é‡å¿ƒ

è®¡ç®—ä»¥æ— æ ¹æ ‘æ¯ä¸ªç‚¹ä¸ºæ ¹èŠ‚ç‚¹æ—¶çš„**æœ€å¤§å­æ ‘å¤§å°**ï¼Œè¿™ä¸ªå€¼æœ€å°çš„ç‚¹ç§°ä¸ºæ— æ ¹æ ‘çš„**é‡å¿ƒ**ã€‚
æ ‘é‡å¿ƒçš„äº”ä¸ªæ€§è´¨ï¼š

>1ã€æŸä¸ªç‚¹æ˜¯æ ‘çš„**é‡å¿ƒ**ç­‰ä»·äºå®ƒæœ€å¤§å­æ ‘å¤§å°**ä¸å¤§äº**æ•´æ£µæ ‘å¤§å°çš„**ä¸€åŠ**ã€‚
>2ã€æ ‘**è‡³å¤šæœ‰ä¸¤ä¸ª**é‡å¿ƒã€‚å¦‚æœæ ‘æœ‰ä¸¤ä¸ªé‡å¿ƒï¼Œé‚£ä¹ˆå®ƒä»¬**ç›¸é‚»**ã€‚æ­¤æ—¶æ ‘ä¸€å®šæœ‰**å¶æ•°**ä¸ªèŠ‚ç‚¹ï¼Œä¸”å¯ä»¥è¢«åˆ’åˆ†ä¸ºä¸¤ä¸ªå¤§å°ç›¸ç­‰çš„åˆ†æ”¯ï¼Œæ¯ä¸ªåˆ†æ”¯å„è‡ªåŒ…å«ä¸€ä¸ªé‡å¿ƒã€‚
>3ã€æ ‘ä¸­æ‰€æœ‰ç‚¹åˆ°æŸä¸ªç‚¹çš„**è·ç¦»å’Œ**ä¸­ï¼Œåˆ°é‡å¿ƒçš„è·ç¦»å’Œæ˜¯æœ€å°çš„ï¼›å¦‚æœæœ‰ä¸¤ä¸ªé‡å¿ƒï¼Œé‚£ä¹ˆåˆ°å®ƒä»¬çš„è·ç¦»å’Œä¸€æ ·ã€‚åè¿‡æ¥ï¼Œè·ç¦»å’Œæœ€å°çš„ç‚¹ä¸€å®šæ˜¯é‡å¿ƒã€‚
>4ã€å¾€æ ‘ä¸Šå¢åŠ æˆ–å‡å°‘ä¸€ä¸ª**å¶å­**ï¼Œå¦‚æœåŸèŠ‚ç‚¹æ•°æ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆé‡å¿ƒå¯èƒ½**å¢åŠ **ä¸€ä¸ªï¼ŒåŸé‡å¿ƒ**ä»æ˜¯é‡å¿ƒ**ï¼›å¦‚æœåŸèŠ‚ç‚¹æ•°æ˜¯å¶æ•°ï¼Œé‡å¿ƒå¯èƒ½**å‡å°‘**ä¸€ä¸ªï¼Œå‰©ä¸‹çš„å¦ä¸€ä¸ªé‡å¿ƒ**ä»æ˜¯é‡å¿ƒ**ã€‚
>5ã€æŠŠä¸¤æ£µæ ‘é€šè¿‡ä¸€æ¡è¾¹ç›¸è¿å¾—åˆ°ä¸€æ£µæ–°çš„æ ‘ï¼Œåˆ™æ–°çš„é‡å¿ƒåœ¨**è¾ƒå¤§**çš„ä¸€æ£µæ ‘ä¸€ä¾§çš„**è¿æ¥ç‚¹**ä¸**åŸé‡å¿ƒ**ä¹‹é—´çš„**ç®€å•è·¯å¾„**ä¸Šã€‚å¦‚æœä¸¤æ£µæ ‘å¤§å°ä¸€æ ·ï¼Œåˆ™é‡å¿ƒå°±æ˜¯ä¸¤ä¸ªè¿æ¥ç‚¹ã€‚

~~~c++
int n, sz[MAXN], mss[MAXN]; //nï¼šæ€»ç»“ç‚¹æ•°ï¼ˆè¯·ä»å¤–éƒ¨ä¼ å…¥ï¼‰ï¼Œszï¼šæ ‘çš„å¤§å°ï¼Œmssï¼šæœ€å¤§å­æ ‘å¤§å°
vector<int> ctr; //é‡å¿ƒ
void dfs(int s, int fa = 0) //æ‰¾é‡å¿ƒ
{
    sz[s] = 1, mss[s] = 0;
    for (auto [to, w] : edges[s])
        if (to != fa)
        {
            dfs(to, s);
            mss[s] = max(mss[s], sz[to]);
            sz[s] += sz[to];
        }
    mss[s] = max(mss[s], n - sz[s]); //è€ƒè™‘çˆ¶èŠ‚ç‚¹é‚£ä¸€åŠçš„å­æ ‘å¤§å°
    if (mss[s] <= n / 2) ctr.push_back(s); //è·å–é‡å¿ƒ
}
~~~

ä¾‹é¢˜ï¼š[P1395 ä¼šè®® - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/problem/P1395)

## æ ‘ç›´å¾„

**æ ‘çš„ç›´å¾„æ˜¯æŒ‡æ ‘ä¸­æœ€é•¿çš„ç®€å•è·¯å¾„çš„é•¿åº¦ã€‚** è¿™æ„å‘³ç€è¦æ‰¾åˆ°æ ‘ä¸­ä¸¤ä¸ªæœ€è¿œçš„èŠ‚ç‚¹ä¹‹é—´çš„è·ç¦»ã€‚æ±‚æ ‘çš„ç›´å¾„æœ‰ä¸¤ç§æ–¹æ³•ï¼š**æ·±æœ**å’Œ**æ ‘å½¢dp**ã€‚

**æ³•ä¸€**ï¼šè·‘ä¸¤édfs

å®¹æ˜“è¯æ˜ï¼Œè·ç¦»æ ‘ä¸Šä»»æ„ä¸€ç‚¹**è·ç¦»æœ€è¿œçš„ç‚¹**å¿…ç„¶æ˜¯ç›´å¾„çš„ç«¯ç‚¹ï¼ˆè¯æ˜ç”¨**åè¯æ³•**ï¼Œå‡è®¾è·ç¦»æœ€è¿œçš„ç‚¹ä¸æ˜¯ç›´å¾„ç«¯ç‚¹ï¼Œç”¨è·ç¦»æœ€è¿œçš„ç‚¹æ›¿æ¢ç›´å¾„ç«¯ç‚¹ï¼Œåˆ™å¯ä»¥å¾—åˆ°æ›´é•¿çš„æ ‘ä¸Šç®€å•è·¯å¾„ï¼Œä¸ç›´å¾„å®šä¹‰çŸ›ç›¾ï¼Œå¾—è¯ï¼‰ã€‚é‚£ä¹ˆå–æ ‘ä¸Šä»»æ„ä¸€ç‚¹ï¼Œè·‘ä¸€é $dfs$ æ‰¾åˆ°è·ç¦»æœ€è¿œçš„ç‚¹ï¼Œå³æ˜¯ç›´å¾„çš„ä¸€ä¸ªç«¯ç‚¹ï¼›åœ¨ç”¨è¯¥ç«¯ç‚¹è·‘ä¸€é $dfs$ å³å¯æ±‚åˆ°å¦ä¸€ä¸ªç«¯ç‚¹ã€‚

~~~c++
~~~

**æ³•äºŒ**ï¼šæ ‘å½¢dp

ç›¸æ¯”äºæ·±æœï¼Œæ ‘å½¢dpå¯ä»¥å¤„ç†**è¾¹æƒå€¼ä¸ºè´Ÿæ•°**çš„æƒ…å†µã€‚

**ä¾‹é¢˜**

[Problem - 7452 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=7452)
**å…³é”®è¯**ï¼šæ ‘ä¸Šdfsï¼Œæ±‚æ ‘çš„ç›´å¾„ï¼Œåˆ†ç±»è®¨è®º
**é¢˜ç›®å¤§æ„**ï¼šå¯¹äºä¸€ä¸ªèŠ‚ç‚¹ $i$ çš„æˆé•¿ï¼Œå…ˆå°†è¿™ä¸ªèŠ‚ç‚¹å˜ä¸º $d_i$ è¾¹å‹ï¼ˆ $d_i$ ä¸ºè¿™ä¸ªç‚¹çš„åº¦æ•°ï¼‰ï¼Œç„¶åå°†åŸæœ¬ä¸è¿™ä¸ªç‚¹ç›¸è¿çš„è¾¹éšæœºåŒ¹é…å¤šè¾¹å½¢ä¸Šçš„ç‚¹ï¼Œå†éšæœºåˆ é™¤ç”±è¿™ä¸ªç‚¹å˜åŒ–æˆçš„å¤šè¾¹å½¢ä¸Šçš„ä¸€æ¡è¾¹ã€‚ç‰¹åˆ«çš„ï¼Œå¯¹äºä¸€ä¸ªåº¦æ•°ä¸º0æˆ–1çš„ç‚¹ï¼Œè¿›è¡Œæˆé•¿å°†ä¸ä¼šå‘ç”Ÿå˜åŒ–ã€‚å¯¹äºä¸€æ£µæ ‘çš„æˆé•¿ï¼Œå®šä¹‰ä¸ºæ ‘ä¸Šæ‰€æœ‰çš„èŠ‚ç‚¹è¿›è¡Œä¸€æ¬¡æˆé•¿ã€‚
æ±‚ç»è¿‡ $m$ æ¬¡æˆé•¿åæ‰€ç»™æ ‘æœ€é•¿çš„å¯èƒ½ç›´å¾„é•¿åº¦ï¼ˆè¿™é‡Œå®šä¹‰æ ‘çš„ç›´å¾„çš„é•¿åº¦ä¸ºç›´å¾„ä¸Šçš„ç‚¹æ•°ã€‚ï¼‰
**é¢˜è§£**ï¼šæ³¨æ„åˆ°ï¼Œä¸€ä¸ªåº¦æ•°ä¸º $d$ çš„èŠ‚ç‚¹ï¼Œç»è¿‡ä¸€æ¬¡æˆé•¿ï¼Œå¯¹ä½¿æ ‘å˜é•¿çš„æœ€å¤§è´¡çŒ®ä¸º $d-1$ï¼Œå³å¾—åˆ° $d-1$ ä¸ªåº¦ä¸º $2$ çš„èŠ‚ç‚¹ï¼Œå¹¶ä¸”åœ¨æ–°é“¾çš„æœ«ç«¯é‡æ–°å¾—åˆ°ä¸€ä¸ªä¸åŸèŠ‚ç‚¹åº¦æ•°ç›¸åŒçš„ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆå®¹æ˜“è¯æ˜æ­¤ç§æ‰©å±•æ–¹å¼æ˜¯ä½¿æ ‘æˆé•¿ä¸ºæœ€é•¿æƒ…å†µçš„å…¶ä¸­ä¸€ç§ï¼‰ï¼Œé‚£ä¹ˆä¸€ä¸ªåº¦æ•°ä¸º $d$ çš„èŠ‚ç‚¹ï¼Œç»è¿‡ $m$ æ¬¡æˆé•¿ï¼Œå°±ä¼šè´¡çŒ® $(2^m-1)*(d-1)$ ä¸ªèŠ‚ç‚¹ã€‚é‚£ä¹ˆæ ¹æ® $m$ çš„å¤§å°å°†æƒ…å†µåˆ†ä¸ºä¸¤ç§ï¼š$m$ è¾ƒå°çš„æ—¶å€™ï¼ŒåŒæ—¶è€ƒè™‘ç›´å¾„åŸé•¿å’Œåº¦æ•°çš„å½±å“ï¼ˆå› ä¸ºä¸ä¼šè¢«å–æ¨¡å½±å“å–å¤§å°ï¼‰ï¼›$m$ è¾ƒå¤§çš„æ—¶å€™ï¼Œåªè€ƒè™‘åº¦æ•°çš„å½±å“ï¼ˆå¢é•¿çš„è¶³å¤Ÿå¤šï¼Œä»…è€ƒè™‘å¢é•¿å¹…åº¦ï¼‰ï¼Œä½†æ˜¯æ€»åº¦æ•°å’Œä¸€æ ·çš„æ—¶å€™æ ¹æ®åŸé•¿æ’åºã€‚ç”¨æ±‚æ ‘ç›´å¾„çš„æ–¹æ³•è·‘ä¸¤ç¼– $dfs$ å³å¯ã€‚

~~~c++
ll n,m,deg[MAXN],rt,d[MAXN],dep[MAXN];
//deg-åº¦æ•° d-deg-1çš„å’Œ dep-èŠ‚ç‚¹æ•°ç›®å’Œ
vector<int>G[MAXN];
void init()
{
	cin>>n>>m;
	for(int i=1;i<=n;++i){
		G[i].clear();
		deg[i]=d[i]=dep[i]=0;
	}
}
ll cal(int s)
{
	ll w=1e9;
	if(m<30) w=qpow(2,m)-1; //mè¾ƒå°çš„æ—¶å€™
	return 1ll*w*(d[s]-1)+dep[s];	
}
void dfs(int s,int fa=0)
{
	if(cal(s)>cal(rt)) rt=s;
	for(auto to:G[s]){
		if(to==fa) continue;
		d[to]=deg[to]-1+d[s];
		dep[to]=dep[s]+1;
		dfs(to,s);
	}
}
void solve()
{
	for(int i=1;i<n;++i){
		int u=read(),v=read();
		G[u].push_back(v);
		G[v].push_back(u);
		deg[u]++,deg[v]++;
	}
	rt=1;
	d[1]=deg[1]-1;
	dep[1]=1;
	dfs(1,1);
	d[rt]=deg[rt]-1;
	dep[rt]=1;
	dfs(rt);
	ll ans=(((qpow(2,m)-1)*d[rt])%mode+dep[rt])%mode;
	cout<<ans<<'\n';
	return;
}
~~~





# æœ€è¿‘å…¬å…±ç¥–å…ˆ(LCA)

æœ´ç´ çš„åšæ³•ï¼Œå…ˆé€šè¿‡dfsæ±‚å‡ºæ¯ä¸ªç‚¹çš„æ·±åº¦ã€‚

å†å°†è¾ƒä½çš„ç‚¹å‘ä¸Šçˆ¬ç›´è‡³ä¸é›¶ã€å¦ä¸€ç‚¹åŒé«˜ã€‚ä¸€èµ·å‘ä¸Šçˆ¬ç›´è‡³æ‰¾åˆ°LCAã€‚æŸ¥è¯¢çš„æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚

~~~c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int MAXN = 100100;

int N, M, p;
vector <int> G[MAXN];
int dep[MAXN], fa[MAXN];
bool vis[MAXN];

void dfs(int cur, int fath)   //dfsä»¥æ±‚å‡ºæ¯ä¸€ä¸ªç‚¹çš„æ·±åº¦
{
	if (vis[cur]) return;
	vis[cur] = true;
	dep[cur] = dep[fath] + 1;
	for (int i = 0; i < G[cur].size(); i++)
		dfs(G[cur][i], cur);
	return;
}

int lca(int a, int b)    //æ±‚lac
{
	if (dep[a] > dep[b]) swap(a, b);        //ä¸å¦¨å‡è®¾aæ¯”è¾ƒæµ…
	while (dep[a] != dep[b]) b = fa[b];     //ä¿è¯åŒç­‰é«˜åº¦
	if (a == b) return a;
	for (int k = dep[a]; k >= 0; k--) {     //ä¸€èµ·å‘ä¸Š
		if (fa[a] != fa[b]) {
			a = fa[a]; b = fa[b];
		}
	}
	return fa[a];
}

int main()
{
	cin >> N >> M;
	for (int i = 1; i <= M; i++) {     //æ„æ ‘
		int u, v; cin >> u >> v;
		G[u].push_back(v);
		fa[v] = u;
	}
	dfs(1, 0);
	cin >> p;
	while (p--) {                 //æ±‚lca
		int u, v;
		cin >> u >> v;
		cout << lca(u, v);
	}
	return 0;
}
~~~

$O(n)$ çš„æ—¶é—´å¤æ‚åº¦æ˜¾ç„¶å¾ˆå®¹æ˜“è¶…æ—¶ï¼Œå¯ä»¥ä½¿ç”¨å€å¢çš„ç®—æ³•ä½¿æ—¶é—´å¤æ‚åº¦é™ä¸º $O(logn)$ ã€‚

~~~c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int MAXN = 5e5 + 10;

int N, M, S;
int fa[MAXN][25], dep[MAXN], lg[MAXN], vis[MAXN];
//faä¸­ç¬¬äºŒé¡¹çš„å¸¸æ•°ä¸»è¦æ˜¯æ ¹æ®æ•°æ®èŒƒå›´å†³å®šï¼Œä¸€èˆ¬æƒ…å†µä¸‹25è¶³å¤Ÿ
vector <int> G[MAXN];

void dfs(int s, int fath = 0)
{
	if (vis[s]) return;
	vis[s] = true;
	dep[s] = dep[fath] + 1;
	fa[s][0] = fath;
	for (int i = 1; i <= lg[dep[s]]; i++) {
		fa[s][i] = fa[fa[s][i - 1]][i - 1];
	}
    //å€å¢çš„ä¸»è¦æ€æƒ³
	for (int i = 0; i < G[s].size(); i++) {
		dfs(G[s][i], s);
	}
	return;
}

int lca(int a, int b)
{
	if (dep[a] > dep[b]) swap(a, b);
	while (dep[a] != dep[b]){
        b = fa[b][lg[dep[b] - dep[a]]];
	}
	if (a == b) return a;
	for (int k = lg[dep[a]]; k >= 0; k--) {
		if (fa[a][k] != fa[b][k])
			a = fa[a][k], b = fa[b][k];
	}
	return fa[a][0];
}

int main()
{
	cin >> N >> M >> S;
	for (int i = 1; i < N; i++) {
		int u, v;
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	lg[1] = 0; for (int i = 2; i <= N; i++) lg[i] = lg[i >> 1] + 1;
	dfs(S);
	for (int i = 1; i <= M; i++) {
		int u, v;
		cin >> u >> v;
		cout << lca(u, v) << '\n';
	}
	return 0;
}
~~~

**ä¾‹é¢˜**

>[Problem - 2006B - Codeforces](https://codeforces.com/problemset/problem/2006/B)

**é¢˜æ„**ï¼šç»™å‡ºä¸€æ£µæ ‘ï¼ŒèŠ‚ç‚¹æŒ‰ $dfs$ åº**æ’åº**ï¼Œå¼€å§‹æ—¶ç»™å‡ºæ ‘ä¸Šæ‰€æœ‰è¾¹çš„æƒå€¼å’Œï¼Œæ¯æ¡è¾¹çš„å…·ä½“æƒå€¼æ˜¯æœªçŸ¥çš„ï¼Œç°é€ä¸€ç»™å‡ºæ¯æ¡è¾¹çš„æƒå€¼ï¼Œå¹¶ç»™å‡ºæ¯æ¬¡ç¡®è®¤ä¸€æ¡è¾¹æƒå€¼åçš„ $\sum_{i=1}^{i=n} dis(i,i\mod n + 1)$  çš„æœ€å¤§å€¼ã€‚
**é¢˜è§£**ï¼šç”± $dfs$ åºçš„æ€§è´¨å®¹æ˜“å‘ç°ï¼Œæ¯æ¡è¾¹å¯¹ $dis$ çš„ç»“æœ**æœ€å¤šåªæœ‰ä¸¤æ¬¡è´¡çŒ®**ï¼Œä¸€æ¬¡æ˜¯**ç›¸é‚»èŠ‚ç‚¹**ï¼Œä¸€æ¬¡æ˜¯**è¯¥è¾¹æ·±åº¦è¾ƒå¤§çš„é‚»ç‚¹æ‰€åœ¨å­æ ‘çš„ dfs åºæœ€å¤§çš„ç‚¹ä¸å­æ ‘å¤–ä¸€ç‚¹çš„ç®€å•è·¯å¾„**ã€‚å› æ­¤ï¼Œæ¯ç¡®å®šä¸€æ¡è¾¹ï¼Œéƒ½ä¼šå¯¼è‡´**ä¸åŒ…å«è¿™æ¡è¾¹**çš„ $dis$ å€¼å‡å°‘è¾¹çš„æƒå€¼ï¼›è€Œ**åŒ…å«è¯¥è¾¹**çš„åˆ™ä¸å—å½±å“ï¼Œç›´åˆ°è¯¥ç®€å•è·¯å¾„ä¸Šçš„æ‰€æœ‰è¾¹çš„æƒå€¼éƒ½ç¡®å®šï¼Œæ­¤æ—¶ $dis$ ç¡®å®šã€‚
**ä»£ç **ï¼šè¿™ä¸ªä»£ç å€Ÿé‰´äº†cfçš„é¢˜è§£ï¼Œååˆ†ç²¾å·§ï¼Œæˆ‘è‡ªå·±å†™ç»å¯¹å†™ä¸äº†è¿™ä¹ˆç®€å•ï¼Œå€¼å¾—å­¦ä¹ ã€‚

~~~c++
...
//è¾¹ç”¨æ·±åº¦å¤§çš„é‚»ç‚¹è¡¨ç¤º
// fa-çˆ¶èŠ‚ç‚¹ï¼Œdpe-æ·±åº¦ï¼Œc1-æŸæ¡è¾¹å¯¹åº”æœ‰è´¡çŒ®çš„å…¶ä¸€ç®€å•è·¯å¾„çš„èµ·ç‚¹ï¼Œc2-å…¶äºŒ len-æŸæ¡ç®€å•è·¯å¾„è¿˜æœ‰å¤šå°‘æœªç¡®å®šæƒå€¼çš„è¾¹å­˜åœ¨
ll w,n,fa[MAXN],dep[MAXN],c1[MAXN],c2[MAXN],len[MAXN];
void solve()
{
    cin>>n>>w;
    for(int i=1;i<=n;++i){
        c1[i]=c2[i]=len[i]=dep[i]=0;
    }
    for(int i=2;i<=n;++i){
        cin>>fa[i];
        dep[i]=dep[fa[i]]+1;
    }
    for(int i=1,x,y;i<=n;++i){
        x=i,y=(i==n?1:i+1);
        while(x!=y){ //lca
            if(dep[y]>dep[x]) swap(x,y);
            (c1[x]?c2[x]:c1[x])=i;
            ++len[i];
            x=fa[x];
        }
    }
    ll sum=0,sur=n; //sur-è¿˜æœ‰å¤šå°‘ä¸ªè·¯å¾„æ˜¯æœ‰ä¸ç¡®å®šè¾¹çš„
    for(int i=1;i<n;++i){
        ll x,tmpw;
        cin>>x>>tmpw;
        sum+=tmpw;
        if((--len[c1[x]])==0) --sur;
        if((--len[c2[x]])==0) --sur;
        cout<<sum*2+sur*(w-sum)<<" ";
    } cout<<'\n';
    return;
}

int main()
{
    //std::ios::sync_with_stdio(false);
    int t=1;
	cin>>t;
    while(t--){
        solve();
    }
}
~~~





# é‡é“¾å‰–åˆ†

åŸºæœ¬æ€è·¯ï¼šä¸€ç§å¯¹æ ‘ä¸­å…ƒç´ è¿›è¡Œåˆ†ç±»çš„ä¸€ç§æ–¹å¼ã€‚å°†æ¯ä¸ªèŠ‚ç‚¹ä¸­èŠ‚ç‚¹æœ€å¤šçš„å­æ ‘ç§°ä¸º**é‡å­èŠ‚ç‚¹**ï¼Œå…¶ä»–çš„ç§°ä¸º**è½»å­èŠ‚ç‚¹**ã€‚é‚£ä¹ˆä»æ ¹å¼€å§‹ï¼Œæ‰€æœ‰çš„èŠ‚ç‚¹éƒ½æŒ‡å‘é‡å­èŠ‚ç‚¹ï¼Œå°±ä¼šå½¢æˆä¸€æ¡æ¡**é“¾**ï¼Œå³é‡é“¾å‰–åˆ†ã€‚
é‡é“¾å‰–åˆ†æœ‰ä¸€ä¸ªé‡è¦çš„æ€§è´¨ï¼š**å¯¹äºèŠ‚ç‚¹æ•°ä¸º $ğ‘›$ çš„æ ‘ï¼Œä»ä»»æ„èŠ‚ç‚¹å‘ä¸Šèµ°åˆ°æ ¹èŠ‚ç‚¹ï¼Œç»è¿‡çš„è½»è¾¹æ•°é‡ä¸è¶…è¿‡ $logâ¡ğ‘›$** ã€‚ï¼ˆè¿™ä¸ªç»“è®ºä¼šåœ¨**æ ‘ä¸Šå¯å‘å¼åˆå¹¶**ä¸­ç”¨åˆ°ï¼‰ã€‚

> è¿™æ˜¯å› ä¸ºï¼Œå¦‚æœä¸€ä¸ªèŠ‚ç‚¹è¿å‘çˆ¶èŠ‚ç‚¹çš„è¾¹æ˜¯è½»è¾¹ï¼Œå°±å¿…ç„¶å­˜åœ¨å­æ ‘ä¸å°äºå®ƒçš„å…„å¼ŸèŠ‚ç‚¹ï¼Œé‚£ä¹ˆçˆ¶èŠ‚ç‚¹å¯¹åº”å­æ ‘çš„å¤§å°ä¸€å®šè¶…è¿‡è¯¥èŠ‚ç‚¹çš„ä¸¤å€ã€‚æ¯ç»è¿‡ä¸€æ¡è½»è¾¹ï¼Œå­æ ‘å¤§å°å°±ç¿»å€ï¼Œæ‰€ä»¥æœ€å¤šåªèƒ½ç»è¿‡ $logâ¡ğ‘›$ æ¡ã€‚

![img](https://pic1.zhimg.com/80/v2-4a2b4cb96b4ce1f40595e0e61ff06fd8_720w.webp)

ç¬¬ä¸€æ¬¡ $dfs$ï¼Œæ±‚å‡ºæ¯ä¸ªèŠ‚ç‚¹çš„**å­æ ‘å¤§å°**ã€**çˆ¶èŠ‚ç‚¹**ã€**é‡å­èŠ‚ç‚¹**ã€‚åŸºæœ¬æ€è·¯ä¸æ±‚æ ‘çš„é‡å¿ƒä¸€è‡´ã€‚

~~~c++
void dfs1(int s, int h = 1)
{
	int size = 1, ma = 0;
	dep[s] = h;
	for (auto q : G[s]) {
		if (!dep[q]) {
			dfs1(q, h + 1);
			fa[q] = s;
			size += sz[q];
			if (sz[q] > ma) {
				ma = sz[q];
				hson[s] = q;
			}
		}
	}
	sz[s] = size;
}
~~~

ç¬¬äºŒæ¬¡ $dfs$ï¼Œæ±‚å‡ºæ¯ä¸€ä¸ªèŠ‚ç‚¹çš„é“¾å¤´

~~~c++
void dfs2(int s)
{
	for (auto q : G[s]) {
		if (!top[q]) {
			if (hson[s] == q) {
				top[q] = top[s];
			}
			else {
				top[q] = q;
			}
			dfs2(q);
		}
	}
}
~~~

## æ±‚LCA

~~~c++
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
const int MAXN = 5e5 + 10;

int N, M, S;
vector <int> G[MAXN];

int fa[MAXN], dep[MAXN], sz[MAXN], hson[MAXN], top[MAXN];
void dfs1(int s, int h = 1)
{
	int size = 1, ma = 0;
	dep[s] = h;
	for (auto q : G[s]) {
		if (!dep[q]) {
			dfs1(q, h + 1);
			fa[q] = s;
			size += sz[q];
			if (sz[q] > ma) {
				ma = sz[q];
				hson[s] = q;
			}
		}
	}
	sz[s] = size;
}
void dfs2(int s)
{
	for (auto q : G[s]) {
		if (!top[q]) {
			if (hson[s] == q) {
				top[q] = top[s];
			}
			else {
				top[q] = q;
			}
			dfs2(q);
		}
	}
}

int lca(int a, int b)
{
	while (top[a] != top[b]) {
		if (dep[top[a]] > dep[top[b]]) {
			a = fa[top[a]];
		}
		else {
			b = fa[top[b]];
		}
	}
	return dep[a] > dep[b] ? b : a;
}

int main()
{
	cin >> N >> M >> S;
	for (int i = 1; i < N; i++) {
		int u, v;
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	dfs1(S);
	top[S] = S;
	dfs2(S);
	for (int i = 1; i <= M; i++) {
		int u, v;
		cin >> u >> v;
		cout << lca(u, v) << "\n";
	}
	return 0;
}
~~~

## +æ•°æ®ç»“æ„

é€šè¿‡æ±‚ $lca$ å¯ä»¥å¿«é€Ÿå¾—åˆ°æ ‘ä¸Šä¸¤ä¸ªç‚¹ä¹‹é—´çš„ç®€å•è·¯å¾„çš„é•¿åº¦ï¼Œåªéœ€è¦å°†æ·±åº¦ç›¸å‡å†ç›¸åŠ å³å¯ã€‚
ç°åœ¨å°†é—®é¢˜æ‰©å±•ï¼šæ¯ä¸ªç‚¹éƒ½æœ‰æƒå€¼ï¼Œè¦å¯¹è¯¥æ ‘è¿›è¡Œä¸¤ä¸ªæ“ä½œï¼šä¿®æ”¹ç‚¹ $x,y$ ä¹‹é—´æ‰€æœ‰ç‚¹çš„æƒå€¼ï¼›æ±‚ç‚¹ $x,y$ ä¸ºç«¯ç‚¹çš„ç®€å•è·¯å¾„çš„æƒå€¼å’Œã€‚
åˆæ­¥æ¥çœ‹ï¼Œè¿™æœ‰ä¸€ç‚¹ç±»ä¼¼äº**çº¿æ®µæ ‘**çš„åŒºé—´ä¿®æ”¹å’ŒåŒºé—´æŸ¥è¯¢ï¼Œæˆ‘ä»¬è€ƒè™‘å°†æ ‘ä¸Šçš„èŠ‚ç‚¹åˆ’åˆ†ä¸º**ä¸€ä¸ªä¸ªè¿ç»­çš„åŒºé—´**ï¼Œæ°å¥½é‡é“¾å‰–åˆ†å°†æ ‘åˆ’åˆ†ä¸ºäº†ä¸€æ¡æ¡é“¾ã€‚å› æ­¤å¯ä»¥ä½¿ç”¨æ ‘é“¾å‰–åˆ†+çº¿æ®µæ ‘çš„æ–¹å¼æ¥è§£å†³ä¸Šè¿°é—®é¢˜ã€‚

~~~c++
~~~



æ¿å­ï¼š[P3384 ã€æ¨¡æ¿ã€‘é‡é“¾å‰–åˆ†/æ ‘é“¾å‰–åˆ† - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/problem/P3384)

~~~c++
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+10;
const int MAXM = 1e5+10;
const int INF = 0x7fffffff;
const long long inf = 1e18;
typedef long long ll;
const int dx[] = { -1,0,1,0 }, dy[] = { 0,1,0,-1 };
#define lowbit(x) x&(-x)
#define debug(x) cout<<"?"<<x<<"?\n";
inline int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch>'9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - 48; ch = getchar(); }
    return x * f;
}

int n,m,r,mode,w[MAXN];
vector<int>G[MAXN];

//é‡é“¾å‰–åˆ†éƒ¨åˆ†
int fa[MAXN],dep[MAXN],sz[MAXN],hson[MAXN],top[MAXN];
void dfs1(int s,int d=1)
{
    int size=1,ma=0;
    dep[s]=d;
    for(auto to:G[s]){
        if(!dep[to]){
            dfs1(to,d+1);
            fa[to]=s;
            size+=sz[to];
            if(sz[to]>ma)
                hson[s]=to,ma=sz[to];
        }
    }
    sz[s]=size;
}
int cnt=0,dfsn[MAXN],rdfsn[MAXN];
void dfs2(int s)
{
    dfsn[s]=++cnt;
    if(hson[s]!=0)
    {
        top[hson[s]]=top[s];
        dfs2(hson[s]);
    }
    for(auto to:G[s])
    {
        if(!top[to])
        {
            top[to]=to;
            dfs2(to);
        }
    }
    rdfsn[s]=cnt;
}

//çº¿æ®µæ ‘éƒ¨åˆ†
ll a[MAXN];
ll tree[MAXN * 4], lazy[MAXN * 4];
void build(ll p = 1, ll l = 1, ll r = n)
{
	if (l == r) tree[p] = a[l];
	else {
		ll mid = (l + r) / 2;
		build(p * 2, l, mid);
		build(p * 2 + 1, mid + 1, r);
		tree[p] = tree[p * 2] + tree[p * 2 + 1];
        tree[p]%=mode;
	}
	return;
}
inline void push_down(ll p, ll len)
{
	lazy[p * 2] += lazy[p];
	lazy[p * 2 + 1] += lazy[p];
    lazy[p*2]%=mode;
    lazy[p*2+1]%=mode;
	tree[p * 2] += (len - len / 2) * lazy[p];
	tree[p * 2 + 1] += lazy[p] * (len / 2);
    tree[p*2]%=mode;
    tree[p*2+1]%=mode;
	lazy[p] = 0;
	return;
}
void update(ll cl, ll cr, ll d, ll p = 1, ll l = 1, ll r = n)
{
	if (l > cr || r < cl) return;
	else if (l >= cl && r <= cr) {
		tree[p] += d * (r - l + 1);
        tree[p]%=mode;
		if (l < r) lazy[p] = (lazy[p]+d)%mode;
	}
	else {
		ll mid = (l + r) / 2;
		push_down(p, r - l + 1);
		update(cl, cr, d, p * 2, l, mid);
		update(cl, cr, d, p * 2 + 1, mid + 1, r);
		tree[p] = (tree[p * 2] + tree[p * 2 + 1])%mode;
	}
	return;
}
ll ask(ll cl, ll cr, ll p = 1, ll l = 1, ll r = n)
{
	if (l > cr || r < cl) return 0;
	else if (l >= cl && r <= cr) return tree[p];
	else {
		ll mid = (l + r) / 2;
		push_down(p, r - l + 1);
		return (ask(cl, cr, p * 2, l, mid) + ask(cl, cr, p * 2 + 1, mid + 1, r))%mode;
	}
}

//å¿«é€Ÿæ”¹å˜/æ±‚æ ‘ä¸Šå€¼éƒ¨åˆ†
void update_path(int x,int y,int z)
{
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]])
            swap(x,y);
        update(dfsn[top[x]],dfsn[x],z);
        x=fa[top[x]];
    }
    if(dep[x]<dep[y]) swap(x,y);
    update(dfsn[y],dfsn[x],z);
}
ll ask_path(int x,int y)
{
    ll ans=0;
    while(top[x]!=top[y])
    {
        if(dep[top[x]]<dep[top[y]]) swap(x,y);
        ans+=ask(dfsn[top[x]],dfsn[x]);
        ans%=mode;
        x=fa[top[x]];
    }
    if(dep[x]<dep[y]) swap(x,y);
    ans+=ask(dfsn[y],dfsn[x]);
    return ans%mode;
}
void update_subtree(int x,int z)
{
    update(dfsn[x],rdfsn[x],z);
}
ll ask_subtree(int x)
{
    return ask(dfsn[x],rdfsn[x]);
}

void solve()
{
    cin>>n>>m>>r>>mode;
    for(int i=1;i<=n;++i)
    {
        cin>>w[i];
    }
    for(int i=1;i<n;++i)
    {
        int u=read(),v=read();
        G[u].push_back(v);
        G[v].push_back(u);
    }

    dfs1(r);
    top[r]=r;
    dfs2(r);
    for(int i=1;i<=n;++i)
    {
        a[dfsn[i]]=w[i];
    }
    build();

    for(int i=1;i<=m;++i)
    {
        int op=read(),x=read();
        if(op==1)
        {
            int y=read(),z=read();
            update_path(x,y,z);
        }
        if(op==2)
        {
            int y=read();
            cout<<ask_path(x,y)%mode<<'\n';
        }
        if(op==3)
        {
            int z=read();
            update_subtree(x,z);
        }
        if(op==4)
        {
            cout<<ask_subtree(x)%mode<<'\n';
        }
    }
    return;
}

int main()
{
    int t=1;
    //cin>>t;
    while(t--)
    {
        solve();
    }
}
~~~



# é•¿é“¾å‰–åˆ†

**é•¿é“¾å‰–åˆ†**ä¸é‡é“¾å‰–åˆ†ååˆ†ç›¸ä¼¼ï¼Œåªéœ€å°†é‡å­èŠ‚ç‚¹çš„å®šä¹‰è½¬åŒ–ä¸ºé•¿åº¦æœ€é•¿çš„å­èŠ‚ç‚¹å³å¯ã€‚

é•¿é“¾å‰–åˆ†çš„ä¸¤ä¸ªæ€§è´¨ï¼š
**ä»»æ„èŠ‚ç‚¹ p çš„ k çº§ç¥–å…ˆ q æ‰€åœ¨çš„é“¾çš„é•¿åº¦ä¸€å®šå¤§äº k** ã€‚é€šè¿‡é•¿é“¾å‰–åˆ†çš„æ€§è´¨å®¹æ˜“è¯æ˜ï¼šåŠ å…¥ $p$ ä¸ $q$ åœ¨åŒä¸€æ¡é“¾å†…ï¼Œåˆ™è¯¥æ¡é“¾çš„é•¿åº¦è‡³å°‘ä¸º $k+1$ ï¼›åŠ å¦‚ $p$ ä¸ $q$ ä¸åœ¨åŒä¸€æ¡é“¾å†…ï¼Œè¯´ $q$ å¿…ç„¶åœ¨æœ‰ä¸€æ¡é•¿åº¦å¤§äº $k$ çš„é‡å­èŠ‚ç‚¹æ‰€åœ¨çš„é“¾ã€‚è¯æ¯•ã€‚
**ä»»æ„èŠ‚ç‚¹ p åˆ°æ ¹èŠ‚ç‚¹æœ€å¤šç»è¿‡** $\sqrt n$ **çº§åˆ«çš„è½»è¾¹**ã€‚å› ä¸ºæ¯ä¸€ä¸ªèŠ‚ç‚¹çš„é“¾å¤´çš„çˆ¶äº²èŠ‚ç‚¹æ‰€åœ¨çš„é“¾ä¸€å®šé•¿äºè¯¥èŠ‚ç‚¹æ‰€åœ¨é“¾ï¼Œåˆ™æ¯ä¸ªèŠ‚ç‚¹å‘ä¸Šè·³è·ƒï¼Œé“¾çš„é•¿åº¦ä¼šæ„æˆä¸€ä¸ªé€’å¢åºåˆ—ï¼Œæ¯æ¬¡åŠ  $1$ æ—¶æƒ…å†µæœ€ç³Ÿï¼Œä¸º $sqrt n$ã€‚

æ¿å­ï¼š

~~~c++
// æ·±åº¦ï¼Œéƒ¨åˆ†é“¾é•¿ï¼Œçˆ¶èŠ‚ç‚¹ï¼Œé‡å„¿å­ï¼Œé“¾å¤´ï¼Œdfsåºï¼Œå­æ ‘æœ€å¤§dfsåºï¼Œdfsåºå¯¹åº”èŠ‚ç‚¹ï¼ˆä¸ä¸€å®šæ¯é“é¢˜éƒ½ä¼šç”¨åˆ°æ‰€æœ‰ï¼‰
int dep[MAXN], len[MAXN], fa[MAXN], hson[MAXN], top[MAXN], dfsn[MAXN], mdfsn[MAXN], node[MAXN], cnt;
void dfs1(int p, int d = 1) {
    len[p] = 1, dep[p] = d;
    for (auto q : edges[p])
        if (!dep[q]) {
            dfs1(q, d + 1);
            fa[q] = p;
            if (len[q] + 1 > len[p])
                hson[p] = q, len[p] = len[q] + 1;
        }
}
void dfs2(int p, int tp) {
    dfsn[p] = ++cnt;
    top[p] = tp;
    node[cnt] = p;
    if (hson[p]) dfs2(hson[p], tp); //ä¿è¯é‡å­èŠ‚ç‚¹ä¼˜å…ˆéå† ä»¥ä¿è¯dfsåºåœ¨ä¸€æ¡é“¾å†…è¿ç»­
    for (auto q : edges[p])
        if (!top[q])
            dfs2(q, q);
    mdfsn[p] = cnt;
}
void cut(int r = 1) {
    dfs1(r);
    dfs2(r, r);
}
~~~

ä¾‹é¢˜ï¼š

[P5903 ã€æ¨¡æ¿ã€‘æ ‘ä¸Š K çº§ç¥–å…ˆ - æ´›è°· | è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)](https://www.luogu.com.cn/problem/P5903)

[Problem - F - Codeforces](https://codeforces.com/contest/1009/problem/F)ï¼š
è¿™é“é¢˜å¯ä»¥ç”¨æ ‘ä¸Šå¯å‘å¼åˆå¹¶ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(nlogn)$ã€‚ä½†æ˜¯è¿™é“é¢˜ä¹Ÿå¯ä»¥ä½¿ç”¨é•¿é“¾å‰–åˆ†ï¼Œç°ä¸å¦¨å®šä¹‰æ•°ç»„ $dp[s][x]$ è¡¨ç¤ºèŠ‚ç‚¹ $s$ çš„å­æ ‘ä¸­åˆ°æ ¹èŠ‚ç‚¹è·ç¦»ä¸º $x$ çš„èŠ‚ç‚¹æ•°ç›®ï¼Œåˆ™å®¹æ˜“æœ‰é€’æ¨æ–¹ç¨‹ï¼š
$$
dp[s][x] = \left\{ \begin{gathered}
  \sum_{s->to}dp[to][x-1],  x>0\hfill \\
  1,x=0 \hfill \\ 
\end{gathered}  \right.
$$

é‚£ä¹ˆä½¿ç”¨ç±»ä¼¼äºæ ‘ä¸Šå¯å‘å¼åˆå¹¶çš„æ€æƒ³ï¼Œå¯¹äº**è½»é“¾ç›´æ¥æš´åŠ›è½¬ç§»**ï¼Œå¯¹äº**é‡é“¾ç›´æ¥ä½¿ç”¨å…¶å†…å­˜ç©ºé—´**ï¼ˆå…·ä½“æ–¹å¼ä¸ºä½¿ç”¨å€’å™çš„ $vector$ å­˜å‚¨ï¼Œç„¶åç›´æ¥ç”¨é‡èŠ‚ç‚¹çš„å­˜å‚¨ç©ºé—´ï¼‰ï¼Œå®ç° $O(1)$ çš„è½¬ç§»ï¼Œå› ä¸ºæ¯æ¡è½»é“¾éƒ½åªä¼šè¢«æš´åŠ›è½¬ç§»ä¸€æ¬¡ï¼Œå› æ­¤æ€»æ—¶é—´å¤æ‚åº¦å°±æ˜¯ $O(n)$ã€‚ç½‘ä¸Šè¿˜æœ‰ä¸€ç§ä½¿ç”¨æŒ‡é’ˆçš„é¢˜è§£ï¼Œä½†æ˜¯ä½¿ç”¨æŒ‡é’ˆæ€»æ˜¯å±é™©çš„ï¼Œå› æ­¤ä¸åœ¨æ­¤ç»™å‡ºã€‚
**æ€»ç»“**ï¼šä¸€èˆ¬æƒ…å†µä¸‹ï¼Œé•¿é“¾å‰–åˆ†çš„æ—¶é—´å¤æ‚åº¦æ˜¯ä¸å¦‚é‡é“¾å‰–åˆ†çš„ï¼Œä½†æ˜¯åœ¨ä¸€äº›ç¥å¥‡çš„æ–¹æ³•ï¼Œé•¿é“¾å‰–åˆ†ä¼šæœ‰å¾ˆå¥½çš„å¤æ‚åº¦ï¼ˆå‰æœ‰é­”æ³•ï¼Œè¯·ä½¿ç”¨é•¿é“¾å‰–åˆ†ï¼‰ã€‚



# æ ‘ä¸Šå¯å‘å¼åˆå¹¶

**æ ‘ä¸Šå¯å‘å¼åˆå¹¶**ï¼Œæ˜¯ä¸€ç§è§£å†³æŸäº›**æ ‘ä¸Šç¦»çº¿é—®é¢˜**çš„ç®—æ³•ï¼Œå°¤å…¶å¸¸è¢«ç”¨äºè§£å†³â€œå¯¹æ¯ä¸ªèŠ‚ç‚¹ï¼Œè¯¢é—®å…³äºå…¶å­æ ‘çš„æŸäº›ä¿¡æ¯â€è¿™æ ·çš„é—®é¢˜ã€‚
å‡è®¾æˆ‘ä»¬è¦å¯¹æ ‘ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹ $p$ æ±‚ $ans[p]$ ï¼Œä¸”è¿™ä¸ª $ğ‘ğ‘›ğ‘ [ğ‘]$ å¯ä»¥é€šè¿‡åˆå¹¶ $ğ‘$ çš„å­èŠ‚ç‚¹çš„æŸäº›ä¿¡æ¯å¾—çŸ¥ï¼Œä¸€èˆ¬æ¥è¯´æˆ‘ä»¬å¯ä»¥ç”¨æ ‘å½¢DPè§£å†³ã€‚ä½†å¦‚æœâ€œå­èŠ‚ç‚¹çš„æŸäº›ä¿¡æ¯â€çš„è§„æ¨¡è¾ƒå¤§ï¼Œç®€å•çš„æ ‘å½¢DPåœ¨æ—¶é—´å’Œç©ºé—´ä¸Šéƒ½å¯èƒ½çˆ†ç‚¸ã€‚æ‰€ä»¥æˆ‘ä»¬ä¸èƒ½å­˜å‚¨æ¯ä¸ªèŠ‚ç‚¹çš„ä¿¡æ¯ï¼Œè€Œæ˜¯è¦å®ç°æŸç§**èµ„æºå¤ç”¨**ã€‚

**ï¼ˆ[CF600E](https://codeforces.com/problemset/problem/600/E)ï¼‰Lomsat gelral**

> You are given a rooted tree with root in vertex 1. Each vertex is coloured in some colour.
> Let's call colour *c* dominating in the subtree of vertex *v* if there are no other colours that appear in the subtree of vertex *v* more times than colour *c*. So it's possible that two or more colours will be dominating in the subtree of some vertex.
> The subtree of vertex *v* is the vertex *v* and all other vertices that contains vertex *v* in each path to the root.
> For each vertex *v* find the sum of all dominating colours in the subtree of vertex *v*.

**é¢˜æ„**ï¼šç»™æ ‘çš„èŠ‚ç‚¹æŸ“è‰²ï¼Œå­æ ‘ä¸­å‡ºç°æœ€å¤šæ¬¡çš„é¢œè‰²ï¼ˆå¯èƒ½æœ‰å¤šä¸ªï¼‰ç§°ä¸ºå é¢†è¯¥å­æ ‘ï¼Œå¯¹æ¯ä¸ªèŠ‚ç‚¹ï¼Œæ±‚å é¢†è¯¥èŠ‚ç‚¹æ‰€å¯¹åº”å­æ ‘çš„é¢œè‰²çš„ç¼–å·ä¹‹å’Œã€‚
åœ¨æœ¬é¢˜ä¸­ï¼Œ $ğ‘ğ‘›ğ‘ [ğ‘]$ è¡¨ç¤ºå é¢† ğ‘ æ‰€å¯¹åº”å­æ ‘çš„é¢œè‰²çš„ç¼–å·ä¹‹å’Œï¼Œæˆ‘ä»¬éœ€è¦å¯¹æ ‘ä¸Šçš„æ¯ä¸ªèŠ‚ç‚¹ $ğ‘$ æ±‚ $ğ‘ğ‘›ğ‘ [ğ‘]$ã€‚è¯šç„¶ï¼Œå¯ä»¥ç»™æ¯ä¸ªèŠ‚ç‚¹ ğ‘ åˆ†é…ä¸€ä¸ªæ¡¶ $ğ‘ğ‘›ğ‘¡[ğ‘]$ ï¼Œè¡¨ç¤ºå…¶å­æ ‘ä¸­å„ä¸ªé¢œè‰²çš„æ•°é‡ï¼Œé€šè¿‡åˆå¹¶ $ğ‘$ çš„å­èŠ‚ç‚¹çš„ä¿¡æ¯å¯ä»¥è®¡ç®— $ğ‘ğ‘›ğ‘¡[ğ‘]$ï¼Œè¿›è€Œç®—å‡º $ğ‘ğ‘›ğ‘ [ğ‘]$ ã€‚ç„¶è€Œï¼Œè¿™æ ·å¤æ‚åº¦å¤ªå¤§äº†ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæˆ‘ä»¬ä¸èƒ½å¯¹æ¯ä¸ªèŠ‚ç‚¹éƒ½ç»´æŠ¤å…¶ä¿¡æ¯ï¼Œè€Œè¦è¿›è¡Œèµ„æºçš„**å¤ç”¨** ã€‚
æœ´ç´ çš„ä¼˜åŒ–æ–¹å¼ï¼Œæ›´æ–°æ¯ä¸ªç‚¹çš„æ—¶å€™éƒ½ç”¨**åŒä¸€ä¸ª**æ¡¶ï¼Œæ¯æ¬¡æ›´æ–°å®Œå°±æ¸…ç©ºã€‚è¿™æ ·å­ç©ºé—´å¤æ‚åº¦åˆæ ¼äº†ï¼Œä½†æ˜¯å¿…ç„¶ä¼š$TLE$ã€‚ä¸éš¾å‘ç°ï¼Œé€’å½’è®¡ç®—èŠ‚ç‚¹ $s$ çš„æ•°æ®åï¼Œå¯ä»¥ä¸æ¸…ç©ºå…¶**æœ€åä¸€ä¸ªå­èŠ‚ç‚¹**å¯¹æ¡¶çš„å½±å“ï¼Œå› ä¸ºå…¶åœ¨è®¡ç®— $s$ å¯¹ $s$ çˆ¶èŠ‚ç‚¹çš„è´¡çŒ®æ—¶ä¹Ÿä¼šäº§ç”Ÿå½±å“ï¼Œå³ä½¿è¢«æ¸…ç©ºä¹Ÿä¼šè¢«é‡æ–°åŠ å…¥ï¼Œè¿™æ ·å­å°±æœ‰äº†ä¸€å®šçš„ä¼˜åŒ–ã€‚å¦‚ä½•ä½¿ä¼˜åŒ–æœ€å¤§ï¼Ÿä»¤æœ€åä¸€ä¸ªå­èŠ‚ç‚¹æœ€å¤§ã€‚å®¹æ˜“æƒ³åˆ°ç”¨**æ ‘é“¾å‰–åˆ†**çš„æ€æƒ³å¿«é€Ÿå¾—åˆ°æ¯ä¸ªèŠ‚ç‚¹çš„é‡å­èŠ‚ç‚¹ï¼Œå°†å…¶ä½œä¸ºä¸æ¸…ç©ºçš„æœ€åä¸€ä¸ªå­èŠ‚ç‚¹ï¼Œç”±äºè¿˜æœ‰ç»“è®ºï¼šå¯¹äºèŠ‚ç‚¹æ•°ä¸º $ğ‘›$ çš„æ ‘ï¼Œä»ä»»æ„èŠ‚ç‚¹å‘ä¸Šèµ°åˆ°æ ¹èŠ‚ç‚¹ï¼Œç»è¿‡çš„è½»è¾¹æ•°é‡ä¸è¶…è¿‡ $logâ¡ğ‘›$ï¼Œå› è€Œæ—¶é—´å¤æ‚åº¦å°±ä¸º $O(nlogn)$ äº†ã€‚
**ä»£ç **ï¼š

~~~c++
//std::ios::sync_with_stdio(false);
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e5+10;
const int MAXM = 1e5+10;
#define ll long long 
#define debug(x) cout<<"?"<<x<<"?\n";
inline int read()
{
    int x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch>'9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - 48; ch = getchar(); }
    return x * f;
}

int n,col[MAXN];
vector<int>G[MAXN];

int dep[MAXN], sz[MAXN], hson[MAXN];
void dfs1(int s, int h = 1)
{
	int size = 1, ma = 0;
	dep[s] = h;
	for (auto q : G[s]) {
		if (!dep[q]) {
			dfs1(q, h + 1);
			size += sz[q];
			if (sz[q] > ma) {
				ma = sz[q];
				hson[s] = q;
			}
		}
	}
	sz[s] = size;
}

ll ans[MAXN],sum,cnt[MAXN],maxn;
void add(int s)
{
    int temp=++cnt[col[s]];
    if(temp>maxn) {
        maxn=temp,sum=col[s];
    } else if(temp==maxn) {
        sum+=col[s];
    }
}
void del(int s)
{
    --cnt[col[s]];
}
void addsubtree(int s,int fa=-1)
{
    add(s);
    for(auto to:G[s])
    {
        if(to!=fa) 
            addsubtree(to,s);
    }
}
void delsubtree(int s,int fa=-1)
{
    del(s);
    for(auto to:G[s])
    {
        if(to!=fa) 
            delsubtree(to,s);
    }
}
void dfs(int s,int fa=-1,bool keep=1)
{
    for(auto to:G[s])
    {
        if(to!=fa&&to!=hson[s])
            dfs(to,s,0);
    }
    if(hson[s]) dfs(hson[s],s,1);
    add(s);
    for(auto to:G[s])
    {
        if(to!=fa&&to!=hson[s])
            addsubtree(to,s);
    }
    ans[s]=sum; //æ›´æ–°ansçš„åœ°æ–¹
    if(!keep){
        delsubtree(s,fa);
        maxn=sum=0;
    }
}

void solve()
{
    n=read();
    for(int i=1;i<=n;++i)
    {
        col[i]=read();
    }
    for(int i=1;i<n;++i)
    {
        int u=read(),v=read();
        G[u].push_back(v);
        G[v].push_back(u);
    }
    dfs1(1);
    dfs(1);
    for(int i=1;i<=n;++i)
    {
        printf("%lld ",ans[i]);
    }
    return;
}

int main()
{
    int t=1;
    //cin>>t;
    while(t--)
    {
        solve();
    }
}
~~~

**ä¾‹é¢˜**

[Problem - 7435 (hdu.edu.cn)](https://acm.hdu.edu.cn/showproblem.php?pid=7435)
å…³é”®å­—ï¼šæ ‘ä¸Šå¯å‘å¼åˆå¹¶ï¼Œæ ‘çŠ¶æ•°ç»„
é¢˜ç›®å¤§æ„ï¼š
é¢˜è§£ï¼š



# ç‚¹åˆ†æ²»

**ç‚¹åˆ†æ²»**ä¸»è¦ç”¨æ¥æ±‚æ ‘ä¸Šè·¯å¾„çš„é—®é¢˜ã€‚

å‡å¦‚è¦éå†ç»Ÿè®¡æ ‘ä¸Šæ¯æ¡è¾¹çš„ä¿¡æ¯ï¼Œæœ´ç´ çš„ç®—æ³•æ˜¯ä¾æ¬¡å¯¹æ¯ä¸€ä¸ªç‚¹è¿›è¡Œ**dfs**ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n^2)$ ã€‚

è€ƒè™‘ä½¿ç”¨åˆ†æ²»ã€‚å°†è·¯å¾„åˆ†ä¸º**ç»è¿‡æŸèŠ‚ç‚¹**ä¸**ä¸ç»è¿‡æŸèŠ‚ç‚¹**çš„ï¼Œç»è¿‡æ ¹èŠ‚ç‚¹çš„éƒ¨åˆ†è½¬åŒ–ä¸º**éå†å­æ ‘**çš„é—®é¢˜å³å¯ï¼›è€Œä¸ç»è¿‡çš„åˆ™å¯ä»¥**é€’å½’**çš„è¿›è¡Œå¤„ç†ï¼Œé€šè¿‡åˆ é™¤åŸæ¥çš„æ ¹èŠ‚ç‚¹ï¼Œå†å¯»æ‰¾æ–°çš„æ ¹èŠ‚ç‚¹ï¼Œé‡å¤ä¸Šè¿°æ“ä½œç›´åˆ°éå†æ‰€æœ‰è¾¹ã€‚ä»è€Œå°†åŸé—®é¢˜å˜ä¸ºä¸€ä¸ªä¸ªç®€å•çš„å­é—®é¢˜ï¼Œé€’å½’å®ç°ï¼Œä»¥æé«˜æ•ˆç‡ã€‚

å¦‚æœæ‰€ç»™çš„æ ‘æ˜¯ä¸€æ¡**é“¾**ï¼Œé€ä¸€çš„åˆ ç‚¹ï¼Œåˆ™æ—¶é—´å¤æ‚åº¦ä¼šé€€åŒ–ä¸º $O(n^2)$ ã€‚å¦‚æœæ¯æ¬¡é€‰å–çš„éƒ½æ˜¯æ ‘çš„**é‡å¿ƒ**ï¼Œåˆ™æ¯æ¬¡åˆ ç‚¹åå¾—åˆ°çš„å¤šæ£µå­æ ‘çš„å¤§å°å‡ä¼šå°äºåŸå­æ ‘çš„ä¸€åŠï¼Œåˆ™æ—¶é—´å¤æ‚åº¦ä¸º $O(nlogn)$ ã€‚

é‚£ä¹ˆç‚¹åˆ†æ²»çš„é¢˜ç›®å°±å¯ä»¥åˆ†ä¸ºå¤§è‡´ä¸‰ä¸ªæ¨¡å—ï¼š

**å¯»æ‰¾æ ‘çš„é‡å¿ƒ**ï¼Œæ¯”è¾ƒçš„æ¨¡æ¿ï¼Œä¸å¤šè§£é‡Šã€‚

~~~c++
void dfs(int s, int fa = 0)  //æŸ¥æ‰¾é‡å¿ƒ
{
	sz[s] = 1;
	int mss = 0;
	for (auto to : G[s]) {
		if (to != fa && !del[to]) {
			dfs(to, s);
			if (ctr != -1) return; //æ‰¾åˆ°é‡å¿ƒå³å¯é€€å‡º
			mss = max(mss, sz[to]);
			sz[s] += sz[to];
		}
	}
	mss = max(mss, n - sz[s]);
	if (mss <= n / 2) {
		ctr = s;
		sz[fa] = n - sz[s]; //æ›´æ–°æ ¹èŠ‚ç‚¹éå†æ—¶å€™çš„çˆ¶èŠ‚ç‚¹çš„æ ‘å¤§å°ï¼Œä»¥ä¾¿åé¢åˆ†æ²»ä½¿ç”¨Â·1
	}
	return;
}
~~~

**å¯¹é—®é¢˜çš„æ±‚è§£**ã€‚æ”¹æ¨¡å—ä»£ç æ ¹æ®é¢˜ç›®è€Œå®šã€‚

**é€’å½’çš„å®ç°**ã€‚å³åˆ é™¤åŸæ ¹èŠ‚ç‚¹ï¼Œåœ¨å­æ ‘ä¸­å¯»æ‰¾æ–°çš„æ ¹èŠ‚ç‚¹å¹¶ç»§ç»­è§£å†³é—®é¢˜ã€‚

~~~c++
void run(int s)
{
	/*
	    ç»Ÿè®¡è¿‡æ ¹èŠ‚ç‚¹çš„ç­”æ¡ˆã€‚
	*/
    //
	
	//ç»Ÿè®¡ä¸ç»è¿‡æ ¹èŠ‚ç‚¹çš„ç­”æ¡ˆ
	del[s] = 1; //å°†æ ¹èŠ‚ç‚¹åˆ é™¤
	for (auto to : G[s]) {  //åˆ æ‰åŸæ¥èŠ‚ç‚¹ï¼Œå¯»æ‰¾æ–°çš„æ ¹èŠ‚ç‚¹
		if (!del[to]) {
			n = sz[to];  //å› ä¸ºåªå†å­æ ‘å†…æ“ä½œï¼Œå› è€Œä¸ä¼šæ”¹å˜å…¶ä»–å­æ ‘ä¸­èŠ‚ç‚¹çš„szå¤§å°
			ctr = -1;  
			dfs(to);
			run(ctr); //è¿›è¡Œä¸‹ä¸€æ¬¡æ“ä½œ
		}
	}
}

int solve()  //è¿›è¡Œç‚¹åˆ†æ²»ã€‚
{
	ctr = -1;
	dfs(1);
	run(ctr);
	return ans; //è¿”å›ç­”æ¡ˆ
}

~~~



ä¾‹é¢˜ï¼š

~~~c++
#include <iostream>
#include <stdio.h>
#include <vector>
#include <stack>
#include <queue>
#include <algorithm>
#include <string>
#include <string.h>
#include <cmath>
#include <set>
#include <map>
using namespace std;
const int MAXN = 1e5 + 10;
const int MAXK = 5e2 + 10;
const int INF = 0x7fffffff;
const int mode = 998244353;
typedef long long ll;
typedef pair <int, int> P;

int n, k, u, v;
vector <int> G[MAXN];
bool del[MAXN];

int sz[MAXN], ctr;
void dfs(int s, int fa = 0)  //æŸ¥æ‰¾é‡å¿ƒ
{
	sz[s] = 1;
	int mss = 0;
	for (auto to : G[s]) {
		if (to != fa && !del[to]) {
			dfs(to, s);
			if (ctr != -1) return; //æ‰¾åˆ°é‡å¿ƒå³å¯é€€å‡º
			mss = max(mss, sz[to]);
			sz[s] += sz[to];
		}
	}
	mss = max(mss, n - sz[s]);
	if (mss <= n / 2) {
		ctr = s;
		sz[fa] = n - sz[s]; //æ›´æ–°æ ¹èŠ‚ç‚¹éå†æ—¶å€™çš„çˆ¶èŠ‚ç‚¹çš„æ ‘å¤§å°
	}
	return;
}

//cnttç”¨æ¥æ„å»ºtempæ•°ç»„ï¼Œtempå­˜å…¥è·¯å¾„é•¿ï¼›
//lensç»´æŠ¤çš„æ˜¯å‰é¢éå†è¿‡çš„å­æ ‘å‡ºç°è¿‡çš„è¾¹é•¿æ•°ç›®ï¼Œcntåˆ™æ˜¯ç­”æ¡ˆï¼›
int cntt = 0, cnt = 0, lens[MAXK], temp[MAXN];
void dfs2(int s, int fa, int len) //éå†å­æ ‘ï¼Œæ±‚ç»è¿‡æ ¹èŠ‚ç‚¹è·¯å¾„ä¸ºkçš„é“è·¯æ•°ç›®
{
	if (len > k) return;
	//å·¦è¾¹æ˜¯åˆ°å…¶ä»–å­æ ‘ï¼Œå³è¾¹æ˜¯åˆ°æ ¹èŠ‚ç‚¹
	cnt += lens[k - len] + (len == k);  //æ›´æ–°ç­”æ¡ˆ
	temp[cntt++] = len;  //å­˜å…¥æ–°çš„è·¯å¾„é•¿
	for (auto to : G[s]) {
		if (!del[to] && to != fa) {
			dfs2(to, s, len + 1);  //ç»§ç»­éå†å­æ ‘
		}
	}
}

void run(int s)
{
	for (auto to : G[s]) {
		if (!del[to]) {
			dfs2(to, s, 1);
			for (int i = 0; i < cntt; ++i) {
				lens[temp[i]]++; //éå†å®Œä¸€ä¸ªå­æ ‘åï¼Œæ›´æ–°è·ç¦»çš„æ•°ç›®ï¼Œä¸ºä¸‹é¢çš„éå†æ‰“å¥½åŸºç¡€
			}
			cntt = 0;
		}
	}
	fill(lens, lens + MAXK, 0); //æ›´æ¢æ ¹èŠ‚ç‚¹æ—¶ä¹Ÿè¦å˜æ¢lensæ•°ç»„
	//ç»Ÿè®¡ä¸ç»è¿‡æ ¹èŠ‚ç‚¹çš„ç­”æ¡ˆ
	del[s] = 1;
	for (auto to : G[s]) {  
		if (!del[to]) {
			n = sz[to];  
			ctr = -1;  
			dfs(to);
			run(ctr);
		}
	}
}

int solve()
{
	ctr = -1;
	dfs(1);
	run(ctr);
	return cnt;
}

int main()
{
	cin >> n >> k;
	for (int i = 1; i < n; i++) {
		cin >> u >> v;
		G[u].push_back(v);
		G[v].push_back(u);
	}
	cout << solve() << '\n';
	return 0;
}
~~~







