# 储存方式

## **邻接矩阵**

因为题目给出的图一般是比较**稀疏**的，故用邻接矩阵的方式存图效率较低。

## **邻接表**

用**vector**进行存图操作。

缺点：常数较大。**寻找反向边**与**删边**操作较为困难。

## **链式前向星**

链式前向星是一种特殊的**边集数组**，我们把边集数组中的每一条边按照起点从小到大排序,如果起点相同就按照终点从小到大排序。

**建立**

~~~c++
struct edge{
    int to,w,next;
}edges[MAXM];
int head[MAXN],cnt;
inline void add(int from,int to,int w)
{
    edges[++cnt].w=w;
    edges[cnt].to=to;
    edges[cnt].next=head[from];
    head[from]=cnt;
}
~~~

邻接表是往后面存图，链式前向星则是往**前面**增加存图。

**遍历**

~~~c++
for (int i=head[p];i;i=edges[i].next){
    cout<<edges[i].to;
}
~~~







# 最短路

![img](https://img-blog.csdnimg.cn/img_convert/45c0b5f04c254019fa1d5dff2647d8c6.png)

当然，多源最短路时间复杂度最小的必然不是 $floyed$ 算法，还有做 $n$ 次 $O(nmlogn)$ 的 $Dijkstra$ 与适用负权的$Johnson$ 算法。

## 单源最短路

### Dijkstra

（有向图版本）

~~~c++
typedef pair<int, int> P;

struct edge {
	int to, cost;
};
int n, m, s;
int d[100010];
vector <edge> G[100010];
priority_queue <P, vector<P>, greater<P>> que;

int main()
{
	cin>>n>>m>>s;
	for (int i = 1; i <= m; i++) {
		edge e; int a;
		cin >> a >> e.to >> e.cost;
		G[a].push_back(e);
	}
	fill(d + 1, d + 1 + n, 2147483647);
	que.push(P(0, s));
	d[s] = 0;
	while (!que.empty()) {
		P p = que.top(); que.pop();
		int v = p.second;
		if (d[v] < p.first) continue;
		for (int i = 0; i < G[v].size() ;i++) {
			edge e = G[v][i];
			if (d[e.to] > d[v] + e.cost) {
				d[e.to] = d[v] + e.cost;
				que.push(P(d[e.to], e.to));
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		cout << d[i] << " ";
	}
	return 0;
}
~~~

### Bellman-Ford

Bellman-Ford 算法采用**动态规划**进行设计，实现的**时间复杂度**为 O(V*E)，其中 V 为顶点数量，E 为边的数量。

### SPFA

SPFA的基本思路为：维护一个队列，用于维护待更新的节点。每次取出队列的首个节点，使用该节点更新其相邻节点的最短路径，如果相邻节点被更新且不再队列中，则将其加入队列。初始加入起始节点，然后循环上述操作直到队列为空。

可用数学归纳法证明该算法的正确性。在源点加入队列时，源点作为第一个节点的最短路已更新结束；假设距离源点路径数目小于等于为 $k$ 的节点的最短路均已更新，则下一轮必然可以更新所有路径数目为 $k+1$ 的节点（注意这里是路径数目而非路径长度），证毕。

时间复杂度上，平均复杂度为 $O(kE)$，其中 $k$ 为常数，但极端复杂度为 $O(VE)$,

~~~c++
bool inque[MAXN];
int dist[MAXN],cnt[MAXN];
bool SPFA(int s)
{
    memset(dist,127,sizeof(dist));
    queue<int>que;
    que.push(s);
    dist[s]=0;
    while(!que.empty())
    {
        int q=que.front();
        que.pop();
        if(cnt[q]>n){
            return false;
        }
        inque[q]=false;
        for(auto e:G[q]){
            int to=e.to;
            if(dist[to]>dist[q]+e.w){
                dist[to]=dist[q]+e.w;
                if(!inque[to]){
                    que.push(to);
                    inque[to]=true;
                    cnt[to]++;
                }
            }
        }
    }
    return true;
}
~~~

[Currency Exchange - OpenJ_Bailian 1860 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/OpenJ_Bailian-1860)

## 多源最短路

### Floyed

用来求**无向图**的多源最短路。

不妨令 $d(i,j)$ 表示两个节点的路径长度，其中，假如两点之间有边，则初始化为对应权值，否则初始化为无穷，注意 $d(i,i)=0$ 。
$floyed$ 的基本思想在于**逐步扩大中间点的范围**，假如不考虑任何经过中间节点的情况，则 $d$ 与初始化一致。现考虑节点 $1$ 作为可经过的中间节点，则 $d(i,j)=min(d(i,j),d(i,1)+d(1,j))$ ；然后逐步考虑更多的节点作为中间节点的情况；直到最后遍历所有节点，即得到最终结果。

~~~c++
for(int k=1;k<=n;++k){
	for(int i=1;i<=n;++i){
		for(int j=1;j<=n;++j){
            dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);
        }
    }
}
~~~



### Johnson

## 多层图的最短路

注意如果边的权值可以选择性的发生改变，考虑使用多层图。

## 一些模型

### 状压+最短路

状压+最短路，是将状态作为节点，状态之间的转移作为边，转移的代价作为权值，来计算某个状态到另一个状态的最小代价。与 **状压dp** 和 **状压dfs** 的思想有一定的相似性。

[软件补丁问题](https://www.luogu.com.cn/problem/P2761)
**关键字**：状压，最短路
**题意**：现有 $n$ 个错误，$m$ 个补丁。每个补丁只有在包含错误集合 $B1$，不包含错误集合 $B2$ 中任意元素的时候可以使用；使用效果为在 $t$ 时间内消除集合 $F1$ 的错误，并引入集合 $F2$ 的错误。求消除所有错误的最短时间，无解则输出 $0$。
**题解**：先观察题目中的 $n$ 和 $m$ 都较小，考虑使用状压。对于每个补丁，错误集合 $B1$ 用二进制表示（$0$ 表示该错误不属于集合，$1$ 则表示属于），再转化为十进制数 $b1$，若当前状态 $(f$ & $b1) $ ^ $b1==0$ ,则说明该状态包含错误集合 $B1$ ；对 $B2$，则是 $(f$ & $b2)==0$说明不包含 $B2$ 内的任何错误；对满足补丁使用条件的状态建立一条到 $(f$&$f1)|f2$ 状态，权值为 $t$ 的边。然后从满错误状态跑最短路，求到 $0$ 的距离即可。

~~~c++
int n,m,f[MAXN][5],t[MAXN],d[MAXM];
string str;
struct edge{
	int to,w;
	edge(){};
	edge(int To,int W){to=To,w=W;}
};
vector<edge>G[MAXM];
void dij(int s)
{
	memset(d,127,sizeof(d));
	priority_queue<pair<int,int>>que;
	que.push(make_pair(0,s));
	d[s]=0;
	while(!que.empty()){
		pair<int,int> p=que.top();
		que.pop();
		int u=p.second;
		if(d[u]<p.first) continue;
		for(auto e:G[u]){
			int to=e.to;
			if(d[to]>d[u]+e.w){
				d[to]=d[u]+e.w;
				que.push(make_pair(d[to],to));
			}
		}
	}
}
void solve()
{
	cin>>n>>m;
	for(int i=1;i<=m;++i){
		cin>>t[i]>>str;
		for(int j=0;j<n;++j) {
			if(str[j]=='+'){
				f[i][1]+=(1<<j);  //先&1在^1 ==0
			}
			if(str[j]=='-'){
				f[i][2]+=(1<<j);  //&2 ==0
			}
		}
		cin>>str;
		for(int j=0;j<n;++j){
			if(str[j]!='-'){
				f[i][3]+=(1<<j);  //&3表示解决问题
			}
			if(str[j]=='+'){
				f[i][4]+=(1<<j); //|4加入问题
			}
		}
	}
	for(int i=((1<<n)-1);i>=0;--i){
		for(int j=1;j<=m;++j){
			if(((i&f[j][1])^f[j][1])==0&&(i&f[j][2])==0){
				int to=((i&f[j][3])|f[j][4]);
				G[i].push_back(edge(to,t[j]));
			}
		}
	}
	dij((1<<n)-1);
	if(d[0]==2139062143) d[0]=0;
	cout<<d[0];
	return;
}
~~~



### 删边最短路

该模型解决的是如何求 **删除图上任意一条边后的最短路** ？
先定义一些概念，方便后文讲述：**最短路边构成的边集合用 $E$ 表示**，**编号为 $i$ 的边为 $e_i$**。
首先讨论删边的位置：
若**删边不在 $E$ 上**，则直接输出原图最短路的长度。
若**删边在 $E$ 上**，则问题比较复杂。若直接删除改边，重跑跑一遍最短路，则时间复杂度最坏为 $O(nmlogn)$，这样必然会超时，因而我们不能逐一考虑 $E$ 中每条边被删除后对最短路的影响；而是反过来，**考虑图上任意一条非最短路边成为新的最短路时对 $E$ 中每条边答案的影响**，即必须区间修改。
接下来考虑这个新的最短路能更新 $E$ 中哪些边的答案。因为不容易考虑某条边的最短路，我们先考虑边上的点。首先可以得到一个定理：**删除一条边后，图上的新最短路$E'$ 必然只能与原图最短路 $E$ 有公共前缀与公共后缀。**通俗来讲，$E'$ 只能与 $E$ 在首尾有重合，而不能有多段重合（这其实很好证明，假设可以有多段，则说明有多端非重合，其中只能有一段是因为删边不能通过导致，由于最短路的性质，其他几段的长度必然大于等于直接选取在 $E$ 上的简单路径，与最短路矛盾，故只能有一段 ）。现做出以下定义：对于每个点 $x$， 设 $l_x$ 表示最小的 $i$，使得在某条 $1→x$ 的最短路上，$e_i$ 是第一条 $E$ 上的不在其中的边；$r_x$ 表示最大的 $i$，使得在某条 $x→n$ 的最短路上，$e_i$ 是最后一条 $E$ 上的不在其中的边。则对每条非最短路边 $e$，我们设它的端点为 $u,v$，则用 $d_{(1,u)} + w_{u,v}+d_{(v,n)}$ 更新区间 $[e_{l_u},e_{r_v}]$，用 $d_{(1,v)} + w_{v,u}+d_{(u,n)}$ 更新区间 $[e_{l_v},e_{r_u}]$。
接下来，只要有方法快速求出上面的几个参量的值即可。对于距离 $d$ ，可以分别从源点和终点跑最短路得到。先考虑 $l_x$ 与 $r_x$ ，对于 $E$ 上的边，直接更新其为 $i$ 与 $i-1$ 即可（$i$ 为边编号）；对于非最短路边，也按照求最短路的顺序更新，若边 $(u,v)$ 满足 $d_{1,u}+w_{u,v}=d_{1,v}$，则 $l_v=min⁡(l_v,l_u)$。可以将点按 $d$ 值排序，就不用重新跑最短路了。
最后，由于是区间修改，还需要使用线段树或者其他数据结构来维护 $E$ 中每条边的答案。这样子，最终的时间复杂度就为 $O(mlogn)$。

例题：[Problem - 1163F - Codeforces](https://codeforces.com/problemset/problem/1163/F)
**题意**：给一个 $n$ 个点，$m$ 条边的无向图，每条边连接点 $u, v$，并且有个长度 $w$。有 $q$ 次询问，每次询问给你一对 $t, x$，表示**仅当前询问**下，将 $t$ 这条边的长度修改为 $x$，请你输出当前 $1$ 到 $n$ 的最短路长度。
**题解**：可以把询问分成四种情况：
1、将非最短路上的边的权值减少，分别求出$d_{(1,u)} + w_{u,v}+d_{(v,n)}$ ， $d_{(1,v)} + w_{v,u}+d_{(u,n)}$ ，取和原最短路的三者最小值即可。
2、将最短路上的边的权值减小，此时直接最短路减去变化值即可。
3、将非最短路上的边的权值增大，直接输出最短路。
4、将最短路上的边的权值增大，输出 原最短路+变化值与删边最短路的小值即可。 

**拓展**：感觉对图/树这种非线性结构的区间做一些操作，都会想办法让其区间变成线性，然后是用线段树等数据结构。



# 最小生成树

$kruskal$算法(使用并查集)：

~~~c++
#include <iostream>
#include <algorithm>
using namespace std;
const int MAXM = 2e5 + 10;
const int MAXN = 5e3 + 10;

struct edge {
	int u, v, w;
}G[MAXM];
int n, m, x[MAXM], y[MAXM], z[MAXM];
int fa[MAXN], ra[MAXN];

int find(int s)
{
	return fa[s] == s ? s : fa[s] = find(fa[s]);
}

void unite(int x, int y)
{
	int a = find(x), b = find(y);
	if (ra[a] > ra[b]) fa[b] = a;
	else if (ra[a] < ra[b]) fa[a] = b;
	else {
		fa[a] = b; ra[b]++;
	}
	return;
}

bool cmp(edge x, edge y)
{
	return x.w < y.w;
}

int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		cin >> x[i] >> y[i] >> z[i];
		G[i].u = x[i];
		G[i].v = y[i];
		G[i].w = z[i];
	}
	sort(G + 1, G + m + 1, cmp);
	for (int i = 1; i <= n; i++) fa[i] = i;
	int sum = 0;
	for (int i = 1; i <= m; i++) {
		if (find(G[i].u) != find(G[i].v)) {
			unite(G[i].u, G[i].v);
			sum += G[i].w;
		}
	}
	int q = 0;
	for (int i=1;i<=n;i++){
		if (find(i) == i) q++;
	}
	if (q != 1) cout<<"orz";
	else cout << sum;
	return 0;
}
~~~

$prim$算法（仿迪杰斯特拉）：

~~~c++
mincost[1] = 0; int rec = 0;
	while (true) {
		int v = -1;
		for (int i = 1; i <= N; i++) {
			if (used[i] == 0 && (v == -1 || mincost[i] < mincost[v]) && mincost[i]!=2034567890) v = i;
		}
		if (v == -1) break;
		rec = rec + mincost[v];
		used[v] = 1;
		for (int i = 1; i <= N; i++) {
			mincost[i] = min(mincost[i], cost[v][i]);
		}
	}
~~~

## 唯一MST

判断方法：
1、遍历所有树边，**刨除**树边确认是否可以**重新构造**。
2、计算**非严格次小生成树的值**，若一样则不唯一。

例题：https://vjudge.net/contest/565164#problem/I 板子。

## 次小生成树

**定义**：对于一张无向图 $G$，我们假令 $G$ 的一颗最小生成树为 $T$，并且一颗非最小生成树为 $T1$，那么如果不存在任意一颗 $G$ 的生成树 $T2$ 使得 $W(T)<W(T2)<W(T1)$，则称 $T1$ 为 $G$ 的次小生成树。

**非严格次小生成树**： 权值和最小生成树可以相等。

**严格次小生成树**：保证树的权值小于最小生成树。

[P4180 [BJWC2010\] 严格次小生成树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P4180)（$kruskal$算法+树上倍增$lca$维护/树上线段树维护）

次小生成树的**发散题**：

**链接**：[Qin Shi Huang's National Road System - HDU 4081 - Virtual Judge (vjudge.net)](https://vjudge.net/problem/HDU-4081)
**题目大意**：有 $n$ 个坐标和人口给出的城市，秦始皇要修路将它们连接起来，可以正常花费距离的代价修路，也可用一条魔法路径连接两个城市，求 (魔法路径连接城市的人口/正常修路的代价）的最大值。
**题目解法**：先求出最小生成树并得到全职，然后遍历所有边。若边属于 $MST$ ，则直接减去改变的权值；若不属于，则查找树中与该边两端点为首位的路径的最大权值，然后计算求解取最大值即可。思路与求次小生成树一致。（但是我是用 $lca$ 倍增 $+$ $kruscal$ $+$ 离散处理依旧 $TLE$ ，后来直接用 $dfs$ 暴力更新过了，我不理解）
**代码**：详见链接中提交。



# 二分图

二分图又称作偶图，是图论中的一种特殊模型。
设 $G=(V,E)$ 是一无向图，若顶点 $V$ 可分割为两个互不相交的子集 $(A,B)$，且图中的每条边 $(i,j)$ 所关联的两个顶点 $i$ 和 $j$ 分属这两个不同的顶点集 $(i ∈ A,j ∈ B)$，则称图 G 为二分图。
其充要条件是：**图 G 中至少存在两个点，且图中所有回路的长度均为偶数。**

**匹配**：在二分图中，由一些边组成的集合，这些边**没有共同的顶点**。

**最大匹配**：在二分图所有可能的匹配中，边数最多的匹配称为最大匹配。

**完全匹配**：对于二分图的其中一个集合中的每个顶点，都能在另一个集合中找到一个顶点与之相连形成匹配边，即一个集合中的所有顶点都参与到匹配中。

**完美匹配**：不仅一个集合中的所有顶点都参与到匹配中，而且另一个集合中的所有顶点也都参与到匹配中，也就是两个集合中的顶点一一对应地被匹配。通常要求二分图两个集合中的顶点数量相等且存在完全匹配时，这个完全匹配就是完美匹配。

**最小点覆盖**：找到**最少**的一些**点**，使二分图所有的边都**至少有一个端点**在这些点之中。倒过来说就是，删除包含这些点的边，可以删掉所有边。

## konig定理

>**一个二分图中的最大匹配数等于这个图中的最小点覆盖数。**



# 欧拉路径

**欧拉路径**为无向图/有向图中经过所有边但每条边只经过一次的路径。
欧拉路径分为欧拉回路与欧拉路径，即路劲终点是否与起点相同。

- **欧拉回路**
  1. 无向图：所有点的度数都是偶数。
  2. 有向图：所有点出度等于入度。
- **欧拉通路**
  1. 无向图：相比欧拉回路，可以看成有一个起点，一个终点，即可以有两个点的度数是奇数，开始搜索时，起点为其中一个奇点（七桥问题
  2. 有向图：同理，相比欧拉回路，可以看成有一个起点，一个终点，即可以有一个起点是出度=入度+1，一个终点是入度=出度+1
  3. 注意欧拉回路是欧拉路径的一种特殊情况，即要注意考虑没有奇点/所有点出入度都相同的情况。

判断直接通过遍历点的**入度**和**出度**即可。

如果要求完整的路径，可以使用 $Hierholzer$ 算法。该算法的精髓是当每次访问一条边的时候，删除这条边，当遍历完一个节点所连的所有节点后，才将该节点入栈，最后将栈中的节点反转，即可得到欧拉路径。时间复杂度为 $O(V+E)$。

~~~c++
vector<int>G[MAXN];
stack<int>ans;
int now[MAXN]; //now-记录某点已经访问到第几条边 
void Hierholzer(int s)
{
    for(int i=now[s];i<G[s].size();i=now[s]) 
    {
        now[s]++;
        Hierholzer(G[s][i]);
    }
    ans.push(s);
    return;
}
~~~

例题：[Problem - 1981D - Codeforces](https://codeforces.com/problemset/problem/1981/D)
题解：这道题是一个构造题，详情可见 题目训练。



# **拓扑排序**

**拓扑排序**是对**DAG**（有向无环图）上的节点进行排序，使得对于每一条有向边 u→v ， u 都在 v 之前出现。简单地说，是在不破坏节点**先后顺序**的前提下，把**DAG**拉成一条**链**。如果以游戏中的科技树*（虽然名字带树，其实常常不是树而只是DAG）*举例，拓扑排序就是找到一种**可能的**点科技树的**顺序**。

![算法学习笔记(53): 拓扑排序](https://pic1.zhimg.com/v2-ecb3af795e137fb78582689b9270d28d_720w.jpg?source=172ae18b)

拓扑排序最经典的算法是**Kahn算法**。时间复杂度为n*m，其中，n代表点，m代表边。

~~~c++
int deg[MAXN],a[MAXN];  //其中deg是入度，a是排序后的数组
   
bool toposort(int n)
{
    int cnt=0;
    queue <int> que;
    for (int i=1;i<=n;i++){
        if (deg[i]==0) que.push(i);
    }
    while(!que.empty()){
        int u=que.front();
        a[++cnt]=u;
        que.pop();
        for (int i=0;i<G[u].size();i++){     //G是储存边的vector容器
            int e=G[u][i].to;
            deg[e]--;
            if(deg[e]==0) que.push(e);
        }
    }
    return cnt==n;  //是否能排序 (若未成功则说明有环)
}
~~~

**例题**：洛谷P1347



>**给出一个无向图，求图中环上的节点数目**

可以用拓扑排序来判断图中是否有环。







# 强连通分量

### 定义

**连通**：**无向图**中，从任意点 $i$ 可以到达 $j$ 。

**强连通**：**有向图**中，从任意点 $i$ 可以到达 $j$ 。

**弱联通**：把**有向图看成无向图**时，从任意点 $i$ 可以到达 $j$ 。

**强连通分量**是有向图的**极大**的强连通子图。所谓“极大”意味着，把图划分为若干个强连通分量后，不存在两个强连通分量相互可达。

### **核心思想**

实现强连通分量的基本思路，是通过 **dfs** 从根节点开始遍历图，记录每一个点的**遍历序号** $(dfsn(i))$ 与通过有向边**可以回溯到的最早遍历序号** $(low(i))$，然后根据这两个点的值来确定强连通分量。

>![img](https://pic3.zhimg.com/80/v2-e7e7a4b03fac528b20756592334e03e2_720w.webp)

以 $1$ 为根节点开始进行遍历，注意，该dfs遍历是先进行传递遍历，再回溯进行值的读出。

考虑 $1$，则 $dfsn(1) = 1, low(1) = 1$。按序遍历，则到第二个点 $dfsn(2) = 2,low(2) = 2$， 第三个点中 $dfsn(3) = 3, low(3) = 3$，而因为第三个点可以通过有向边指向 $1$ ，所以 $low(3)$ 更新为 $1$ , 此时 $3$ 结束，则回溯到 $2$ ，$low(2)$ 也更新为 $1$ 。$2$ 开始继续遍历，则 $dfsn(4)=4,low(4)=4$ ,结束，回到 $2$ ，再回到 $1$。那么当遍历完全结束后，得到 $low$ 值如图：

>![img](https://pic3.zhimg.com/80/v2-b9d5bb59070317978fbfff3b224f3402_720w.webp)
>
>*不难看出，其中各个颜色的部分即为强连通分量。*

而当 **$dfs(n) = low(n)$** 时，表明 $n$ 点不可能通往与更早的时间点，可以得出该点是一个强连通分量的**根**。而为了统计以 $n$ 点为根的强连通分量还有什么点，可以构建一个**栈**，当**遍历的时候将点 $i$ 入栈**，如果访问到 $dfs(n) = low(n)$ 的点时，则**进行出栈操作直至 $n$ 点出栈**，其中出栈的点都与 $n$ 在同一个强连通分量中。

比如当遍历进行到 $4$ 的时候，栈中元素分别为 $1,2,3,4$ ，得到 $dfs(n) = low(n)$ ，则将 $4$ 弹出，$5,6,7,8$ 也是同理，不断弹出至 $5$ 弹出为止。

### 代码实现

~~~c++
stack<int> stk;
// instk：是否在栈中  scc：每个点所属的强连通分量编号  cscc：强连通分量的数量
int dfsn[MAXN], low[MAXN], instk[MAXN], scc[MAXN], cnt, cscc;
void tarjan(int p)
{
    low[p] = dfsn[p] = ++cnt;
    instk[p] = 1;
    stk.push(p); // 进栈
    for (auto q : edges[p])
    {
        if (!dfsn[q]) // 未访问过
        {
            tarjan(q); // 递归地搜索
            low[p] = min(low[p], low[q]);
        }
        else if (instk[q]) // 访问过，且q可达p
            low[p] = min(low[p], dfsn[q]);
        //这里写成 low[p] = min(low[p], low[q]);应该更好,不过应该没有影响
        
        ////2023.12.28 不可以写成 low[p]=min(low[p],low[q]),因为如果指向的节点已经被弹出栈
        ////说明该节点q和正在访问的节点p属于不同的强连通分量。
        ////但是p可以指向q，因此q不存在指向p的边，那么q的low值应该小于p。
        ////但是由于深度搜索的局限性，导致q先被访问，因而得到更高的low值
        ////该代码的存在是限制此bug的产生。
        
        //因为即使q的low可以更新，但是此时还没有回溯到q，q的信息没有更新完全，
        //low[q]依旧可能与dfsn[q]相等
        //low[q]的意义严谨来说是可以直接到达的最小dfsn序值
        //只要low[p]与dfsn[p]不相等就可以说明不是根
  		//2024.10.23-证明已更新
        
        //2025.4.25
        //low在这里定义为，最多经过一次反向边能够到达的最小dfsn序值
        //如果修改为为low[p]=min(low[p],low[q]),求强连通分量不会出错
        //但是求割点和桥时会有问题
    }
    if (low[p] == dfsn[p]) // 回溯后发现强连通分量的根
    {
        int top;
        cscc++;
        do
        {
            top = stk.top();
            stk.pop();
            instk[top] = 0;
            scc[top] = cscc; // 记录所属的强连通分量
        } while (top != p); // 直到弹出p才停止
    }
}
~~~

~~~c++
stack<int> stk;
int dfsn[MAXN], low[MAXN], instk[MAXN], scc[MAXN], cnt, cscc;
void tarjan(int p)
{
    low[p] = dfsn[p] = ++cnt;
    instk[p] = 1;
    stk.push(p); 
    for (auto q : edges[p])
    {
        if (!dfsn[q]) 
        {
            tarjan(q); 
            low[p] = min(low[p], low[q]);
        }
        else if (instk[q]) 
            low[p] = min(low[p], dfsn[q]);
    }
    if (low[p] == dfsn[p]) 
    {
        int top;
        cscc++;
        do
        {
            top = stk.top();
            stk.pop();
            instk[top] = 0;
            scc[top] = cscc; // 记录所属的强连通分量
        } while (top != p); // 直到弹出p才停止
    }
}
~~~



因为图不一定是强连通的，因而需要一所有点为根节点进行一次遍历。

~~~c++
for (int i = 1; i <= n; ++i)
    if (!dfsn[i])
        tarjan(i);
~~~

### 拓展

给出一个**有向无环图**，如果要将它变为一个**强连通图**，需要的最小步骤数为**入度为零的点**的个数和**出度为零**的点的个数的较大值。



## 割点和桥

### 定义

如果删除**无向图**中的某个**点**会使无向图的**连通分量数**增多，则把这个点称为**割点**。

如果删除**无向图**中的某条**边**会使无向图的连通分量数增多，则把这个点称为**割边**或**桥**。

### 核心思想

同样是通过**tarjan**算法。首先递归遍历得到每个点的 $dfsn(n), low(n)$ ，那么如果某个点的 $dfsn(n) <=$ 他的子节点的 $low(m)$ ，则表明该点的子树，无法通过其他途径回到比它更早的点，而只能通过它，即可得到点 $n$ 为割点。

有一种特殊情况，即当 $n$ 是根节点时，则只要有**两个及以上子节点**，则说明根节点是割点。

~~~c++
int dfsn[MAXN], low[MAXN], cnt;
vector<int> cut; // 存储所有割点
void tarjan(int p, bool root = true)
{
    int tot = 0;
    low[p] = dfsn[p] = ++cnt;
    for (auto q : edges[p])
    {
        if (!dfsn[q])
        {
            tarjan(q, false);
            low[p] = min(low[p], low[q]);
            tot += (low[q] >= dfsn[p]); // 统计满足low[q] >= dfsn[p]的子节点数目
        }
        else
            low[p] = min(low[p], dfsn[q]);
    }
    if (tot > root) // 如果是根，tot需要大于1；否则只需大于0
        cut.push_back(p);
}
~~~

类似的，求**桥**的时候，只需要某个点的 $dfsn(n) <$ 他的子节点的 $low(m)$，则说明该边是桥。

与求**割点**不同的是，某个点不能通过指向其父节点的通路更新 $low$ 值。

~~~c++
vector<pair<int, int>> bridges;
int dfsn[MAXN], low[MAXN], fa[MAXN], cnt;
void tarjan(int p)
{
    low[p] = dfsn[p] = ++cnt;
    for (auto to : edges[p])
    {
        if (!dfsn[to])
        {
            fa[to] = p; // 记录父节点
            tarjan(to);
            low[p] = min(low[p], low[to]);
            if (low[to] > dfsn[p])
                bridges.emplace_back(p, to);
        }
        else if (fa[p] != to) // 排除父节点
            low[p] = min(low[p], dfsn[to]);
    }
}
~~~



# 传递闭包

从数学上来说，传递闭包是在集合 $X$ 上求包含关系 $R$ 的最小传递关系。

从关系图的角度来说，就是如果原关系图上有 $i$ 到 $j$ 的**路径**，则其传递闭包的关系图上就应有从 $i$ 到 $j$ 的**边**。通俗地讲，就是确定每个点是否能到达其他每个点。

而这，把Floyd最短路算法稍微改一下即可。设 $E$ 是原来的关系矩阵，则可以这样写：

```c++
for (int k = 1; k <= n; ++k)
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            if (E[i][k] && E[k][j])
                E[i][j] = 1;
```

复杂度为 $O(n^3)$。



# 差分约束

差分约束用来求解**不等式组的解**的问题。

假设现有不等式组
$$
\begin{cases}
x_1-c_1 \le x_2\\
x_2-c_2 \le x_3\\
x_3+c_3 \le x_4
\end{cases}
$$
如果我们将不等式组转化为下列形式：

$$
\begin{cases}
x_1 \le x_2 + c_1\\
x_2 \le x_3 + c_2\\
x_3 \le x_4 - c_3
\end{cases}
$$
该形式与**最短路问题**中的 $dis[i]<=dis[j]+w$ 十分类似，因此我们可以考虑将变量 $x_1$ 看成节点的最短路 $dis[i]$ 的等价，进而抽象出一张图，在其上跑最短路即可得到不等式的解。但是如何确定源点？容易发现，无论以哪个点为源点，求出来的结果都是一致的（在保证连通性的情况下），因此考虑加入一个超级源点 $x_0$ ，$x_0$ 通过权值为 $w$ 的边指向所有节点。可以证明，此时求最短路的结果与原问题在不超过 $w$ 范围下的**最大解**一致（证明如下：直观理解，该不等式与算法抽象建模出来的图是**等价的**，这可以用 $bellmanford$ 的算法思路理解， 而最短路算法相当于每次都尽量让不等式取等，因此最后得到的结果就会是最大值）。如果要求**最小解**，则更新不等号方向为 $x_2 \ge x_1 - c_1 $ ，然后转化为求最长路问题，其他建模方式与最大解一致。

由于原不等式是有可能无解的，因此考虑无解不等式转化的图的性质。容易想到，当图存在**负环**时，不等式无解（因为没有最短路，如果是求最长路则相反）。因此考虑使用 $SPFA$ 来解决问题。

代码参考 $SPFA$ 部分。



















