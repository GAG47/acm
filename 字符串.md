# 字符串基础

一些关于字符串的常见操作：

- **char数组**：用cin、cin.getline输入，其中cin遇到空格断开，getline可以收入空格。

​       **string数组**，用cin、getline输入，区别同上。

- scanf和sscanf都是用来进行输入的，只不过scanf的输入源是stdin，而sscanf的输入源是字符（char[]）。sscanf可以根据指定的格式，向变量里面传递数据。 比如sscanf（str,"%d:%d:%d",year,month,day）,str="2023:2:7"，则可以得到对应的时间
- 

# 字符串哈希

基本思想：Hash 的核心思想在于，将输入映射到一个值域较小、可以方便比较的范围。

**双值哈希**：

~~~c++
typedef unsigned long long ull;
ull base = 131;
ull mod1 = 212370440130137957, mod2 = 1e9 + 7;

ull get_hash1(std::string s) {
  int len = s.size();
  ull ans = 0;
  for (int i = 0; i < len; i++) ans = (ans * base + (ull)s[i]) % mod1;
  return ans;
}

ull get_hash2(std::string s) {
  int len = s.size();
  ull ans = 0;
  for (int i = 0; i < len; i++) ans = (ans * base + (ull)s[i]) % mod2;  
  return ans;
}

bool cmp(const std::string s, const std::string t) {
  bool f1 = get_hash1(s) != get_hash1(t);
  bool f2 = get_hash2(s) != get_hash2(t);
  return f1 || f2;
}
~~~

## 字符串匹配

现加色求出模式串的哈希值后，求出文本串每个长度为模式串长度的子串的哈希值，分别与模式串的哈希值比较即可。



# KMP算法

**KMP算法**（全称Knuth-Morris-Pratt字符串查找算法，由三位发明者的姓氏命名）是可以在**文本串s**中快速查找**模式串p**的一种算法。

## **PMT**

**PMT**（Partial Match Table，**部分匹配表**）是一种数据表，也被称为**前缀函数**。对于一个字符串而言，既是它的前缀又是它的后缀的字符串称为**border**，pmt则表示 $s[1,...,i-1,i]$ 的最大border。举个例子：**p** 是一个字符串，则它的 **PMT$[ i ]$** 表示从 **p[0]** 开始往后数，从 **p[i]** 开始往前数，在保证二者始终相同的情况下的最大步值。

PMT的使用可以减小用 **p** 去逐一匹配 **s** 时的时间复杂度，在与暴力算法比较时，使用pmt的优势就十分明显。如，当 $s$ 是 **abababcabaa** ，$p$ 是**ababcabaa** 时:

![img](https://pic2.zhimg.com/80/v2-9d1c23a01a1f37510fda43475a8ed969_720w.webp)

此时，如果用一般的暴力算法，需要重现使指向p的 $j$ 指针回到0，然后将指向s的 $i$ 指针想下一个移动。而如果通过pmt，可以得到 $pmt[j-1]$ 为2 则将 $j$ 指针指向 $pmt[ j-1 ]$：

![img](https://pic4.zhimg.com/80/v2-91d8b7d6082d758ebac1ab378717270f_720w.webp)

因为pmt存储的是前缀和后缀相同的最长长度，所以中间不可能存在可以完全匹配的指针 **$i$** （否则pmt就会增大），可以直接进行**指针跳跃**，节省中间无效的搜索，从而大大的提高时间效率。

~~~c++
for (int i = 0, j = 0; i < s.length(); i++) {
	while (j && s[i] != p[j]) j = pmt[j - 1];
	if (s[i] == p[j])j++;
	if (j == p.length()) {
		// 对应操作
		j = pmt[j - 1]; //继续向下匹配
	}
}
//注意，这里i和j指针都是从0开始；如果要从1开始需要调整pmt[]中指针的位置
~~~

## 获取pmt

如果直接**暴力**，那么时间复杂度就是 $O(n^2)$ ，复杂度较高。

因而采用另外一种比较巧妙的做法：将p错开一位后，用**自己匹配自己**（即用自己的后缀匹配前缀）。

已知pmt[0]=0。

![img](https://pic1.zhimg.com/80/v2-7715906edbd181b2def0b8f1883b0d9c_720w.webp)

![img](https://pic1.zhimg.com/80/v2-756dfd984818b1cfca7420b64cab847c_720w.webp)

![img](https://pic2.zhimg.com/80/v2-c4769fb332833124b50057505dfb5d95_720w.webp)

![img](https://pic3.zhimg.com/80/v2-2bfca9e441f95030be16b74c0b9fbb2a_720w.webp)

![img](https://pic1.zhimg.com/80/v2-e3a3860d27d3cb45ffb7e884d64d246c_720w.webp)

![img](https://pic2.zhimg.com/80/v2-49a44760e3e8ec5ec9665dfeed67e2e9_720w.webp)

类似于上面应用pmt的方法，求pmt时候使用之前算出来的pmt，以提高效率。

~~~c++
for (int i = 1, j = 0; i < p.length(); i++) {
	while (j && p[i] != p[j]) j = pmt[j - 1];
	if (p[i] == p[j])j++;
	pmt[i] = j;
}
~~~

完整版子：

~~~c++
int pmt[MAXN];
void get_pmt(const string& s) {
    for (int i = 1, j = 0; i < s.length(); ++i) {
        while (j && s[i] != s[j]) j = pmt[j - 1];
        if (s[i] == s[j]) j++;
        pmt[i] = j;
    }
}
void kmp(const string& s, const string& p) {
    for (int i = 0, j = 0; i < s.length(); ++i) {
        while (j && s[i] != p[j]) j = pmt[j - 1];
        if (s[i] == p[j]) j++;
        if (j == p.length()) {
            //完全匹配
            j = pmt[j - 1];
        }
    }
}
~~~



# Z算法

类似于kmp中的**pmt**，**Z算法**中引入了一种称为**Z函数**的数据表，其中存储的是 $s$ 与 $s[i..n-1]$ 的**最大公共前缀**（LCP）。

例如，设有字符串`aabcaabcaaaab`，那么它的Z函数值如下表所示：

![img](https://pic2.zhimg.com/80/v2-60e17daa70312eb1481cf63b79ddd939_720w.webp)

如何获取 $z$ 函数？朴素的算法，直接暴力遍历，时间复杂度为 $O(n^2)$ ，显然是比较一般的。考虑以下优化：
现假设两个变量 $l,r$ ，表示 $l$ 小于等于 $i$ 的且 $r$ 最大的 $Z-BOX$ 区间（$Z-BOX$ 表示 $[i,i+z[i]-1]$），那么现在分两种情况：
① $i>r$ ，此时直接暴力获取 $z[i]$，同时更新 $l,r$。
② $i <=r$ ，因为 $s[l..r]$ 与 $s[0..r−l]$ 是相等的，因此 $s[i..r]$ 与 $s[i−l..r−l]$ 也是相等的。因此我们考虑 $Z[i-l]$，假如 $i+Z[i-l]-1<r$ ，则 $Z[i]=Z[i-l]$；否则说明 $Z-BOX$ 外的部分还有可以匹配的，此时暴力延长即可。
将两种情况综合考虑，得到写法如下：

**板子**：

~~~
void get_Z(const string &s)
{
    int n=s.size();
    for(int i=1,l=0,r=0;i<n;++i){
        if(z[i-l]<r-i+1){
            z[i]=z[i-l];
        } else{
            z[i]=max(r-i+1,0);
            while(i+z[i]<n&&s[z[i]]==s[i+z[i]]){
                z[i]++;
            }
            l=i,r=i+z[i]-1;
        }
    }
}
~~~

**一些应用：**

知道了Z函数的求法后，我们来看它的几个简单应用：



> **给出字符串 a,b ，求 a 的每个后缀与 b 的LCP。**

设 # 为字符集外字符，求 b+#+a 的Z函数，则 $a$ 的后缀 $a[i..]$ 与 $b$ 的 $LCP$ 为 $Z(|b|+1+i)$ 。



> **给出文本串 s 和模式串 p ，求 p 在 s 中的所有出现位置。**

这是KMP和字符串哈希的经典题目，但也可以用Z算法。设 # 为字符集外字符，求 p+#+s 的Z函数，则每一个 $Z(i)=|p|$ 都对应 $p$ 在 $s$ 中的一次出现。



> **求** s **的所有border。**

虽然这个是KMP裸题，但也可以用Z算法。求 $s$ 的Z函数。对于每一个 $i$ ，如果 $i+Z(i)=|s|$ ，说明这个Z-Box对应一个border。（注：与KMP不同，这里只是求所有border，不是求所有前缀的border）



> **求 s 的每个前缀的出现次数。**

求 s 的Z函数。对于每一个 i ，如果 Z(i) 不等于0，说明长度为 $Z(i),Z(i)−1,…,1$ 的前缀在此处各出现了一次，所以求一个后缀和即可。在这个问题中一般令 $Z(0)=|s|$ 。

```cpp
for (int i = n + 1; i < 2 * n + 1; ++i)
    S[z[i]]++;
for (int i = n; i >= 1; --i)
    S[i] += S[i + 1];
```



**例题**：
[P5410 【模板】扩展 KMP/exKMP（Z 函数） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)](https://www.luogu.com.cn/problem/P5410)
题解：对应用1的拙劣模仿罢了。



# 字典树（trie树）



# AC自动机

~~~c++
//std::ios::sync_with_stdio(false);
#include<bits/stdc++.h>
using namespace std;
const int MAXN = 1e6+10;
const int MAXM = 110*110;
const int mode = 1e9+7;
const int INF = 0x7fffffff;
const long long inf = 1e18;
typedef long long ll;
const int dx[] = { -1,0,1,0 }, dy[] = { 0,1,0,-1 };
#define lowbit(x) x&(-x)
#define debug(x) cout<<"?"<<x<<"?\n";
inline int read()
{
	int x=0,f=1;char ch=getchar();
	while (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}
	while (ch>='0'&&ch<='9'){x=x*10+ch-48;ch=getchar();}
	return x*f;
}

int n, t[MAXN][27], cnt = 0, fail[MAXN], ans[MAXN];
vector<int> vis[MAXN];

void update(const string& str, int k)
{
	int p = 0;
	for (int i = 0; i < str.size(); ++i) {
		register int j = str[i] - 'a';
		if (!t[p][j])
			t[p][j] = ++cnt;
		p = t[p][j];
	}
	vis[p].push_back(k);  //标记单词末位
	return;
}

void ask(const string& str)
{
	int p = 0, sum = 0;
	for (int i = 0; i < str.size(); ++i) {
		p = t[p][str[i] - 'a'];
		for (int j = p; j; j = fail[j]) {
			for(auto q : vis[j]) ans[q]++;
		}
	}
	return;
}

void bfs()
{
	queue<int>que;
	for (int i = 0; i < 26; ++i) 
    {
		if (t[0][i])
			que.push(t[0][i]);
	}

	while (!que.empty()) 
    {
		int u = que.front();
		que.pop();
		for (int i = 0; i < 26; ++i) 
        {
			if (t[u][i]) {
				fail[t[u][i]] = t[fail[u]][i];
				que.push(t[u][i]);
			}
			else
				t[u][i] = t[fail[u]][i];
		}
	}
	return;
}

void solve()
{
	string s;
	cin >> s;
	ask(s);
	
	int maxn = 0;
	for(int i=1;i<=n;++i)
    {
		cout << ans[i] << '\n';
	}
	
	return;
}

int main()
{
	cin>>n;
	if(n)
    {
		string s;
		for (int i = 1; i <= n; ++i) {
			cin>>s;
			update(s, i);
		}
		bfs();
		solve();
	}
	return 0;
}
~~~



# 后缀自动机

~~~c++
struct state{
	int fa,len,next[26];
}sam[MAXN];
int cnt=1,last=1;
void insert(int ch) //插入的时候要减'a'或者其他
{
	int cur=++cnt,p;
	sam[cur].len=sam[last].len+1;
	for(p=last;p&&!sam[p].next[ch];p=sam[p].fa)  //构建传递边
		sam[p].next[ch]=cur;
	int q=sam[p].next[ch];
	if(q==0){  //① 说明这个字母是全新的，需将其父节点设置为根节点
		sam[cur].fa=1;
	} else if(sam[p].len+1==sam[q].len){  //② 图中存在合法的父节点
		sam[cur].fa=q;
	} else {   //③ 父节点不合法 需要将其裂开
		int r=++cnt;  //新的节点 
		sam[r]=sam[q];  //r的父节点为q的父节点 将q的转移边复制给r
		sam[r].len=sam[p].len+1;
		for(;p&&sam[p].next[ch]==q;p=sam[p].fa)  //将指向q的转移边指向r
			sam[p].next[ch]=r;
		sam[cur].fa=sam[q].fa=r; //将新加入节点与q的父亲设置为r
	}
	last=cur;
}
~~~

---

## 广义后缀自动机

~~~c++
namespace gsa {
const int N = _;
struct State {
    int fa, len, next[26];
} G[N];
int cnt = 1;
namespace trie {
void insert(const string &s) {
    int p = 1;
    for (auto c : s) {
        int &q = G[p].next[c - 'a'];
        if (!q) q = ++cnt;
        p = q;
    }
}
} // namespace trie
int insert(int last, int ch) { // 1
    int cur = G[last].next[ch], p; // 2
    G[cur].len = G[last].len + 1;
    for (p = G[last].fa; p && !G[p].next[ch]; p = G[p].fa) // 3
        G[p].next[ch] = cur;
    int q = G[p].next[ch];
    if (q == 0) {
        G[cur].fa = 1;
    } else if (G[p].len + 1 == G[q].len) {
        G[cur].fa = q;
    } else {
        int r = ++cnt;
        G[r].fa = G[q].fa;
        for (int i = 0; i < 26; ++i) // 4
            if (G[G[q].next[i]].len)
                G[r].next[i] = G[q].next[i];
        G[r].len = G[p].len + 1;
        for (; p && G[p].next[ch] == q; p = G[p].fa)
            G[p].next[ch] = r;
        G[cur].fa = G[q].fa = r;
    }
    return cur;
}
void bfs() {
    queue<pair<int, int>> Q;
    for (int i = 0; i < 26; ++i)
        if (G[1].next[i]) Q.emplace(1, i);
    while (Q.size()) {
        auto [f, ch] = Q.front();
        Q.pop();
        int p = insert(f, ch);
        for (int i = 0; i < 26; ++i)
            if (G[p].next[i]) Q.emplace(p, i);
    }
}
} // namespace gsa
~~~

